
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.amazonLocationClient = {}));
})(this, (function (exports) { 'use strict';

    const getHttpHandlerExtensionConfiguration$3 = (runtimeConfig) => {
        let httpHandler = runtimeConfig.httpHandler;
        return {
            setHttpHandler(handler) {
                httpHandler = handler;
            },
            httpHandler() {
                return httpHandler;
            },
            updateHttpClientConfig(key, value) {
                httpHandler.updateHttpClientConfig(key, value);
            },
            httpHandlerConfigs() {
                return httpHandler.httpHandlerConfigs();
            },
        };
    };
    const resolveHttpHandlerRuntimeConfig$3 = (httpHandlerExtensionConfiguration) => {
        return {
            httpHandler: httpHandlerExtensionConfiguration.httpHandler(),
        };
    };

    var HttpAuthLocation$4;
    (function (HttpAuthLocation) {
        HttpAuthLocation["HEADER"] = "header";
        HttpAuthLocation["QUERY"] = "query";
    })(HttpAuthLocation$4 || (HttpAuthLocation$4 = {}));

    var HttpApiKeyAuthLocation$4;
    (function (HttpApiKeyAuthLocation) {
        HttpApiKeyAuthLocation["HEADER"] = "header";
        HttpApiKeyAuthLocation["QUERY"] = "query";
    })(HttpApiKeyAuthLocation$4 || (HttpApiKeyAuthLocation$4 = {}));

    var EndpointURLScheme$4;
    (function (EndpointURLScheme) {
        EndpointURLScheme["HTTP"] = "http";
        EndpointURLScheme["HTTPS"] = "https";
    })(EndpointURLScheme$4 || (EndpointURLScheme$4 = {}));

    var AlgorithmId$4;
    (function (AlgorithmId) {
        AlgorithmId["MD5"] = "md5";
        AlgorithmId["CRC32"] = "crc32";
        AlgorithmId["CRC32C"] = "crc32c";
        AlgorithmId["SHA1"] = "sha1";
        AlgorithmId["SHA256"] = "sha256";
    })(AlgorithmId$4 || (AlgorithmId$4 = {}));

    var FieldPosition$4;
    (function (FieldPosition) {
        FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
        FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
    })(FieldPosition$4 || (FieldPosition$4 = {}));

    const SMITHY_CONTEXT_KEY$3 = "__smithy_context";

    var IniSectionType$4;
    (function (IniSectionType) {
        IniSectionType["PROFILE"] = "profile";
        IniSectionType["SSO_SESSION"] = "sso-session";
        IniSectionType["SERVICES"] = "services";
    })(IniSectionType$4 || (IniSectionType$4 = {}));

    var RequestHandlerProtocol$4;
    (function (RequestHandlerProtocol) {
        RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
        RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
        RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
    })(RequestHandlerProtocol$4 || (RequestHandlerProtocol$4 = {}));

    let HttpRequest$4 = class HttpRequest {
        constructor(options) {
            this.method = options.method || "GET";
            this.hostname = options.hostname || "localhost";
            this.port = options.port;
            this.query = options.query || {};
            this.headers = options.headers || {};
            this.body = options.body;
            this.protocol = options.protocol
                ? options.protocol.slice(-1) !== ":"
                    ? `${options.protocol}:`
                    : options.protocol
                : "https:";
            this.path = options.path ? (options.path.charAt(0) !== "/" ? `/${options.path}` : options.path) : "/";
            this.username = options.username;
            this.password = options.password;
            this.fragment = options.fragment;
        }
        static clone(request) {
            const cloned = new HttpRequest({
                ...request,
                headers: { ...request.headers },
            });
            if (cloned.query) {
                cloned.query = cloneQuery$5(cloned.query);
            }
            return cloned;
        }
        static isInstance(request) {
            if (!request) {
                return false;
            }
            const req = request;
            return ("method" in req &&
                "protocol" in req &&
                "hostname" in req &&
                "path" in req &&
                typeof req["query"] === "object" &&
                typeof req["headers"] === "object");
        }
        clone() {
            return HttpRequest.clone(this);
        }
    };
    function cloneQuery$5(query) {
        return Object.keys(query).reduce((carry, paramName) => {
            const param = query[paramName];
            return {
                ...carry,
                [paramName]: Array.isArray(param) ? [...param] : param,
            };
        }, {});
    }

    let HttpResponse$4 = class HttpResponse {
        constructor(options) {
            this.statusCode = options.statusCode;
            this.reason = options.reason;
            this.headers = options.headers || {};
            this.body = options.body;
        }
        static isInstance(response) {
            if (!response)
                return false;
            const resp = response;
            return typeof resp.statusCode === "number" && typeof resp.headers === "object";
        }
    };

    function isValidHostname(hostname) {
        const hostPattern = /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/;
        return hostPattern.test(hostname);
    }

    function resolveHostHeaderConfig$3(input) {
        return input;
    }
    const hostHeaderMiddleware$3 = (options) => (next) => async (args) => {
        if (!HttpRequest$4.isInstance(args.request))
            return next(args);
        const { request } = args;
        const { handlerProtocol = "" } = options.requestHandler.metadata || {};
        if (handlerProtocol.indexOf("h2") >= 0 && !request.headers[":authority"]) {
            delete request.headers["host"];
            request.headers[":authority"] = request.hostname + (request.port ? ":" + request.port : "");
        }
        else if (!request.headers["host"]) {
            let host = request.hostname;
            if (request.port != null)
                host += `:${request.port}`;
            request.headers["host"] = host;
        }
        return next(args);
    };
    const hostHeaderMiddlewareOptions$3 = {
        name: "hostHeaderMiddleware",
        step: "build",
        priority: "low",
        tags: ["HOST"],
        override: true,
    };
    const getHostHeaderPlugin$3 = (options) => ({
        applyToStack: (clientStack) => {
            clientStack.add(hostHeaderMiddleware$3(options), hostHeaderMiddlewareOptions$3);
        },
    });

    const loggerMiddleware$3 = () => (next, context) => async (args) => {
        try {
            const response = await next(args);
            const { clientName, commandName, logger, dynamoDbDocumentClientOptions = {} } = context;
            const { overrideInputFilterSensitiveLog, overrideOutputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
            const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
            const outputFilterSensitiveLog = overrideOutputFilterSensitiveLog ?? context.outputFilterSensitiveLog;
            const { $metadata, ...outputWithoutMetadata } = response.output;
            logger?.info?.({
                clientName,
                commandName,
                input: inputFilterSensitiveLog(args.input),
                output: outputFilterSensitiveLog(outputWithoutMetadata),
                metadata: $metadata,
            });
            return response;
        }
        catch (error) {
            const { clientName, commandName, logger, dynamoDbDocumentClientOptions = {} } = context;
            const { overrideInputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
            const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
            logger?.error?.({
                clientName,
                commandName,
                input: inputFilterSensitiveLog(args.input),
                error,
                metadata: error.$metadata,
            });
            throw error;
        }
    };
    const loggerMiddlewareOptions$3 = {
        name: "loggerMiddleware",
        tags: ["LOGGER"],
        step: "initialize",
        override: true,
    };
    const getLoggerPlugin$3 = (options) => ({
        applyToStack: (clientStack) => {
            clientStack.add(loggerMiddleware$3(), loggerMiddlewareOptions$3);
        },
    });

    const TRACE_ID_HEADER_NAME$3 = "X-Amzn-Trace-Id";
    const ENV_LAMBDA_FUNCTION_NAME$3 = "AWS_LAMBDA_FUNCTION_NAME";
    const ENV_TRACE_ID$3 = "_X_AMZN_TRACE_ID";
    const recursionDetectionMiddleware$3 = (options) => (next) => async (args) => {
        const { request } = args;
        if (!HttpRequest$4.isInstance(request) ||
            options.runtime !== "node" ||
            request.headers.hasOwnProperty(TRACE_ID_HEADER_NAME$3)) {
            return next(args);
        }
        const functionName = process.env[ENV_LAMBDA_FUNCTION_NAME$3];
        const traceId = process.env[ENV_TRACE_ID$3];
        const nonEmptyString = (str) => typeof str === "string" && str.length > 0;
        if (nonEmptyString(functionName) && nonEmptyString(traceId)) {
            request.headers[TRACE_ID_HEADER_NAME$3] = traceId;
        }
        return next({
            ...args,
            request,
        });
    };
    const addRecursionDetectionMiddlewareOptions$3 = {
        step: "build",
        tags: ["RECURSION_DETECTION"],
        name: "recursionDetectionMiddleware",
        override: true,
        priority: "low",
    };
    const getRecursionDetectionPlugin$3 = (options) => ({
        applyToStack: (clientStack) => {
            clientStack.add(recursionDetectionMiddleware$3(options), addRecursionDetectionMiddlewareOptions$3);
        },
    });

    function resolveUserAgentConfig$3(input) {
        return {
            ...input,
            customUserAgent: typeof input.customUserAgent === "string" ? [[input.customUserAgent]] : input.customUserAgent,
        };
    }

    const IP_V4_REGEX = new RegExp(`^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$`);
    const isIpAddress = (value) => IP_V4_REGEX.test(value) || (value.startsWith("[") && value.endsWith("]"));

    const VALID_HOST_LABEL_REGEX = new RegExp(`^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$`);
    const isValidHostLabel = (value, allowSubDomains = false) => {
        if (!allowSubDomains) {
            return VALID_HOST_LABEL_REGEX.test(value);
        }
        const labels = value.split(".");
        for (const label of labels) {
            if (!isValidHostLabel(label)) {
                return false;
            }
        }
        return true;
    };

    const customEndpointFunctions = {};

    const debugId = "endpoints";

    function toDebugString(input) {
        if (typeof input !== "object" || input == null) {
            return input;
        }
        if ("ref" in input) {
            return `$${toDebugString(input.ref)}`;
        }
        if ("fn" in input) {
            return `${input.fn}(${(input.argv || []).map(toDebugString).join(", ")})`;
        }
        return JSON.stringify(input, null, 2);
    }

    class EndpointError extends Error {
        constructor(message) {
            super(message);
            this.name = "EndpointError";
        }
    }

    const booleanEquals = (value1, value2) => value1 === value2;

    const getAttrPathList = (path) => {
        const parts = path.split(".");
        const pathList = [];
        for (const part of parts) {
            const squareBracketIndex = part.indexOf("[");
            if (squareBracketIndex !== -1) {
                if (part.indexOf("]") !== part.length - 1) {
                    throw new EndpointError(`Path: '${path}' does not end with ']'`);
                }
                const arrayIndex = part.slice(squareBracketIndex + 1, -1);
                if (Number.isNaN(parseInt(arrayIndex))) {
                    throw new EndpointError(`Invalid array index: '${arrayIndex}' in path: '${path}'`);
                }
                if (squareBracketIndex !== 0) {
                    pathList.push(part.slice(0, squareBracketIndex));
                }
                pathList.push(arrayIndex);
            }
            else {
                pathList.push(part);
            }
        }
        return pathList;
    };

    const getAttr = (value, path) => getAttrPathList(path).reduce((acc, index) => {
        if (typeof acc !== "object") {
            throw new EndpointError(`Index '${index}' in '${path}' not found in '${JSON.stringify(value)}'`);
        }
        else if (Array.isArray(acc)) {
            return acc[parseInt(index)];
        }
        return acc[index];
    }, value);

    const isSet = (value) => value != null;

    const not = (value) => !value;

    const DEFAULT_PORTS = {
        [EndpointURLScheme$4.HTTP]: 80,
        [EndpointURLScheme$4.HTTPS]: 443,
    };
    const parseURL = (value) => {
        const whatwgURL = (() => {
            try {
                if (value instanceof URL) {
                    return value;
                }
                if (typeof value === "object" && "hostname" in value) {
                    const { hostname, port, protocol = "", path = "", query = {} } = value;
                    const url = new URL(`${protocol}//${hostname}${port ? `:${port}` : ""}${path}`);
                    url.search = Object.entries(query)
                        .map(([k, v]) => `${k}=${v}`)
                        .join("&");
                    return url;
                }
                return new URL(value);
            }
            catch (error) {
                return null;
            }
        })();
        if (!whatwgURL) {
            console.error(`Unable to parse ${JSON.stringify(value)} as a whatwg URL.`);
            return null;
        }
        const urlString = whatwgURL.href;
        const { host, hostname, pathname, protocol, search } = whatwgURL;
        if (search) {
            return null;
        }
        const scheme = protocol.slice(0, -1);
        if (!Object.values(EndpointURLScheme$4).includes(scheme)) {
            return null;
        }
        const isIp = isIpAddress(hostname);
        const inputContainsDefaultPort = urlString.includes(`${host}:${DEFAULT_PORTS[scheme]}`) ||
            (typeof value === "string" && value.includes(`${host}:${DEFAULT_PORTS[scheme]}`));
        const authority = `${host}${inputContainsDefaultPort ? `:${DEFAULT_PORTS[scheme]}` : ``}`;
        return {
            scheme,
            authority,
            path: pathname,
            normalizedPath: pathname.endsWith("/") ? pathname : `${pathname}/`,
            isIp,
        };
    };

    const stringEquals = (value1, value2) => value1 === value2;

    const substring = (input, start, stop, reverse) => {
        if (start >= stop || input.length < stop) {
            return null;
        }
        if (!reverse) {
            return input.substring(start, stop);
        }
        return input.substring(input.length - stop, input.length - start);
    };

    const uriEncode = (value) => encodeURIComponent(value).replace(/[!*'()]/g, (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`);

    const endpointFunctions = {
        booleanEquals,
        getAttr,
        isSet,
        isValidHostLabel,
        not,
        parseURL,
        stringEquals,
        substring,
        uriEncode,
    };

    const evaluateTemplate = (template, options) => {
        const evaluatedTemplateArr = [];
        const templateContext = {
            ...options.endpointParams,
            ...options.referenceRecord,
        };
        let currentIndex = 0;
        while (currentIndex < template.length) {
            const openingBraceIndex = template.indexOf("{", currentIndex);
            if (openingBraceIndex === -1) {
                evaluatedTemplateArr.push(template.slice(currentIndex));
                break;
            }
            evaluatedTemplateArr.push(template.slice(currentIndex, openingBraceIndex));
            const closingBraceIndex = template.indexOf("}", openingBraceIndex);
            if (closingBraceIndex === -1) {
                evaluatedTemplateArr.push(template.slice(openingBraceIndex));
                break;
            }
            if (template[openingBraceIndex + 1] === "{" && template[closingBraceIndex + 1] === "}") {
                evaluatedTemplateArr.push(template.slice(openingBraceIndex + 1, closingBraceIndex));
                currentIndex = closingBraceIndex + 2;
            }
            const parameterName = template.substring(openingBraceIndex + 1, closingBraceIndex);
            if (parameterName.includes("#")) {
                const [refName, attrName] = parameterName.split("#");
                evaluatedTemplateArr.push(getAttr(templateContext[refName], attrName));
            }
            else {
                evaluatedTemplateArr.push(templateContext[parameterName]);
            }
            currentIndex = closingBraceIndex + 1;
        }
        return evaluatedTemplateArr.join("");
    };

    const getReferenceValue = ({ ref }, options) => {
        const referenceRecord = {
            ...options.endpointParams,
            ...options.referenceRecord,
        };
        return referenceRecord[ref];
    };

    const evaluateExpression = (obj, keyName, options) => {
        if (typeof obj === "string") {
            return evaluateTemplate(obj, options);
        }
        else if (obj["fn"]) {
            return callFunction(obj, options);
        }
        else if (obj["ref"]) {
            return getReferenceValue(obj, options);
        }
        throw new EndpointError(`'${keyName}': ${String(obj)} is not a string, function or reference.`);
    };

    const callFunction = ({ fn, argv }, options) => {
        const evaluatedArgs = argv.map((arg) => ["boolean", "number"].includes(typeof arg) ? arg : evaluateExpression(arg, "arg", options));
        const fnSegments = fn.split(".");
        if (fnSegments[0] in customEndpointFunctions && fnSegments[1] != null) {
            return customEndpointFunctions[fnSegments[0]][fnSegments[1]](...evaluatedArgs);
        }
        return endpointFunctions[fn](...evaluatedArgs);
    };

    const evaluateCondition = ({ assign, ...fnArgs }, options) => {
        if (assign && assign in options.referenceRecord) {
            throw new EndpointError(`'${assign}' is already defined in Reference Record.`);
        }
        const value = callFunction(fnArgs, options);
        options.logger?.debug?.(`${debugId} evaluateCondition: ${toDebugString(fnArgs)} = ${toDebugString(value)}`);
        return {
            result: value === "" ? true : !!value,
            ...(assign != null && { toAssign: { name: assign, value } }),
        };
    };

    const evaluateConditions = (conditions = [], options) => {
        const conditionsReferenceRecord = {};
        for (const condition of conditions) {
            const { result, toAssign } = evaluateCondition(condition, {
                ...options,
                referenceRecord: {
                    ...options.referenceRecord,
                    ...conditionsReferenceRecord,
                },
            });
            if (!result) {
                return { result };
            }
            if (toAssign) {
                conditionsReferenceRecord[toAssign.name] = toAssign.value;
                options.logger?.debug?.(`${debugId} assign: ${toAssign.name} := ${toDebugString(toAssign.value)}`);
            }
        }
        return { result: true, referenceRecord: conditionsReferenceRecord };
    };

    const getEndpointHeaders = (headers, options) => Object.entries(headers).reduce((acc, [headerKey, headerVal]) => ({
        ...acc,
        [headerKey]: headerVal.map((headerValEntry) => {
            const processedExpr = evaluateExpression(headerValEntry, "Header value entry", options);
            if (typeof processedExpr !== "string") {
                throw new EndpointError(`Header '${headerKey}' value '${processedExpr}' is not a string`);
            }
            return processedExpr;
        }),
    }), {});

    const getEndpointProperty = (property, options) => {
        if (Array.isArray(property)) {
            return property.map((propertyEntry) => getEndpointProperty(propertyEntry, options));
        }
        switch (typeof property) {
            case "string":
                return evaluateTemplate(property, options);
            case "object":
                if (property === null) {
                    throw new EndpointError(`Unexpected endpoint property: ${property}`);
                }
                return getEndpointProperties(property, options);
            case "boolean":
                return property;
            default:
                throw new EndpointError(`Unexpected endpoint property type: ${typeof property}`);
        }
    };

    const getEndpointProperties = (properties, options) => Object.entries(properties).reduce((acc, [propertyKey, propertyVal]) => ({
        ...acc,
        [propertyKey]: getEndpointProperty(propertyVal, options),
    }), {});

    const getEndpointUrl = (endpointUrl, options) => {
        const expression = evaluateExpression(endpointUrl, "Endpoint URL", options);
        if (typeof expression === "string") {
            try {
                return new URL(expression);
            }
            catch (error) {
                console.error(`Failed to construct URL with ${expression}`, error);
                throw error;
            }
        }
        throw new EndpointError(`Endpoint URL must be a string, got ${typeof expression}`);
    };

    const evaluateEndpointRule = (endpointRule, options) => {
        const { conditions, endpoint } = endpointRule;
        const { result, referenceRecord } = evaluateConditions(conditions, options);
        if (!result) {
            return;
        }
        const endpointRuleOptions = {
            ...options,
            referenceRecord: { ...options.referenceRecord, ...referenceRecord },
        };
        const { url, properties, headers } = endpoint;
        options.logger?.debug?.(`${debugId} Resolving endpoint from template: ${toDebugString(endpoint)}`);
        return {
            ...(headers != undefined && {
                headers: getEndpointHeaders(headers, endpointRuleOptions),
            }),
            ...(properties != undefined && {
                properties: getEndpointProperties(properties, endpointRuleOptions),
            }),
            url: getEndpointUrl(url, endpointRuleOptions),
        };
    };

    const evaluateErrorRule = (errorRule, options) => {
        const { conditions, error } = errorRule;
        const { result, referenceRecord } = evaluateConditions(conditions, options);
        if (!result) {
            return;
        }
        throw new EndpointError(evaluateExpression(error, "Error", {
            ...options,
            referenceRecord: { ...options.referenceRecord, ...referenceRecord },
        }));
    };

    const evaluateTreeRule = (treeRule, options) => {
        const { conditions, rules } = treeRule;
        const { result, referenceRecord } = evaluateConditions(conditions, options);
        if (!result) {
            return;
        }
        return evaluateRules(rules, {
            ...options,
            referenceRecord: { ...options.referenceRecord, ...referenceRecord },
        });
    };

    const evaluateRules = (rules, options) => {
        for (const rule of rules) {
            if (rule.type === "endpoint") {
                const endpointOrUndefined = evaluateEndpointRule(rule, options);
                if (endpointOrUndefined) {
                    return endpointOrUndefined;
                }
            }
            else if (rule.type === "error") {
                evaluateErrorRule(rule, options);
            }
            else if (rule.type === "tree") {
                const endpointOrUndefined = evaluateTreeRule(rule, options);
                if (endpointOrUndefined) {
                    return endpointOrUndefined;
                }
            }
            else {
                throw new EndpointError(`Unknown endpoint rule: ${rule}`);
            }
        }
        throw new EndpointError(`Rules evaluation failed`);
    };

    const resolveEndpoint = (ruleSetObject, options) => {
        const { endpointParams, logger } = options;
        const { parameters, rules } = ruleSetObject;
        options.logger?.debug?.(`${debugId} Initial EndpointParams: ${toDebugString(endpointParams)}`);
        const paramsWithDefault = Object.entries(parameters)
            .filter(([, v]) => v.default != null)
            .map(([k, v]) => [k, v.default]);
        if (paramsWithDefault.length > 0) {
            for (const [paramKey, paramDefaultValue] of paramsWithDefault) {
                endpointParams[paramKey] = endpointParams[paramKey] ?? paramDefaultValue;
            }
        }
        const requiredParams = Object.entries(parameters)
            .filter(([, v]) => v.required)
            .map(([k]) => k);
        for (const requiredParam of requiredParams) {
            if (endpointParams[requiredParam] == null) {
                throw new EndpointError(`Missing required parameter: '${requiredParam}'`);
            }
        }
        const endpoint = evaluateRules(rules, { endpointParams, logger, referenceRecord: {} });
        if (options.endpointParams?.Endpoint) {
            try {
                const givenEndpoint = new URL(options.endpointParams.Endpoint);
                const { protocol, port } = givenEndpoint;
                endpoint.url.protocol = protocol;
                endpoint.url.port = port;
            }
            catch (e) {
            }
        }
        options.logger?.debug?.(`${debugId} Resolved endpoint: ${toDebugString(endpoint)}`);
        return endpoint;
    };

    const isVirtualHostableS3Bucket = (value, allowSubDomains = false) => {
        if (allowSubDomains) {
            for (const label of value.split(".")) {
                if (!isVirtualHostableS3Bucket(label)) {
                    return false;
                }
            }
            return true;
        }
        if (!isValidHostLabel(value)) {
            return false;
        }
        if (value.length < 3 || value.length > 63) {
            return false;
        }
        if (value !== value.toLowerCase()) {
            return false;
        }
        if (isIpAddress(value)) {
            return false;
        }
        return true;
    };

    const parseArn = (value) => {
        const segments = value.split(":");
        if (segments.length < 6)
            return null;
        const [arn, partition, service, region, accountId, ...resourceId] = segments;
        if (arn !== "arn" || partition === "" || service === "" || resourceId[0] === "")
            return null;
        return {
            partition,
            service,
            region,
            accountId,
            resourceId: resourceId[0].includes("/") ? resourceId[0].split("/") : resourceId,
        };
    };

    var partitions = [
    	{
    		id: "aws",
    		outputs: {
    			dnsSuffix: "amazonaws.com",
    			dualStackDnsSuffix: "api.aws",
    			implicitGlobalRegion: "us-east-1",
    			name: "aws",
    			supportsDualStack: true,
    			supportsFIPS: true
    		},
    		regionRegex: "^(us|eu|ap|sa|ca|me|af|il)\\-\\w+\\-\\d+$",
    		regions: {
    			"af-south-1": {
    				description: "Africa (Cape Town)"
    			},
    			"ap-east-1": {
    				description: "Asia Pacific (Hong Kong)"
    			},
    			"ap-northeast-1": {
    				description: "Asia Pacific (Tokyo)"
    			},
    			"ap-northeast-2": {
    				description: "Asia Pacific (Seoul)"
    			},
    			"ap-northeast-3": {
    				description: "Asia Pacific (Osaka)"
    			},
    			"ap-south-1": {
    				description: "Asia Pacific (Mumbai)"
    			},
    			"ap-south-2": {
    				description: "Asia Pacific (Hyderabad)"
    			},
    			"ap-southeast-1": {
    				description: "Asia Pacific (Singapore)"
    			},
    			"ap-southeast-2": {
    				description: "Asia Pacific (Sydney)"
    			},
    			"ap-southeast-3": {
    				description: "Asia Pacific (Jakarta)"
    			},
    			"ap-southeast-4": {
    				description: "Asia Pacific (Melbourne)"
    			},
    			"aws-global": {
    				description: "AWS Standard global region"
    			},
    			"ca-central-1": {
    				description: "Canada (Central)"
    			},
    			"ca-west-1": {
    				description: "Canada West (Calgary)"
    			},
    			"eu-central-1": {
    				description: "Europe (Frankfurt)"
    			},
    			"eu-central-2": {
    				description: "Europe (Zurich)"
    			},
    			"eu-north-1": {
    				description: "Europe (Stockholm)"
    			},
    			"eu-south-1": {
    				description: "Europe (Milan)"
    			},
    			"eu-south-2": {
    				description: "Europe (Spain)"
    			},
    			"eu-west-1": {
    				description: "Europe (Ireland)"
    			},
    			"eu-west-2": {
    				description: "Europe (London)"
    			},
    			"eu-west-3": {
    				description: "Europe (Paris)"
    			},
    			"il-central-1": {
    				description: "Israel (Tel Aviv)"
    			},
    			"me-central-1": {
    				description: "Middle East (UAE)"
    			},
    			"me-south-1": {
    				description: "Middle East (Bahrain)"
    			},
    			"sa-east-1": {
    				description: "South America (Sao Paulo)"
    			},
    			"us-east-1": {
    				description: "US East (N. Virginia)"
    			},
    			"us-east-2": {
    				description: "US East (Ohio)"
    			},
    			"us-west-1": {
    				description: "US West (N. California)"
    			},
    			"us-west-2": {
    				description: "US West (Oregon)"
    			}
    		}
    	},
    	{
    		id: "aws-cn",
    		outputs: {
    			dnsSuffix: "amazonaws.com.cn",
    			dualStackDnsSuffix: "api.amazonwebservices.com.cn",
    			implicitGlobalRegion: "cn-northwest-1",
    			name: "aws-cn",
    			supportsDualStack: true,
    			supportsFIPS: true
    		},
    		regionRegex: "^cn\\-\\w+\\-\\d+$",
    		regions: {
    			"aws-cn-global": {
    				description: "AWS China global region"
    			},
    			"cn-north-1": {
    				description: "China (Beijing)"
    			},
    			"cn-northwest-1": {
    				description: "China (Ningxia)"
    			}
    		}
    	},
    	{
    		id: "aws-us-gov",
    		outputs: {
    			dnsSuffix: "amazonaws.com",
    			dualStackDnsSuffix: "api.aws",
    			implicitGlobalRegion: "us-gov-west-1",
    			name: "aws-us-gov",
    			supportsDualStack: true,
    			supportsFIPS: true
    		},
    		regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
    		regions: {
    			"aws-us-gov-global": {
    				description: "AWS GovCloud (US) global region"
    			},
    			"us-gov-east-1": {
    				description: "AWS GovCloud (US-East)"
    			},
    			"us-gov-west-1": {
    				description: "AWS GovCloud (US-West)"
    			}
    		}
    	},
    	{
    		id: "aws-iso",
    		outputs: {
    			dnsSuffix: "c2s.ic.gov",
    			dualStackDnsSuffix: "c2s.ic.gov",
    			implicitGlobalRegion: "us-iso-east-1",
    			name: "aws-iso",
    			supportsDualStack: false,
    			supportsFIPS: true
    		},
    		regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
    		regions: {
    			"aws-iso-global": {
    				description: "AWS ISO (US) global region"
    			},
    			"us-iso-east-1": {
    				description: "US ISO East"
    			},
    			"us-iso-west-1": {
    				description: "US ISO WEST"
    			}
    		}
    	},
    	{
    		id: "aws-iso-b",
    		outputs: {
    			dnsSuffix: "sc2s.sgov.gov",
    			dualStackDnsSuffix: "sc2s.sgov.gov",
    			implicitGlobalRegion: "us-isob-east-1",
    			name: "aws-iso-b",
    			supportsDualStack: false,
    			supportsFIPS: true
    		},
    		regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
    		regions: {
    			"aws-iso-b-global": {
    				description: "AWS ISOB (US) global region"
    			},
    			"us-isob-east-1": {
    				description: "US ISOB East (Ohio)"
    			}
    		}
    	},
    	{
    		id: "aws-iso-e",
    		outputs: {
    			dnsSuffix: "cloud.adc-e.uk",
    			dualStackDnsSuffix: "cloud.adc-e.uk",
    			implicitGlobalRegion: "eu-isoe-west-1",
    			name: "aws-iso-e",
    			supportsDualStack: false,
    			supportsFIPS: true
    		},
    		regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
    		regions: {
    			"eu-isoe-west-1": {
    				description: "EU ISOE West"
    			}
    		}
    	},
    	{
    		id: "aws-iso-f",
    		outputs: {
    			dnsSuffix: "csp.hci.ic.gov",
    			dualStackDnsSuffix: "csp.hci.ic.gov",
    			implicitGlobalRegion: "us-isof-south-1",
    			name: "aws-iso-f",
    			supportsDualStack: false,
    			supportsFIPS: true
    		},
    		regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
    		regions: {
    		}
    	}
    ];
    var version$6 = "1.1";
    var partitionsInfo = {
    	partitions: partitions,
    	version: version$6
    };

    let selectedPartitionsInfo = partitionsInfo;
    const partition = (value) => {
        const { partitions } = selectedPartitionsInfo;
        for (const partition of partitions) {
            const { regions, outputs } = partition;
            for (const [region, regionData] of Object.entries(regions)) {
                if (region === value) {
                    return {
                        ...outputs,
                        ...regionData,
                    };
                }
            }
        }
        for (const partition of partitions) {
            const { regionRegex, outputs } = partition;
            if (new RegExp(regionRegex).test(value)) {
                return {
                    ...outputs,
                };
            }
        }
        const DEFAULT_PARTITION = partitions.find((partition) => partition.id === "aws");
        if (!DEFAULT_PARTITION) {
            throw new Error("Provided region was not found in the partition array or regex," +
                " and default partition with id 'aws' doesn't exist.");
        }
        return {
            ...DEFAULT_PARTITION.outputs,
        };
    };

    const awsEndpointFunctions = {
        isVirtualHostableS3Bucket: isVirtualHostableS3Bucket,
        parseArn: parseArn,
        partition: partition,
    };
    customEndpointFunctions.aws = awsEndpointFunctions;

    const USER_AGENT$3 = "user-agent";
    const X_AMZ_USER_AGENT$3 = "x-amz-user-agent";
    const SPACE$3 = " ";
    const UA_NAME_SEPARATOR$3 = "/";
    const UA_NAME_ESCAPE_REGEX$3 = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g;
    const UA_VALUE_ESCAPE_REGEX$3 = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g;
    const UA_ESCAPE_CHAR$3 = "-";

    const userAgentMiddleware$3 = (options) => (next, context) => async (args) => {
        const { request } = args;
        if (!HttpRequest$4.isInstance(request))
            return next(args);
        const { headers } = request;
        const userAgent = context?.userAgent?.map(escapeUserAgent$3) || [];
        const defaultUserAgent = (await options.defaultUserAgentProvider()).map(escapeUserAgent$3);
        const customUserAgent = options?.customUserAgent?.map(escapeUserAgent$3) || [];
        const sdkUserAgentValue = ([])
            .concat([...defaultUserAgent, ...userAgent, ...customUserAgent])
            .join(SPACE$3);
        const normalUAValue = [
            ...defaultUserAgent.filter((section) => section.startsWith("aws-sdk-")),
            ...customUserAgent,
        ].join(SPACE$3);
        if (options.runtime !== "browser") {
            if (normalUAValue) {
                headers[X_AMZ_USER_AGENT$3] = headers[X_AMZ_USER_AGENT$3]
                    ? `${headers[USER_AGENT$3]} ${normalUAValue}`
                    : normalUAValue;
            }
            headers[USER_AGENT$3] = sdkUserAgentValue;
        }
        else {
            headers[X_AMZ_USER_AGENT$3] = sdkUserAgentValue;
        }
        return next({
            ...args,
            request,
        });
    };
    const escapeUserAgent$3 = (userAgentPair) => {
        const name = userAgentPair[0]
            .split(UA_NAME_SEPARATOR$3)
            .map((part) => part.replace(UA_NAME_ESCAPE_REGEX$3, UA_ESCAPE_CHAR$3))
            .join(UA_NAME_SEPARATOR$3);
        const version = userAgentPair[1]?.replace(UA_VALUE_ESCAPE_REGEX$3, UA_ESCAPE_CHAR$3);
        const prefixSeparatorIndex = name.indexOf(UA_NAME_SEPARATOR$3);
        const prefix = name.substring(0, prefixSeparatorIndex);
        let uaName = name.substring(prefixSeparatorIndex + 1);
        if (prefix === "api") {
            uaName = uaName.toLowerCase();
        }
        return [prefix, uaName, version]
            .filter((item) => item && item.length > 0)
            .reduce((acc, item, index) => {
            switch (index) {
                case 0:
                    return item;
                case 1:
                    return `${acc}/${item}`;
                default:
                    return `${acc}#${item}`;
            }
        }, "");
    };
    const getUserAgentMiddlewareOptions$3 = {
        name: "getUserAgentMiddleware",
        step: "build",
        priority: "low",
        tags: ["SET_USER_AGENT", "USER_AGENT"],
        override: true,
    };
    const getUserAgentPlugin$3 = (config) => ({
        applyToStack: (clientStack) => {
            clientStack.add(userAgentMiddleware$3(config), getUserAgentMiddlewareOptions$3);
        },
    });

    var SelectorType$3;
    (function (SelectorType) {
        SelectorType["ENV"] = "env";
        SelectorType["CONFIG"] = "shared config entry";
    })(SelectorType$3 || (SelectorType$3 = {}));

    const DEFAULT_USE_DUALSTACK_ENDPOINT$3 = false;

    const DEFAULT_USE_FIPS_ENDPOINT$3 = false;

    const getSmithyContext = (context) => context[SMITHY_CONTEXT_KEY$3] || (context[SMITHY_CONTEXT_KEY$3] = {});

    const normalizeProvider$5 = (input) => {
        if (typeof input === "function")
            return input;
        const promisified = Promise.resolve(input);
        return () => promisified;
    };

    const isFipsRegion$3 = (region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));

    const getRealRegion$3 = (region) => isFipsRegion$3(region)
        ? ["fips-aws-global", "aws-fips"].includes(region)
            ? "us-east-1"
            : region.replace(/fips-(dkr-|prod-)?|-fips/, "")
        : region;

    const resolveRegionConfig$3 = (input) => {
        const { region, useFipsEndpoint } = input;
        if (!region) {
            throw new Error("Region is missing");
        }
        return {
            ...input,
            region: async () => {
                if (typeof region === "string") {
                    return getRealRegion$3(region);
                }
                const providedRegion = await region();
                return getRealRegion$3(providedRegion);
            },
            useFipsEndpoint: async () => {
                const providedRegion = typeof region === "string" ? region : await region();
                if (isFipsRegion$3(providedRegion)) {
                    return true;
                }
                return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
            },
        };
    };

    function convertHttpAuthSchemesToMap(httpAuthSchemes) {
        const map = new Map();
        for (const scheme of httpAuthSchemes) {
            map.set(scheme.schemeId, scheme);
        }
        return map;
    }
    const httpAuthSchemeMiddleware = (config, mwOptions) => (next, context) => async (args) => {
        const options = config.httpAuthSchemeProvider(await mwOptions.httpAuthSchemeParametersProvider(config, context, args.input));
        const authSchemes = convertHttpAuthSchemesToMap(config.httpAuthSchemes);
        const smithyContext = getSmithyContext(context);
        const failureReasons = [];
        for (const option of options) {
            const scheme = authSchemes.get(option.schemeId);
            if (!scheme) {
                failureReasons.push(`HttpAuthScheme \`${option.schemeId}\` was not enabled for this service.`);
                continue;
            }
            const identityProvider = scheme.identityProvider(await mwOptions.identityProviderConfigProvider(config));
            if (!identityProvider) {
                failureReasons.push(`HttpAuthScheme \`${option.schemeId}\` did not have an IdentityProvider configured.`);
                continue;
            }
            const { identityProperties = {}, signingProperties = {} } = option.propertiesExtractor?.(config, context) || {};
            option.identityProperties = Object.assign(option.identityProperties || {}, identityProperties);
            option.signingProperties = Object.assign(option.signingProperties || {}, signingProperties);
            smithyContext.selectedHttpAuthScheme = {
                httpAuthOption: option,
                identity: await identityProvider(option.identityProperties),
                signer: scheme.signer,
            };
            break;
        }
        if (!smithyContext.selectedHttpAuthScheme) {
            throw new Error(failureReasons.join("\n"));
        }
        return next(args);
    };

    const resolveParamsForS3 = async (endpointParams) => {
        const bucket = endpointParams?.Bucket || "";
        if (typeof endpointParams.Bucket === "string") {
            endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
        }
        if (isArnBucketName(bucket)) {
            if (endpointParams.ForcePathStyle === true) {
                throw new Error("Path-style addressing cannot be used with ARN buckets");
            }
        }
        else if (!isDnsCompatibleBucketName(bucket) ||
            (bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:")) ||
            bucket.toLowerCase() !== bucket ||
            bucket.length < 3) {
            endpointParams.ForcePathStyle = true;
        }
        if (endpointParams.DisableMultiRegionAccessPoints) {
            endpointParams.disableMultiRegionAccessPoints = true;
            endpointParams.DisableMRAP = true;
        }
        return endpointParams;
    };
    const DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
    const IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
    const DOTS_PATTERN = /\.\./;
    const isDnsCompatibleBucketName = (bucketName) => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);
    const isArnBucketName = (bucketName) => {
        const [arn, partition, service, , , bucket] = bucketName.split(":");
        const isArn = arn === "arn" && bucketName.split(":").length >= 6;
        const isValidArn = Boolean(isArn && partition && service && bucket);
        if (isArn && !isValidArn) {
            throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
        }
        return isValidArn;
    };

    const createConfigValueProvider = (configKey, canonicalEndpointParamKey, config) => {
        const configProvider = async () => {
            const configValue = config[configKey] ?? config[canonicalEndpointParamKey];
            if (typeof configValue === "function") {
                return configValue();
            }
            return configValue;
        };
        if (configKey === "credentialScope" || canonicalEndpointParamKey === "CredentialScope") {
            return async () => {
                const credentials = typeof config.credentials === "function" ? await config.credentials() : config.credentials;
                const configValue = credentials?.credentialScope ?? credentials?.CredentialScope;
                return configValue;
            };
        }
        if (configKey === "accountId" || canonicalEndpointParamKey === "AccountId") {
            return async () => {
                const credentials = typeof config.credentials === "function" ? await config.credentials() : config.credentials;
                const configValue = credentials?.accountId ?? credentials?.AccountId;
                return configValue;
            };
        }
        if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") {
            return async () => {
                const endpoint = await configProvider();
                if (endpoint && typeof endpoint === "object") {
                    if ("url" in endpoint) {
                        return endpoint.url.href;
                    }
                    if ("hostname" in endpoint) {
                        const { protocol, hostname, port, path } = endpoint;
                        return `${protocol}//${hostname}${port ? ":" + port : ""}${path}`;
                    }
                }
                return endpoint;
            };
        }
        return configProvider;
    };

    const getEndpointFromConfig = async (serviceId) => undefined;

    function parseQueryString$3(querystring) {
        const query = {};
        querystring = querystring.replace(/^\?/, "");
        if (querystring) {
            for (const pair of querystring.split("&")) {
                let [key, value = null] = pair.split("=");
                key = decodeURIComponent(key);
                if (value) {
                    value = decodeURIComponent(value);
                }
                if (!(key in query)) {
                    query[key] = value;
                }
                else if (Array.isArray(query[key])) {
                    query[key].push(value);
                }
                else {
                    query[key] = [query[key], value];
                }
            }
        }
        return query;
    }

    const parseUrl$3 = (url) => {
        if (typeof url === "string") {
            return parseUrl$3(new URL(url));
        }
        const { hostname, pathname, port, protocol, search } = url;
        let query;
        if (search) {
            query = parseQueryString$3(search);
        }
        return {
            hostname,
            port: port ? parseInt(port) : undefined,
            protocol,
            path: pathname,
            query,
        };
    };

    const toEndpointV1 = (endpoint) => {
        if (typeof endpoint === "object") {
            if ("url" in endpoint) {
                return parseUrl$3(endpoint.url);
            }
            return endpoint;
        }
        return parseUrl$3(endpoint);
    };

    const getEndpointFromInstructions = async (commandInput, instructionsSupplier, clientConfig, context) => {
        if (!clientConfig.endpoint) {
            const endpointFromConfig = await getEndpointFromConfig(clientConfig.serviceId || "");
            if (endpointFromConfig) {
                clientConfig.endpoint = () => Promise.resolve(toEndpointV1(endpointFromConfig));
            }
        }
        const endpointParams = await resolveParams(commandInput, instructionsSupplier, clientConfig);
        if (typeof clientConfig.endpointProvider !== "function") {
            throw new Error("config.endpointProvider is not set.");
        }
        const endpoint = clientConfig.endpointProvider(endpointParams, context);
        return endpoint;
    };
    const resolveParams = async (commandInput, instructionsSupplier, clientConfig) => {
        const endpointParams = {};
        const instructions = instructionsSupplier?.getEndpointParameterInstructions?.() || {};
        for (const [name, instruction] of Object.entries(instructions)) {
            switch (instruction.type) {
                case "staticContextParams":
                    endpointParams[name] = instruction.value;
                    break;
                case "contextParams":
                    endpointParams[name] = commandInput[instruction.name];
                    break;
                case "clientContextParams":
                case "builtInParams":
                    endpointParams[name] = await createConfigValueProvider(instruction.name, name, clientConfig)();
                    break;
                default:
                    throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
            }
        }
        if (Object.keys(instructions).length === 0) {
            Object.assign(endpointParams, clientConfig);
        }
        if (String(clientConfig.serviceId).toLowerCase() === "s3") {
            await resolveParamsForS3(endpointParams);
        }
        return endpointParams;
    };

    const endpointMiddleware = ({ config, instructions, }) => {
        return (next, context) => async (args) => {
            const endpoint = await getEndpointFromInstructions(args.input, {
                getEndpointParameterInstructions() {
                    return instructions;
                },
            }, { ...config }, context);
            context.endpointV2 = endpoint;
            context.authSchemes = endpoint.properties?.authSchemes;
            const authScheme = context.authSchemes?.[0];
            if (authScheme) {
                context["signing_region"] = authScheme.signingRegion;
                context["signing_service"] = authScheme.signingName;
                const smithyContext = getSmithyContext(context);
                const httpAuthOption = smithyContext?.selectedHttpAuthScheme?.httpAuthOption;
                if (httpAuthOption) {
                    httpAuthOption.signingProperties = Object.assign(httpAuthOption.signingProperties || {}, {
                        signing_region: authScheme.signingRegion,
                        signingRegion: authScheme.signingRegion,
                        signing_service: authScheme.signingName,
                        signingName: authScheme.signingName,
                        signingRegionSet: authScheme.signingRegionSet,
                    }, authScheme.properties);
                }
            }
            return next({
                ...args,
            });
        };
    };

    const deserializerMiddleware$3 = (options, deserializer) => (next) => async (args) => {
        const { response } = await next(args);
        try {
            const parsed = await deserializer(response, options);
            return {
                response,
                output: parsed,
            };
        }
        catch (error) {
            Object.defineProperty(error, "$response", {
                value: response,
            });
            if (!("$metadata" in error)) {
                const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
                error.message += "\n  " + hint;
                if (typeof error.$responseBodyText !== "undefined") {
                    if (error.$response) {
                        error.$response.body = error.$responseBodyText;
                    }
                }
            }
            throw error;
        }
    };

    const serializerMiddleware$3 = (options, serializer) => (next, context) => async (args) => {
        const endpoint = context.endpointV2?.url && options.urlParser
            ? async () => options.urlParser(context.endpointV2.url)
            : options.endpoint;
        if (!endpoint) {
            throw new Error("No valid endpoint provider available.");
        }
        const request = await serializer(args.input, { ...options, endpoint });
        return next({
            ...args,
            request,
        });
    };

    const deserializerMiddlewareOption$3 = {
        name: "deserializerMiddleware",
        step: "deserialize",
        tags: ["DESERIALIZER"],
        override: true,
    };
    const serializerMiddlewareOption$3 = {
        name: "serializerMiddleware",
        step: "serialize",
        tags: ["SERIALIZER"],
        override: true,
    };
    function getSerdePlugin$3(config, serializer, deserializer) {
        return {
            applyToStack: (commandStack) => {
                commandStack.add(deserializerMiddleware$3(config, deserializer), deserializerMiddlewareOption$3);
                commandStack.add(serializerMiddleware$3(config, serializer), serializerMiddlewareOption$3);
            },
        };
    }

    const endpointMiddlewareOptions = {
        step: "serialize",
        tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
        name: "endpointV2Middleware",
        override: true,
        relation: "before",
        toMiddleware: serializerMiddlewareOption$3.name,
    };
    const getEndpointPlugin = (config, instructions) => ({
        applyToStack: (clientStack) => {
            clientStack.addRelativeTo(endpointMiddleware({
                config,
                instructions,
            }), endpointMiddlewareOptions);
        },
    });

    const resolveEndpointConfig = (input) => {
        const tls = input.tls ?? true;
        const { endpoint } = input;
        const customEndpointProvider = endpoint != null ? async () => toEndpointV1(await normalizeProvider$5(endpoint)()) : undefined;
        const isCustomEndpoint = !!endpoint;
        return {
            ...input,
            endpoint: customEndpointProvider,
            tls,
            isCustomEndpoint,
            useDualstackEndpoint: normalizeProvider$5(input.useDualstackEndpoint ?? false),
            useFipsEndpoint: normalizeProvider$5(input.useFipsEndpoint ?? false),
        };
    };

    const httpAuthSchemeEndpointRuleSetMiddlewareOptions = {
        step: "serialize",
        tags: ["HTTP_AUTH_SCHEME"],
        name: "httpAuthSchemeMiddleware",
        override: true,
        relation: "before",
        toMiddleware: endpointMiddlewareOptions.name,
    };
    const getHttpAuthSchemeEndpointRuleSetPlugin = (config, { httpAuthSchemeParametersProvider, identityProviderConfigProvider, }) => ({
        applyToStack: (clientStack) => {
            clientStack.addRelativeTo(httpAuthSchemeMiddleware(config, {
                httpAuthSchemeParametersProvider,
                identityProviderConfigProvider,
            }), httpAuthSchemeEndpointRuleSetMiddlewareOptions);
        },
    });

    ({
        step: "serialize",
        tags: ["HTTP_AUTH_SCHEME"],
        name: "httpAuthSchemeMiddleware",
        override: true,
        relation: "before",
        toMiddleware: serializerMiddlewareOption$3.name,
    });

    const defaultErrorHandler = (signingProperties) => (error) => {
        throw error;
    };
    const defaultSuccessHandler = (httpResponse, signingProperties) => { };
    const httpSigningMiddleware = (config) => (next, context) => async (args) => {
        if (!HttpRequest$4.isInstance(args.request)) {
            return next(args);
        }
        const smithyContext = getSmithyContext(context);
        const scheme = smithyContext.selectedHttpAuthScheme;
        if (!scheme) {
            throw new Error(`No HttpAuthScheme was selected: unable to sign request`);
        }
        const { httpAuthOption: { signingProperties = {} }, identity, signer, } = scheme;
        const output = await next({
            ...args,
            request: await signer.sign(args.request, identity, signingProperties),
        }).catch((signer.errorHandler || defaultErrorHandler)(signingProperties));
        (signer.successHandler || defaultSuccessHandler)(output.response, signingProperties);
        return output;
    };

    var RETRY_MODES$3;
    (function (RETRY_MODES) {
        RETRY_MODES["STANDARD"] = "standard";
        RETRY_MODES["ADAPTIVE"] = "adaptive";
    })(RETRY_MODES$3 || (RETRY_MODES$3 = {}));
    const DEFAULT_MAX_ATTEMPTS$3 = 3;
    const DEFAULT_RETRY_MODE$3 = RETRY_MODES$3.STANDARD;

    const THROTTLING_ERROR_CODES$3 = [
        "BandwidthLimitExceeded",
        "EC2ThrottledException",
        "LimitExceededException",
        "PriorRequestNotComplete",
        "ProvisionedThroughputExceededException",
        "RequestLimitExceeded",
        "RequestThrottled",
        "RequestThrottledException",
        "SlowDown",
        "ThrottledException",
        "Throttling",
        "ThrottlingException",
        "TooManyRequestsException",
        "TransactionInProgressException",
    ];
    const TRANSIENT_ERROR_CODES$3 = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"];
    const TRANSIENT_ERROR_STATUS_CODES$3 = [500, 502, 503, 504];
    const NODEJS_TIMEOUT_ERROR_CODES$3 = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"];

    const isClockSkewCorrectedError$3 = (error) => error.$metadata?.clockSkewCorrected;
    const isThrottlingError$3 = (error) => error.$metadata?.httpStatusCode === 429 ||
        THROTTLING_ERROR_CODES$3.includes(error.name) ||
        error.$retryable?.throttling == true;
    const isTransientError$3 = (error) => isClockSkewCorrectedError$3(error) ||
        TRANSIENT_ERROR_CODES$3.includes(error.name) ||
        NODEJS_TIMEOUT_ERROR_CODES$3.includes(error?.code || "") ||
        TRANSIENT_ERROR_STATUS_CODES$3.includes(error.$metadata?.httpStatusCode || 0);
    const isServerError$3 = (error) => {
        if (error.$metadata?.httpStatusCode !== undefined) {
            const statusCode = error.$metadata.httpStatusCode;
            if (500 <= statusCode && statusCode <= 599 && !isTransientError$3(error)) {
                return true;
            }
            return false;
        }
        return false;
    };

    let DefaultRateLimiter$3 = class DefaultRateLimiter {
        constructor(options) {
            this.currentCapacity = 0;
            this.enabled = false;
            this.lastMaxRate = 0;
            this.measuredTxRate = 0;
            this.requestCount = 0;
            this.lastTimestamp = 0;
            this.timeWindow = 0;
            this.beta = options?.beta ?? 0.7;
            this.minCapacity = options?.minCapacity ?? 1;
            this.minFillRate = options?.minFillRate ?? 0.5;
            this.scaleConstant = options?.scaleConstant ?? 0.4;
            this.smooth = options?.smooth ?? 0.8;
            const currentTimeInSeconds = this.getCurrentTimeInSeconds();
            this.lastThrottleTime = currentTimeInSeconds;
            this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());
            this.fillRate = this.minFillRate;
            this.maxCapacity = this.minCapacity;
        }
        getCurrentTimeInSeconds() {
            return Date.now() / 1000;
        }
        async getSendToken() {
            return this.acquireTokenBucket(1);
        }
        async acquireTokenBucket(amount) {
            if (!this.enabled) {
                return;
            }
            this.refillTokenBucket();
            if (amount > this.currentCapacity) {
                const delay = ((amount - this.currentCapacity) / this.fillRate) * 1000;
                await new Promise((resolve) => setTimeout(resolve, delay));
            }
            this.currentCapacity = this.currentCapacity - amount;
        }
        refillTokenBucket() {
            const timestamp = this.getCurrentTimeInSeconds();
            if (!this.lastTimestamp) {
                this.lastTimestamp = timestamp;
                return;
            }
            const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;
            this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);
            this.lastTimestamp = timestamp;
        }
        updateClientSendingRate(response) {
            let calculatedRate;
            this.updateMeasuredRate();
            if (isThrottlingError$3(response)) {
                const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);
                this.lastMaxRate = rateToUse;
                this.calculateTimeWindow();
                this.lastThrottleTime = this.getCurrentTimeInSeconds();
                calculatedRate = this.cubicThrottle(rateToUse);
                this.enableTokenBucket();
            }
            else {
                this.calculateTimeWindow();
                calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());
            }
            const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);
            this.updateTokenBucketRate(newRate);
        }
        calculateTimeWindow() {
            this.timeWindow = this.getPrecise(Math.pow((this.lastMaxRate * (1 - this.beta)) / this.scaleConstant, 1 / 3));
        }
        cubicThrottle(rateToUse) {
            return this.getPrecise(rateToUse * this.beta);
        }
        cubicSuccess(timestamp) {
            return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
        }
        enableTokenBucket() {
            this.enabled = true;
        }
        updateTokenBucketRate(newRate) {
            this.refillTokenBucket();
            this.fillRate = Math.max(newRate, this.minFillRate);
            this.maxCapacity = Math.max(newRate, this.minCapacity);
            this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
        }
        updateMeasuredRate() {
            const t = this.getCurrentTimeInSeconds();
            const timeBucket = Math.floor(t * 2) / 2;
            this.requestCount++;
            if (timeBucket > this.lastTxRateBucket) {
                const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);
                this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));
                this.requestCount = 0;
                this.lastTxRateBucket = timeBucket;
            }
        }
        getPrecise(num) {
            return parseFloat(num.toFixed(8));
        }
    };

    const DEFAULT_RETRY_DELAY_BASE$3 = 100;
    const MAXIMUM_RETRY_DELAY$3 = 20 * 1000;
    const THROTTLING_RETRY_DELAY_BASE$3 = 500;
    const INITIAL_RETRY_TOKENS$3 = 500;
    const RETRY_COST$3 = 5;
    const TIMEOUT_RETRY_COST$3 = 10;
    const NO_RETRY_INCREMENT$3 = 1;
    const INVOCATION_ID_HEADER$3 = "amz-sdk-invocation-id";
    const REQUEST_HEADER$3 = "amz-sdk-request";

    const getDefaultRetryBackoffStrategy$3 = () => {
        let delayBase = DEFAULT_RETRY_DELAY_BASE$3;
        const computeNextBackoffDelay = (attempts) => {
            return Math.floor(Math.min(MAXIMUM_RETRY_DELAY$3, Math.random() * 2 ** attempts * delayBase));
        };
        const setDelayBase = (delay) => {
            delayBase = delay;
        };
        return {
            computeNextBackoffDelay,
            setDelayBase,
        };
    };

    const createDefaultRetryToken$3 = ({ retryDelay, retryCount, retryCost, }) => {
        const getRetryCount = () => retryCount;
        const getRetryDelay = () => Math.min(MAXIMUM_RETRY_DELAY$3, retryDelay);
        const getRetryCost = () => retryCost;
        return {
            getRetryCount,
            getRetryDelay,
            getRetryCost,
        };
    };

    let StandardRetryStrategy$3 = class StandardRetryStrategy {
        constructor(maxAttempts) {
            this.maxAttempts = maxAttempts;
            this.mode = RETRY_MODES$3.STANDARD;
            this.capacity = INITIAL_RETRY_TOKENS$3;
            this.retryBackoffStrategy = getDefaultRetryBackoffStrategy$3();
            this.maxAttemptsProvider = typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts;
        }
        async acquireInitialRetryToken(retryTokenScope) {
            return createDefaultRetryToken$3({
                retryDelay: DEFAULT_RETRY_DELAY_BASE$3,
                retryCount: 0,
            });
        }
        async refreshRetryTokenForRetry(token, errorInfo) {
            const maxAttempts = await this.getMaxAttempts();
            if (this.shouldRetry(token, errorInfo, maxAttempts)) {
                const errorType = errorInfo.errorType;
                this.retryBackoffStrategy.setDelayBase(errorType === "THROTTLING" ? THROTTLING_RETRY_DELAY_BASE$3 : DEFAULT_RETRY_DELAY_BASE$3);
                const delayFromErrorType = this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());
                const retryDelay = errorInfo.retryAfterHint
                    ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType)
                    : delayFromErrorType;
                const capacityCost = this.getCapacityCost(errorType);
                this.capacity -= capacityCost;
                return createDefaultRetryToken$3({
                    retryDelay,
                    retryCount: token.getRetryCount() + 1,
                    retryCost: capacityCost,
                });
            }
            throw new Error("No retry token available");
        }
        recordSuccess(token) {
            this.capacity = Math.max(INITIAL_RETRY_TOKENS$3, this.capacity + (token.getRetryCost() ?? NO_RETRY_INCREMENT$3));
        }
        getCapacity() {
            return this.capacity;
        }
        async getMaxAttempts() {
            try {
                return await this.maxAttemptsProvider();
            }
            catch (error) {
                console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS$3}`);
                return DEFAULT_MAX_ATTEMPTS$3;
            }
        }
        shouldRetry(tokenToRenew, errorInfo, maxAttempts) {
            const attempts = tokenToRenew.getRetryCount() + 1;
            return (attempts < maxAttempts &&
                this.capacity >= this.getCapacityCost(errorInfo.errorType) &&
                this.isRetryableError(errorInfo.errorType));
        }
        getCapacityCost(errorType) {
            return errorType === "TRANSIENT" ? TIMEOUT_RETRY_COST$3 : RETRY_COST$3;
        }
        isRetryableError(errorType) {
            return errorType === "THROTTLING" || errorType === "TRANSIENT";
        }
    };

    let AdaptiveRetryStrategy$3 = class AdaptiveRetryStrategy {
        constructor(maxAttemptsProvider, options) {
            this.maxAttemptsProvider = maxAttemptsProvider;
            this.mode = RETRY_MODES$3.ADAPTIVE;
            const { rateLimiter } = options ?? {};
            this.rateLimiter = rateLimiter ?? new DefaultRateLimiter$3();
            this.standardRetryStrategy = new StandardRetryStrategy$3(maxAttemptsProvider);
        }
        async acquireInitialRetryToken(retryTokenScope) {
            await this.rateLimiter.getSendToken();
            return this.standardRetryStrategy.acquireInitialRetryToken(retryTokenScope);
        }
        async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
            this.rateLimiter.updateClientSendingRate(errorInfo);
            return this.standardRetryStrategy.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
        }
        recordSuccess(token) {
            this.rateLimiter.updateClientSendingRate({});
            this.standardRetryStrategy.recordSuccess(token);
        }
    };

    // Unique ID creation requires a high quality random # generator. In the browser we therefore
    // require the crypto API and do not support built-in fallback to lower quality random number
    // generators (like Math.random()).
    let getRandomValues;
    const rnds8 = new Uint8Array(16);
    function rng() {
      // lazy load so that environments that need to polyfill have a chance to do so
      if (!getRandomValues) {
        // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
        getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);

        if (!getRandomValues) {
          throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
        }
      }

      return getRandomValues(rnds8);
    }

    /**
     * Convert array of 16 byte values to UUID string format of the form:
     * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
     */

    const byteToHex = [];

    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 0x100).toString(16).slice(1));
    }

    function unsafeStringify(arr, offset = 0) {
      // Note: Be careful editing this code!  It's been tuned for performance
      // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
      return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
    }

    const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
    var native = {
      randomUUID
    };

    function v4(options, buf, offset) {
      if (native.randomUUID && !buf && !options) {
        return native.randomUUID();
      }

      options = options || {};
      const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

      rnds[6] = rnds[6] & 0x0f | 0x40;
      rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

      return unsafeStringify(rnds);
    }

    const asSdkError$3 = (error) => {
        if (error instanceof Error)
            return error;
        if (error instanceof Object)
            return Object.assign(new Error(), error);
        if (typeof error === "string")
            return new Error(error);
        return new Error(`AWS SDK error wrapper for ${error}`);
    };

    const resolveRetryConfig$3 = (input) => {
        const { retryStrategy } = input;
        const maxAttempts = normalizeProvider$5(input.maxAttempts ?? DEFAULT_MAX_ATTEMPTS$3);
        return {
            ...input,
            maxAttempts,
            retryStrategy: async () => {
                if (retryStrategy) {
                    return retryStrategy;
                }
                const retryMode = await normalizeProvider$5(input.retryMode)();
                if (retryMode === RETRY_MODES$3.ADAPTIVE) {
                    return new AdaptiveRetryStrategy$3(maxAttempts);
                }
                return new StandardRetryStrategy$3(maxAttempts);
            },
        };
    };

    let NoOpLogger$3 = class NoOpLogger {
        trace() { }
        debug() { }
        info() { }
        warn() { }
        error() { }
    };

    const getAllAliases$3 = (name, aliases) => {
        const _aliases = [];
        if (name) {
            _aliases.push(name);
        }
        if (aliases) {
            for (const alias of aliases) {
                _aliases.push(alias);
            }
        }
        return _aliases;
    };
    const getMiddlewareNameWithAliases$3 = (name, aliases) => {
        return `${name || "anonymous"}${aliases && aliases.length > 0 ? ` (a.k.a. ${aliases.join(",")})` : ""}`;
    };
    const constructStack$3 = () => {
        let absoluteEntries = [];
        let relativeEntries = [];
        let identifyOnResolve = false;
        const entriesNameSet = new Set();
        const sort = (entries) => entries.sort((a, b) => stepWeights$3[b.step] - stepWeights$3[a.step] ||
            priorityWeights$3[b.priority || "normal"] - priorityWeights$3[a.priority || "normal"]);
        const removeByName = (toRemove) => {
            let isRemoved = false;
            const filterCb = (entry) => {
                const aliases = getAllAliases$3(entry.name, entry.aliases);
                if (aliases.includes(toRemove)) {
                    isRemoved = true;
                    for (const alias of aliases) {
                        entriesNameSet.delete(alias);
                    }
                    return false;
                }
                return true;
            };
            absoluteEntries = absoluteEntries.filter(filterCb);
            relativeEntries = relativeEntries.filter(filterCb);
            return isRemoved;
        };
        const removeByReference = (toRemove) => {
            let isRemoved = false;
            const filterCb = (entry) => {
                if (entry.middleware === toRemove) {
                    isRemoved = true;
                    for (const alias of getAllAliases$3(entry.name, entry.aliases)) {
                        entriesNameSet.delete(alias);
                    }
                    return false;
                }
                return true;
            };
            absoluteEntries = absoluteEntries.filter(filterCb);
            relativeEntries = relativeEntries.filter(filterCb);
            return isRemoved;
        };
        const cloneTo = (toStack) => {
            absoluteEntries.forEach((entry) => {
                toStack.add(entry.middleware, { ...entry });
            });
            relativeEntries.forEach((entry) => {
                toStack.addRelativeTo(entry.middleware, { ...entry });
            });
            toStack.identifyOnResolve?.(stack.identifyOnResolve());
            return toStack;
        };
        const expandRelativeMiddlewareList = (from) => {
            const expandedMiddlewareList = [];
            from.before.forEach((entry) => {
                if (entry.before.length === 0 && entry.after.length === 0) {
                    expandedMiddlewareList.push(entry);
                }
                else {
                    expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
                }
            });
            expandedMiddlewareList.push(from);
            from.after.reverse().forEach((entry) => {
                if (entry.before.length === 0 && entry.after.length === 0) {
                    expandedMiddlewareList.push(entry);
                }
                else {
                    expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
                }
            });
            return expandedMiddlewareList;
        };
        const getMiddlewareList = (debug = false) => {
            const normalizedAbsoluteEntries = [];
            const normalizedRelativeEntries = [];
            const normalizedEntriesNameMap = {};
            absoluteEntries.forEach((entry) => {
                const normalizedEntry = {
                    ...entry,
                    before: [],
                    after: [],
                };
                for (const alias of getAllAliases$3(normalizedEntry.name, normalizedEntry.aliases)) {
                    normalizedEntriesNameMap[alias] = normalizedEntry;
                }
                normalizedAbsoluteEntries.push(normalizedEntry);
            });
            relativeEntries.forEach((entry) => {
                const normalizedEntry = {
                    ...entry,
                    before: [],
                    after: [],
                };
                for (const alias of getAllAliases$3(normalizedEntry.name, normalizedEntry.aliases)) {
                    normalizedEntriesNameMap[alias] = normalizedEntry;
                }
                normalizedRelativeEntries.push(normalizedEntry);
            });
            normalizedRelativeEntries.forEach((entry) => {
                if (entry.toMiddleware) {
                    const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
                    if (toMiddleware === undefined) {
                        if (debug) {
                            return;
                        }
                        throw new Error(`${entry.toMiddleware} is not found when adding ` +
                            `${getMiddlewareNameWithAliases$3(entry.name, entry.aliases)} ` +
                            `middleware ${entry.relation} ${entry.toMiddleware}`);
                    }
                    if (entry.relation === "after") {
                        toMiddleware.after.push(entry);
                    }
                    if (entry.relation === "before") {
                        toMiddleware.before.push(entry);
                    }
                }
            });
            const mainChain = sort(normalizedAbsoluteEntries)
                .map(expandRelativeMiddlewareList)
                .reduce((wholeList, expandedMiddlewareList) => {
                wholeList.push(...expandedMiddlewareList);
                return wholeList;
            }, []);
            return mainChain;
        };
        const stack = {
            add: (middleware, options = {}) => {
                const { name, override, aliases: _aliases } = options;
                const entry = {
                    step: "initialize",
                    priority: "normal",
                    middleware,
                    ...options,
                };
                const aliases = getAllAliases$3(name, _aliases);
                if (aliases.length > 0) {
                    if (aliases.some((alias) => entriesNameSet.has(alias))) {
                        if (!override)
                            throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases$3(name, _aliases)}'`);
                        for (const alias of aliases) {
                            const toOverrideIndex = absoluteEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));
                            if (toOverrideIndex === -1) {
                                continue;
                            }
                            const toOverride = absoluteEntries[toOverrideIndex];
                            if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {
                                throw new Error(`"${getMiddlewareNameWithAliases$3(toOverride.name, toOverride.aliases)}" middleware with ` +
                                    `${toOverride.priority} priority in ${toOverride.step} step cannot ` +
                                    `be overridden by "${getMiddlewareNameWithAliases$3(name, _aliases)}" middleware with ` +
                                    `${entry.priority} priority in ${entry.step} step.`);
                            }
                            absoluteEntries.splice(toOverrideIndex, 1);
                        }
                    }
                    for (const alias of aliases) {
                        entriesNameSet.add(alias);
                    }
                }
                absoluteEntries.push(entry);
            },
            addRelativeTo: (middleware, options) => {
                const { name, override, aliases: _aliases } = options;
                const entry = {
                    middleware,
                    ...options,
                };
                const aliases = getAllAliases$3(name, _aliases);
                if (aliases.length > 0) {
                    if (aliases.some((alias) => entriesNameSet.has(alias))) {
                        if (!override)
                            throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases$3(name, _aliases)}'`);
                        for (const alias of aliases) {
                            const toOverrideIndex = relativeEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));
                            if (toOverrideIndex === -1) {
                                continue;
                            }
                            const toOverride = relativeEntries[toOverrideIndex];
                            if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
                                throw new Error(`"${getMiddlewareNameWithAliases$3(toOverride.name, toOverride.aliases)}" middleware ` +
                                    `${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden ` +
                                    `by "${getMiddlewareNameWithAliases$3(name, _aliases)}" middleware ${entry.relation} ` +
                                    `"${entry.toMiddleware}" middleware.`);
                            }
                            relativeEntries.splice(toOverrideIndex, 1);
                        }
                    }
                    for (const alias of aliases) {
                        entriesNameSet.add(alias);
                    }
                }
                relativeEntries.push(entry);
            },
            clone: () => cloneTo(constructStack$3()),
            use: (plugin) => {
                plugin.applyToStack(stack);
            },
            remove: (toRemove) => {
                if (typeof toRemove === "string")
                    return removeByName(toRemove);
                else
                    return removeByReference(toRemove);
            },
            removeByTag: (toRemove) => {
                let isRemoved = false;
                const filterCb = (entry) => {
                    const { tags, name, aliases: _aliases } = entry;
                    if (tags && tags.includes(toRemove)) {
                        const aliases = getAllAliases$3(name, _aliases);
                        for (const alias of aliases) {
                            entriesNameSet.delete(alias);
                        }
                        isRemoved = true;
                        return false;
                    }
                    return true;
                };
                absoluteEntries = absoluteEntries.filter(filterCb);
                relativeEntries = relativeEntries.filter(filterCb);
                return isRemoved;
            },
            concat: (from) => {
                const cloned = cloneTo(constructStack$3());
                cloned.use(from);
                cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || (from.identifyOnResolve?.() ?? false));
                return cloned;
            },
            applyToStack: cloneTo,
            identify: () => {
                return getMiddlewareList(true).map((mw) => {
                    const step = mw.step ??
                        mw.relation +
                            " " +
                            mw.toMiddleware;
                    return getMiddlewareNameWithAliases$3(mw.name, mw.aliases) + " - " + step;
                });
            },
            identifyOnResolve(toggle) {
                if (typeof toggle === "boolean")
                    identifyOnResolve = toggle;
                return identifyOnResolve;
            },
            resolve: (handler, context) => {
                for (const middleware of getMiddlewareList()
                    .map((entry) => entry.middleware)
                    .reverse()) {
                    handler = middleware(handler, context);
                }
                if (identifyOnResolve) {
                    console.log(stack.identify());
                }
                return handler;
            },
        };
        return stack;
    };
    const stepWeights$3 = {
        initialize: 5,
        serialize: 4,
        build: 3,
        finalizeRequest: 2,
        deserialize: 1,
    };
    const priorityWeights$3 = {
        high: 3,
        normal: 2,
        low: 1,
    };

    let Client$3 = class Client {
        constructor(config) {
            this.middlewareStack = constructStack$3();
            this.config = config;
        }
        send(command, optionsOrCb, cb) {
            const options = typeof optionsOrCb !== "function" ? optionsOrCb : undefined;
            const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
            const handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
            if (callback) {
                handler(command)
                    .then((result) => callback(null, result.output), (err) => callback(err))
                    .catch(() => { });
            }
            else {
                return handler(command).then((result) => result.output);
            }
        }
        destroy() {
            if (this.config.requestHandler.destroy)
                this.config.requestHandler.destroy();
        }
    };

    const alphabetByEncoding$3 = {};
    const alphabetByValue$3 = new Array(64);
    for (let i = 0, start = "A".charCodeAt(0), limit = "Z".charCodeAt(0); i + start <= limit; i++) {
        const char = String.fromCharCode(i + start);
        alphabetByEncoding$3[char] = i;
        alphabetByValue$3[i] = char;
    }
    for (let i = 0, start = "a".charCodeAt(0), limit = "z".charCodeAt(0); i + start <= limit; i++) {
        const char = String.fromCharCode(i + start);
        const index = i + 26;
        alphabetByEncoding$3[char] = index;
        alphabetByValue$3[index] = char;
    }
    for (let i = 0; i < 10; i++) {
        alphabetByEncoding$3[i.toString(10)] = i + 52;
        const char = i.toString(10);
        const index = i + 52;
        alphabetByEncoding$3[char] = index;
        alphabetByValue$3[index] = char;
    }
    alphabetByEncoding$3["+"] = 62;
    alphabetByValue$3[62] = "+";
    alphabetByEncoding$3["/"] = 63;
    alphabetByValue$3[63] = "/";
    const bitsPerLetter$3 = 6;
    const bitsPerByte$3 = 8;
    const maxLetterValue$3 = 0b111111;

    const fromBase64$3 = (input) => {
        let totalByteLength = (input.length / 4) * 3;
        if (input.slice(-2) === "==") {
            totalByteLength -= 2;
        }
        else if (input.slice(-1) === "=") {
            totalByteLength--;
        }
        const out = new ArrayBuffer(totalByteLength);
        const dataView = new DataView(out);
        for (let i = 0; i < input.length; i += 4) {
            let bits = 0;
            let bitLength = 0;
            for (let j = i, limit = i + 3; j <= limit; j++) {
                if (input[j] !== "=") {
                    if (!(input[j] in alphabetByEncoding$3)) {
                        throw new TypeError(`Invalid character ${input[j]} in base64 string.`);
                    }
                    bits |= alphabetByEncoding$3[input[j]] << ((limit - j) * bitsPerLetter$3);
                    bitLength += bitsPerLetter$3;
                }
                else {
                    bits >>= bitsPerLetter$3;
                }
            }
            const chunkOffset = (i / 4) * 3;
            bits >>= bitLength % bitsPerByte$3;
            const byteLength = Math.floor(bitLength / bitsPerByte$3);
            for (let k = 0; k < byteLength; k++) {
                const offset = (byteLength - k - 1) * bitsPerByte$3;
                dataView.setUint8(chunkOffset + k, (bits & (255 << offset)) >> offset);
            }
        }
        return new Uint8Array(out);
    };

    const fromUtf8$9 = (input) => new TextEncoder().encode(input);

    const toUint8Array$1 = (data) => {
        if (typeof data === "string") {
            return fromUtf8$9(data);
        }
        if (ArrayBuffer.isView(data)) {
            return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
        }
        return new Uint8Array(data);
    };

    const toUtf8$6 = (input) => {
        if (typeof input === "string") {
            return input;
        }
        if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
            throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
        }
        return new TextDecoder("utf-8").decode(input);
    };

    function toBase64$3(_input) {
        let input;
        if (typeof _input === "string") {
            input = fromUtf8$9(_input);
        }
        else {
            input = _input;
        }
        const isArrayLike = typeof input === "object" && typeof input.length === "number";
        const isUint8Array = typeof input === "object" &&
            typeof input.byteOffset === "number" &&
            typeof input.byteLength === "number";
        if (!isArrayLike && !isUint8Array) {
            throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
        }
        let str = "";
        for (let i = 0; i < input.length; i += 3) {
            let bits = 0;
            let bitLength = 0;
            for (let j = i, limit = Math.min(i + 3, input.length); j < limit; j++) {
                bits |= input[j] << ((limit - j - 1) * bitsPerByte$3);
                bitLength += bitsPerByte$3;
            }
            const bitClusterCount = Math.ceil(bitLength / bitsPerLetter$3);
            bits <<= bitClusterCount * bitsPerLetter$3 - bitLength;
            for (let k = 1; k <= bitClusterCount; k++) {
                const offset = (bitClusterCount - k) * bitsPerLetter$3;
                str += alphabetByValue$3[(bits & (maxLetterValue$3 << offset)) >> offset];
            }
            str += "==".slice(0, 4 - bitClusterCount);
        }
        return str;
    }

    function transformToString$3(payload, encoding = "utf-8") {
        if (encoding === "base64") {
            return toBase64$3(payload);
        }
        return toUtf8$6(payload);
    }
    function transformFromString$3(str, encoding) {
        if (encoding === "base64") {
            return Uint8ArrayBlobAdapter$3.mutate(fromBase64$3(str));
        }
        return Uint8ArrayBlobAdapter$3.mutate(fromUtf8$9(str));
    }

    let Uint8ArrayBlobAdapter$3 = class Uint8ArrayBlobAdapter extends Uint8Array {
        static fromString(source, encoding = "utf-8") {
            switch (typeof source) {
                case "string":
                    return transformFromString$3(source, encoding);
                default:
                    throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
            }
        }
        static mutate(source) {
            Object.setPrototypeOf(source, Uint8ArrayBlobAdapter.prototype);
            return source;
        }
        transformToString(encoding = "utf-8") {
            return transformToString$3(this, encoding);
        }
    };

    const escapeUri$4 = (uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode$4);
    const hexEncode$4 = (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`;

    function buildQueryString$3(query) {
        const parts = [];
        for (let key of Object.keys(query).sort()) {
            const value = query[key];
            key = escapeUri$4(key);
            if (Array.isArray(value)) {
                for (let i = 0, iLen = value.length; i < iLen; i++) {
                    parts.push(`${key}=${escapeUri$4(value[i])}`);
                }
            }
            else {
                let qsEntry = key;
                if (value || typeof value === "string") {
                    qsEntry += `=${escapeUri$4(value)}`;
                }
                parts.push(qsEntry);
            }
        }
        return parts.join("&");
    }

    function requestTimeout$3(timeoutInMs = 0) {
        return new Promise((resolve, reject) => {
            if (timeoutInMs) {
                setTimeout(() => {
                    const timeoutError = new Error(`Request did not complete within ${timeoutInMs} ms`);
                    timeoutError.name = "TimeoutError";
                    reject(timeoutError);
                }, timeoutInMs);
            }
        });
    }

    const keepAliveSupport$3 = {
        supported: undefined,
    };
    let FetchHttpHandler$3 = class FetchHttpHandler {
        static create(instanceOrOptions) {
            if (typeof instanceOrOptions?.handle === "function") {
                return instanceOrOptions;
            }
            return new FetchHttpHandler(instanceOrOptions);
        }
        constructor(options) {
            if (typeof options === "function") {
                this.configProvider = options().then((opts) => opts || {});
            }
            else {
                this.config = options ?? {};
                this.configProvider = Promise.resolve(this.config);
            }
            if (keepAliveSupport$3.supported === undefined) {
                keepAliveSupport$3.supported = Boolean(typeof Request !== "undefined" && "keepalive" in new Request("https://[::1]"));
            }
        }
        destroy() {
        }
        async handle(request, { abortSignal } = {}) {
            if (!this.config) {
                this.config = await this.configProvider;
            }
            const requestTimeoutInMs = this.config.requestTimeout;
            const keepAlive = this.config.keepAlive === true;
            const credentials = this.config.credentials;
            if (abortSignal?.aborted) {
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                return Promise.reject(abortError);
            }
            let path = request.path;
            const queryString = buildQueryString$3(request.query || {});
            if (queryString) {
                path += `?${queryString}`;
            }
            if (request.fragment) {
                path += `#${request.fragment}`;
            }
            let auth = "";
            if (request.username != null || request.password != null) {
                const username = request.username ?? "";
                const password = request.password ?? "";
                auth = `${username}:${password}@`;
            }
            const { port, method } = request;
            const url = `${request.protocol}//${auth}${request.hostname}${port ? `:${port}` : ""}${path}`;
            const body = method === "GET" || method === "HEAD" ? undefined : request.body;
            const requestOptions = {
                body,
                headers: new Headers(request.headers),
                method: method,
                credentials,
            };
            if (body) {
                requestOptions.duplex = "half";
            }
            if (typeof AbortController !== "undefined") {
                requestOptions.signal = abortSignal;
            }
            if (keepAliveSupport$3.supported) {
                requestOptions.keepalive = keepAlive;
            }
            let removeSignalEventListener = () => { };
            const fetchRequest = new Request(url, requestOptions);
            const raceOfPromises = [
                fetch(fetchRequest).then((response) => {
                    const fetchHeaders = response.headers;
                    const transformedHeaders = {};
                    for (const pair of fetchHeaders.entries()) {
                        transformedHeaders[pair[0]] = pair[1];
                    }
                    const hasReadableStream = response.body != undefined;
                    if (!hasReadableStream) {
                        return response.blob().then((body) => ({
                            response: new HttpResponse$4({
                                headers: transformedHeaders,
                                reason: response.statusText,
                                statusCode: response.status,
                                body,
                            }),
                        }));
                    }
                    return {
                        response: new HttpResponse$4({
                            headers: transformedHeaders,
                            reason: response.statusText,
                            statusCode: response.status,
                            body: response.body,
                        }),
                    };
                }),
                requestTimeout$3(requestTimeoutInMs),
            ];
            if (abortSignal) {
                raceOfPromises.push(new Promise((resolve, reject) => {
                    const onAbort = () => {
                        const abortError = new Error("Request aborted");
                        abortError.name = "AbortError";
                        reject(abortError);
                    };
                    if (typeof abortSignal.addEventListener === "function") {
                        const signal = abortSignal;
                        signal.addEventListener("abort", onAbort, { once: true });
                        removeSignalEventListener = () => signal.removeEventListener("abort", onAbort);
                    }
                    else {
                        abortSignal.onabort = onAbort;
                    }
                }));
            }
            return Promise.race(raceOfPromises).finally(removeSignalEventListener);
        }
        updateHttpClientConfig(key, value) {
            this.config = undefined;
            this.configProvider = this.configProvider.then((config) => {
                config[key] = value;
                return config;
            });
        }
        httpHandlerConfigs() {
            return this.config ?? {};
        }
    };

    const streamCollector$3 = (stream) => {
        if (typeof Blob === "function" && stream instanceof Blob) {
            return collectBlob$3(stream);
        }
        return collectStream$3(stream);
    };
    async function collectBlob$3(blob) {
        const base64 = await readToBase64$3(blob);
        const arrayBuffer = fromBase64$3(base64);
        return new Uint8Array(arrayBuffer);
    }
    async function collectStream$3(stream) {
        const chunks = [];
        const reader = stream.getReader();
        let isDone = false;
        let length = 0;
        while (!isDone) {
            const { done, value } = await reader.read();
            if (value) {
                chunks.push(value);
                length += value.length;
            }
            isDone = done;
        }
        const collected = new Uint8Array(length);
        let offset = 0;
        for (const chunk of chunks) {
            collected.set(chunk, offset);
            offset += chunk.length;
        }
        return collected;
    }
    function readToBase64$3(blob) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => {
                if (reader.readyState !== 2) {
                    return reject(new Error("Reader aborted too early"));
                }
                const result = (reader.result ?? "");
                const commaIndex = result.indexOf(",");
                const dataOffset = commaIndex > -1 ? commaIndex + 1 : result.length;
                resolve(result.substring(dataOffset));
            };
            reader.onabort = () => reject(new Error("Read aborted"));
            reader.onerror = () => reject(reader.error);
            reader.readAsDataURL(blob);
        });
    }

    const SHORT_TO_HEX$1 = {};
    const HEX_TO_SHORT$1 = {};
    for (let i = 0; i < 256; i++) {
        let encodedByte = i.toString(16).toLowerCase();
        if (encodedByte.length === 1) {
            encodedByte = `0${encodedByte}`;
        }
        SHORT_TO_HEX$1[i] = encodedByte;
        HEX_TO_SHORT$1[encodedByte] = i;
    }
    function fromHex$1(encoded) {
        if (encoded.length % 2 !== 0) {
            throw new Error("Hex encoded strings must have an even number length");
        }
        const out = new Uint8Array(encoded.length / 2);
        for (let i = 0; i < encoded.length; i += 2) {
            const encodedByte = encoded.slice(i, i + 2).toLowerCase();
            if (encodedByte in HEX_TO_SHORT$1) {
                out[i / 2] = HEX_TO_SHORT$1[encodedByte];
            }
            else {
                throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
            }
        }
        return out;
    }
    function toHex$1(bytes) {
        let out = "";
        for (let i = 0; i < bytes.byteLength; i++) {
            out += SHORT_TO_HEX$1[bytes[i]];
        }
        return out;
    }

    const isReadableStream = (stream) => typeof ReadableStream === "function" &&
        (stream?.constructor?.name === ReadableStream.name || stream instanceof ReadableStream);

    const ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
    const sdkStreamMixin = (stream) => {
        if (!isBlobInstance(stream) && !isReadableStream(stream)) {
            const name = stream?.__proto__?.constructor?.name || stream;
            throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${name}`);
        }
        let transformed = false;
        const transformToByteArray = async () => {
            if (transformed) {
                throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
            }
            transformed = true;
            return await streamCollector$3(stream);
        };
        const blobToWebStream = (blob) => {
            if (typeof blob.stream !== "function") {
                throw new Error("Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.\n" +
                    "If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body");
            }
            return blob.stream();
        };
        return Object.assign(stream, {
            transformToByteArray: transformToByteArray,
            transformToString: async (encoding) => {
                const buf = await transformToByteArray();
                if (encoding === "base64") {
                    return toBase64$3(buf);
                }
                else if (encoding === "hex") {
                    return toHex$1(buf);
                }
                else if (encoding === undefined || encoding === "utf8" || encoding === "utf-8") {
                    return toUtf8$6(buf);
                }
                else if (typeof TextDecoder === "function") {
                    return new TextDecoder(encoding).decode(buf);
                }
                else {
                    throw new Error("TextDecoder is not available, please make sure polyfill is provided.");
                }
            },
            transformToWebStream: () => {
                if (transformed) {
                    throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
                }
                transformed = true;
                if (isBlobInstance(stream)) {
                    return blobToWebStream(stream);
                }
                else if (isReadableStream(stream)) {
                    return stream;
                }
                else {
                    throw new Error(`Cannot transform payload to web stream, got ${stream}`);
                }
            },
        });
    };
    const isBlobInstance = (stream) => typeof Blob === "function" && stream instanceof Blob;

    const collectBody$3 = async (streamBody = new Uint8Array(), context) => {
        if (streamBody instanceof Uint8Array) {
            return Uint8ArrayBlobAdapter$3.mutate(streamBody);
        }
        if (!streamBody) {
            return Uint8ArrayBlobAdapter$3.mutate(new Uint8Array());
        }
        const fromContext = context.streamCollector(streamBody);
        return Uint8ArrayBlobAdapter$3.mutate(await fromContext);
    };

    let Command$3 = class Command {
        constructor() {
            this.middlewareStack = constructStack$3();
        }
        static classBuilder() {
            return new ClassBuilder$3();
        }
        resolveMiddlewareWithContext(clientStack, configuration, options, { middlewareFn, clientName, commandName, inputFilterSensitiveLog, outputFilterSensitiveLog, smithyContext, additionalContext, CommandCtor, }) {
            for (const mw of middlewareFn.bind(this)(CommandCtor, clientStack, configuration, options)) {
                this.middlewareStack.use(mw);
            }
            const stack = clientStack.concat(this.middlewareStack);
            const { logger } = configuration;
            const handlerExecutionContext = {
                logger,
                clientName,
                commandName,
                inputFilterSensitiveLog,
                outputFilterSensitiveLog,
                [SMITHY_CONTEXT_KEY$3]: {
                    ...smithyContext,
                },
                ...additionalContext,
            };
            const { requestHandler } = configuration;
            return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
    };
    let ClassBuilder$3 = class ClassBuilder {
        constructor() {
            this._init = () => { };
            this._ep = {};
            this._middlewareFn = () => [];
            this._commandName = "";
            this._clientName = "";
            this._additionalContext = {};
            this._smithyContext = {};
            this._inputFilterSensitiveLog = (_) => _;
            this._outputFilterSensitiveLog = (_) => _;
            this._serializer = null;
            this._deserializer = null;
        }
        init(cb) {
            this._init = cb;
        }
        ep(endpointParameterInstructions) {
            this._ep = endpointParameterInstructions;
            return this;
        }
        m(middlewareSupplier) {
            this._middlewareFn = middlewareSupplier;
            return this;
        }
        s(service, operation, smithyContext = {}) {
            this._smithyContext = {
                service,
                operation,
                ...smithyContext,
            };
            return this;
        }
        c(additionalContext = {}) {
            this._additionalContext = additionalContext;
            return this;
        }
        n(clientName, commandName) {
            this._clientName = clientName;
            this._commandName = commandName;
            return this;
        }
        f(inputFilter = (_) => _, outputFilter = (_) => _) {
            this._inputFilterSensitiveLog = inputFilter;
            this._outputFilterSensitiveLog = outputFilter;
            return this;
        }
        ser(serializer) {
            this._serializer = serializer;
            return this;
        }
        de(deserializer) {
            this._deserializer = deserializer;
            return this;
        }
        build() {
            const closure = this;
            let CommandRef;
            return (CommandRef = class extends Command$3 {
                static getEndpointParameterInstructions() {
                    return closure._ep;
                }
                constructor(...[input]) {
                    super();
                    this.serialize = closure._serializer;
                    this.deserialize = closure._deserializer;
                    this.input = input ?? {};
                    closure._init(this);
                }
                resolveMiddleware(stack, configuration, options) {
                    return this.resolveMiddlewareWithContext(stack, configuration, options, {
                        CommandCtor: CommandRef,
                        middlewareFn: closure._middlewareFn,
                        clientName: closure._clientName,
                        commandName: closure._commandName,
                        inputFilterSensitiveLog: closure._inputFilterSensitiveLog,
                        outputFilterSensitiveLog: closure._outputFilterSensitiveLog,
                        smithyContext: closure._smithyContext,
                        additionalContext: closure._additionalContext,
                    });
                }
            });
        }
    };

    const SENSITIVE_STRING$3 = "***SensitiveInformation***";

    const createAggregatedClient$3 = (commands, Client) => {
        for (const command of Object.keys(commands)) {
            const CommandCtor = commands[command];
            const methodImpl = async function (args, optionsOrCb, cb) {
                const command = new CommandCtor(args);
                if (typeof optionsOrCb === "function") {
                    this.send(command, optionsOrCb);
                }
                else if (typeof cb === "function") {
                    if (typeof optionsOrCb !== "object")
                        throw new Error(`Expected http options but got ${typeof optionsOrCb}`);
                    this.send(command, optionsOrCb || {}, cb);
                }
                else {
                    return this.send(command, optionsOrCb);
                }
            };
            const methodName = (command[0].toLowerCase() + command.slice(1)).replace(/Command$/, "");
            Client.prototype[methodName] = methodImpl;
        }
    };

    const expectBoolean$2 = (value) => {
        if (value === null || value === undefined) {
            return undefined;
        }
        if (typeof value === "number") {
            if (value === 0 || value === 1) {
                logger$3.warn(stackTraceWarning$3(`Expected boolean, got ${typeof value}: ${value}`));
            }
            if (value === 0) {
                return false;
            }
            if (value === 1) {
                return true;
            }
        }
        if (typeof value === "string") {
            const lower = value.toLowerCase();
            if (lower === "false" || lower === "true") {
                logger$3.warn(stackTraceWarning$3(`Expected boolean, got ${typeof value}: ${value}`));
            }
            if (lower === "false") {
                return false;
            }
            if (lower === "true") {
                return true;
            }
        }
        if (typeof value === "boolean") {
            return value;
        }
        throw new TypeError(`Expected boolean, got ${typeof value}: ${value}`);
    };
    const expectNumber$2 = (value) => {
        if (value === null || value === undefined) {
            return undefined;
        }
        if (typeof value === "string") {
            const parsed = parseFloat(value);
            if (!Number.isNaN(parsed)) {
                if (String(parsed) !== String(value)) {
                    logger$3.warn(stackTraceWarning$3(`Expected number but observed string: ${value}`));
                }
                return parsed;
            }
        }
        if (typeof value === "number") {
            return value;
        }
        throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
    };
    const MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
    const expectFloat32 = (value) => {
        const expected = expectNumber$2(value);
        if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
            if (Math.abs(expected) > MAX_FLOAT) {
                throw new TypeError(`Expected 32-bit float, got ${value}`);
            }
        }
        return expected;
    };
    const expectLong$2 = (value) => {
        if (value === null || value === undefined) {
            return undefined;
        }
        if (Number.isInteger(value) && !Number.isNaN(value)) {
            return value;
        }
        throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
    };
    const expectInt32$1 = (value) => expectSizedInt$1(value, 32);
    const expectShort = (value) => expectSizedInt$1(value, 16);
    const expectByte = (value) => expectSizedInt$1(value, 8);
    const expectSizedInt$1 = (value, size) => {
        const expected = expectLong$2(value);
        if (expected !== undefined && castInt$1(expected, size) !== expected) {
            throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
        }
        return expected;
    };
    const castInt$1 = (value, size) => {
        switch (size) {
            case 32:
                return Int32Array.of(value)[0];
            case 16:
                return Int16Array.of(value)[0];
            case 8:
                return Int8Array.of(value)[0];
        }
    };
    const expectNonNull$3 = (value, location) => {
        if (value === null || value === undefined) {
            if (location) {
                throw new TypeError(`Expected a non-null value for ${location}`);
            }
            throw new TypeError("Expected a non-null value");
        }
        return value;
    };
    const expectObject$2 = (value) => {
        if (value === null || value === undefined) {
            return undefined;
        }
        if (typeof value === "object" && !Array.isArray(value)) {
            return value;
        }
        const receivedType = Array.isArray(value) ? "array" : typeof value;
        throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
    };
    const expectString$3 = (value) => {
        if (value === null || value === undefined) {
            return undefined;
        }
        if (typeof value === "string") {
            return value;
        }
        if (["boolean", "number", "bigint"].includes(typeof value)) {
            logger$3.warn(stackTraceWarning$3(`Expected string, got ${typeof value}: ${value}`));
            return String(value);
        }
        throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
    };
    const strictParseDouble = (value) => {
        if (typeof value == "string") {
            return expectNumber$2(parseNumber(value));
        }
        return expectNumber$2(value);
    };
    const strictParseFloat32 = (value) => {
        if (typeof value == "string") {
            return expectFloat32(parseNumber(value));
        }
        return expectFloat32(value);
    };
    const NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
    const parseNumber = (value) => {
        const matches = value.match(NUMBER_REGEX);
        if (matches === null || matches[0].length !== value.length) {
            throw new TypeError(`Expected real number, got implicit NaN`);
        }
        return parseFloat(value);
    };
    const limitedParseDouble$2 = (value) => {
        if (typeof value == "string") {
            return parseFloatString$2(value);
        }
        return expectNumber$2(value);
    };
    const parseFloatString$2 = (value) => {
        switch (value) {
            case "NaN":
                return NaN;
            case "Infinity":
                return Infinity;
            case "-Infinity":
                return -Infinity;
            default:
                throw new Error(`Unable to parse float value: ${value}`);
        }
    };
    const strictParseInt32 = (value) => {
        if (typeof value === "string") {
            return expectInt32$1(parseNumber(value));
        }
        return expectInt32$1(value);
    };
    const strictParseShort = (value) => {
        if (typeof value === "string") {
            return expectShort(parseNumber(value));
        }
        return expectShort(value);
    };
    const strictParseByte = (value) => {
        if (typeof value === "string") {
            return expectByte(parseNumber(value));
        }
        return expectByte(value);
    };
    const stackTraceWarning$3 = (message) => {
        return String(new TypeError(message).stack || message)
            .split("\n")
            .slice(0, 5)
            .filter((s) => !s.includes("stackTraceWarning"))
            .join("\n");
    };
    const logger$3 = {
        warn: console.warn,
    };

    const MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    const RFC3339 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/);
    const parseRfc3339DateTime = (value) => {
        if (value === null || value === undefined) {
            return undefined;
        }
        if (typeof value !== "string") {
            throw new TypeError("RFC-3339 date-times must be expressed as strings");
        }
        const match = RFC3339.exec(value);
        if (!match) {
            throw new TypeError("Invalid RFC-3339 date-time value");
        }
        const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        const year = strictParseShort(stripLeadingZeroes(yearStr));
        const month = parseDateValue(monthStr, "month", 1, 12);
        const day = parseDateValue(dayStr, "day", 1, 31);
        return buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
    };
    const RFC3339_WITH_OFFSET = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/);
    const parseRfc3339DateTimeWithOffset = (value) => {
        if (value === null || value === undefined) {
            return undefined;
        }
        if (typeof value !== "string") {
            throw new TypeError("RFC-3339 date-times must be expressed as strings");
        }
        const match = RFC3339_WITH_OFFSET.exec(value);
        if (!match) {
            throw new TypeError("Invalid RFC-3339 date-time value");
        }
        const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
        const year = strictParseShort(stripLeadingZeroes(yearStr));
        const month = parseDateValue(monthStr, "month", 1, 12);
        const day = parseDateValue(dayStr, "day", 1, 31);
        const date = buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
        if (offsetStr.toUpperCase() != "Z") {
            date.setTime(date.getTime() - parseOffsetToMilliseconds(offsetStr));
        }
        return date;
    };
    const parseEpochTimestamp = (value) => {
        if (value === null || value === undefined) {
            return undefined;
        }
        let valueAsDouble;
        if (typeof value === "number") {
            valueAsDouble = value;
        }
        else if (typeof value === "string") {
            valueAsDouble = strictParseDouble(value);
        }
        else {
            throw new TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
        }
        if (Number.isNaN(valueAsDouble) || valueAsDouble === Infinity || valueAsDouble === -Infinity) {
            throw new TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
        }
        return new Date(Math.round(valueAsDouble * 1000));
    };
    const buildDate = (year, month, day, time) => {
        const adjustedMonth = month - 1;
        validateDayOfMonth(year, adjustedMonth, day);
        return new Date(Date.UTC(year, adjustedMonth, day, parseDateValue(time.hours, "hour", 0, 23), parseDateValue(time.minutes, "minute", 0, 59), parseDateValue(time.seconds, "seconds", 0, 60), parseMilliseconds(time.fractionalMilliseconds)));
    };
    const DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    const validateDayOfMonth = (year, month, day) => {
        let maxDays = DAYS_IN_MONTH[month];
        if (month === 1 && isLeapYear(year)) {
            maxDays = 29;
        }
        if (day > maxDays) {
            throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year}: ${day}`);
        }
    };
    const isLeapYear = (year) => {
        return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    };
    const parseDateValue = (value, type, lower, upper) => {
        const dateVal = strictParseByte(stripLeadingZeroes(value));
        if (dateVal < lower || dateVal > upper) {
            throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
        }
        return dateVal;
    };
    const parseMilliseconds = (value) => {
        if (value === null || value === undefined) {
            return 0;
        }
        return strictParseFloat32("0." + value) * 1000;
    };
    const parseOffsetToMilliseconds = (value) => {
        const directionStr = value[0];
        let direction = 1;
        if (directionStr == "+") {
            direction = 1;
        }
        else if (directionStr == "-") {
            direction = -1;
        }
        else {
            throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
        }
        const hour = Number(value.substring(1, 3));
        const minute = Number(value.substring(4, 6));
        return direction * (hour * 60 + minute) * 60 * 1000;
    };
    const stripLeadingZeroes = (value) => {
        let idx = 0;
        while (idx < value.length - 1 && value.charAt(idx) === "0") {
            idx++;
        }
        if (idx === 0) {
            return value;
        }
        return value.slice(idx);
    };

    let ServiceException$3 = class ServiceException extends Error {
        constructor(options) {
            super(options.message);
            Object.setPrototypeOf(this, ServiceException.prototype);
            this.name = options.name;
            this.$fault = options.$fault;
            this.$metadata = options.$metadata;
        }
    };
    const decorateServiceException$3 = (exception, additions = {}) => {
        Object.entries(additions)
            .filter(([, v]) => v !== undefined)
            .forEach(([k, v]) => {
            if (exception[k] == undefined || exception[k] === "") {
                exception[k] = v;
            }
        });
        const message = exception.message || exception.Message || "UnknownError";
        exception.message = message;
        delete exception.Message;
        return exception;
    };

    const throwDefaultError$9 = ({ output, parsedBody, exceptionCtor, errorCode }) => {
        const $metadata = deserializeMetadata$9(output);
        const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
        const response = new exceptionCtor({
            name: parsedBody?.code || parsedBody?.Code || errorCode || statusCode || "UnknownError",
            $fault: "client",
            $metadata,
        });
        throw decorateServiceException$3(response, parsedBody);
    };
    const withBaseException$3 = (ExceptionCtor) => {
        return ({ output, parsedBody, errorCode }) => {
            throwDefaultError$9({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
        };
    };
    const deserializeMetadata$9 = (output) => ({
        httpStatusCode: output.statusCode,
        requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
        extendedRequestId: output.headers["x-amz-id-2"],
        cfId: output.headers["x-amz-cf-id"],
    });

    const loadConfigsForDefaultMode$3 = (mode) => {
        switch (mode) {
            case "standard":
                return {
                    retryMode: "standard",
                    connectionTimeout: 3100,
                };
            case "in-region":
                return {
                    retryMode: "standard",
                    connectionTimeout: 1100,
                };
            case "cross-region":
                return {
                    retryMode: "standard",
                    connectionTimeout: 3100,
                };
            case "mobile":
                return {
                    retryMode: "standard",
                    connectionTimeout: 30000,
                };
            default:
                return {};
        }
    };

    const getChecksumConfiguration$3 = (runtimeConfig) => {
        const checksumAlgorithms = [];
        for (const id in AlgorithmId$4) {
            const algorithmId = AlgorithmId$4[id];
            if (runtimeConfig[algorithmId] === undefined) {
                continue;
            }
            checksumAlgorithms.push({
                algorithmId: () => algorithmId,
                checksumConstructor: () => runtimeConfig[algorithmId],
            });
        }
        return {
            _checksumAlgorithms: checksumAlgorithms,
            addChecksumAlgorithm(algo) {
                this._checksumAlgorithms.push(algo);
            },
            checksumAlgorithms() {
                return this._checksumAlgorithms;
            },
        };
    };
    const resolveChecksumRuntimeConfig$3 = (clientConfig) => {
        const runtimeConfig = {};
        clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
            runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
        });
        return runtimeConfig;
    };

    const getRetryConfiguration$3 = (runtimeConfig) => {
        let _retryStrategy = runtimeConfig.retryStrategy;
        return {
            setRetryStrategy(retryStrategy) {
                _retryStrategy = retryStrategy;
            },
            retryStrategy() {
                return _retryStrategy;
            },
        };
    };
    const resolveRetryRuntimeConfig$3 = (retryStrategyConfiguration) => {
        const runtimeConfig = {};
        runtimeConfig.retryStrategy = retryStrategyConfiguration.retryStrategy();
        return runtimeConfig;
    };

    const getDefaultExtensionConfiguration$3 = (runtimeConfig) => {
        return {
            ...getChecksumConfiguration$3(runtimeConfig),
            ...getRetryConfiguration$3(runtimeConfig),
        };
    };
    const resolveDefaultRuntimeConfig$3 = (config) => {
        return {
            ...resolveChecksumRuntimeConfig$3(config),
            ...resolveRetryRuntimeConfig$3(config),
        };
    };

    function extendedEncodeURIComponent$2(str) {
        return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
            return "%" + c.charCodeAt(0).toString(16).toUpperCase();
        });
    }

    const getValueFromTextNode = (obj) => {
        const textNodeName = "#text";
        for (const key in obj) {
            if (obj.hasOwnProperty(key) && obj[key][textNodeName] !== undefined) {
                obj[key] = obj[key][textNodeName];
            }
            else if (typeof obj[key] === "object" && obj[key] !== null) {
                obj[key] = getValueFromTextNode(obj[key]);
            }
        }
        return obj;
    };

    const StringWrapper$3 = function () {
        const Class = Object.getPrototypeOf(this).constructor;
        const Constructor = Function.bind.apply(String, [null, ...arguments]);
        const instance = new Constructor();
        Object.setPrototypeOf(instance, Class.prototype);
        return instance;
    };
    StringWrapper$3.prototype = Object.create(String.prototype, {
        constructor: {
            value: StringWrapper$3,
            enumerable: false,
            writable: true,
            configurable: true,
        },
    });
    Object.setPrototypeOf(StringWrapper$3, String);

    function map$3(arg0, arg1, arg2) {
        let target;
        let instructions;
        {
            target = {};
            instructions = arg0;
        }
        for (const key of Object.keys(instructions)) {
            if (!Array.isArray(instructions[key])) {
                target[key] = instructions[key];
                continue;
            }
            applyInstruction$3(target, null, instructions, key);
        }
        return target;
    }
    const take$3 = (source, instructions) => {
        const out = {};
        for (const key in instructions) {
            applyInstruction$3(out, source, instructions, key);
        }
        return out;
    };
    const applyInstruction$3 = (target, source, instructions, targetKey) => {
        if (source !== null) {
            let instruction = instructions[targetKey];
            if (typeof instruction === "function") {
                instruction = [, instruction];
            }
            const [filter = nonNullish$3, valueFn = pass$3, sourceKey = targetKey] = instruction;
            if ((typeof filter === "function" && filter(source[sourceKey])) || (typeof filter !== "function" && !!filter)) {
                target[targetKey] = valueFn(source[sourceKey]);
            }
            return;
        }
        let [filter, value] = instructions[targetKey];
        if (typeof value === "function") {
            let _value;
            const defaultFilterPassed = filter === undefined && (_value = value()) != null;
            const customFilterPassed = (typeof filter === "function" && !!filter(void 0)) || (typeof filter !== "function" && !!filter);
            if (defaultFilterPassed) {
                target[targetKey] = _value;
            }
            else if (customFilterPassed) {
                target[targetKey] = value();
            }
        }
        else {
            const defaultFilterPassed = filter === undefined && value != null;
            const customFilterPassed = (typeof filter === "function" && !!filter(value)) || (typeof filter !== "function" && !!filter);
            if (defaultFilterPassed || customFilterPassed) {
                target[targetKey] = value;
            }
        }
    };
    const nonNullish$3 = (_) => _ != null;
    const pass$3 = (_) => _;

    const resolvedPath$2 = (resolvedPath, input, memberName, labelValueProvider, uriLabel, isGreedyLabel) => {
        if (input != null && input[memberName] !== undefined) {
            const labelValue = labelValueProvider();
            if (labelValue.length <= 0) {
                throw new Error("Empty value provided for input HTTP label: " + memberName + ".");
            }
            resolvedPath = resolvedPath.replace(uriLabel, isGreedyLabel
                ? labelValue
                    .split("/")
                    .map((segment) => extendedEncodeURIComponent$2(segment))
                    .join("/")
                : extendedEncodeURIComponent$2(labelValue));
        }
        else {
            throw new Error("No value provided for input HTTP label: " + memberName + ".");
        }
        return resolvedPath;
    };

    const serializeFloat$2 = (value) => {
        if (value !== value) {
            return "NaN";
        }
        switch (value) {
            case Infinity:
                return "Infinity";
            case -Infinity:
                return "-Infinity";
            default:
                return value;
        }
    };
    const serializeDateTime = (date) => date.toISOString().replace(".000Z", "Z");

    const _json$2 = (obj) => {
        if (obj == null) {
            return {};
        }
        if (Array.isArray(obj)) {
            return obj.filter((_) => _ != null).map(_json$2);
        }
        if (typeof obj === "object") {
            const target = {};
            for (const key of Object.keys(obj)) {
                if (obj[key] == null) {
                    continue;
                }
                target[key] = _json$2(obj[key]);
            }
            return target;
        }
        return obj;
    };

    const isStreamingPayload$3 = (request) => request?.body instanceof ReadableStream;

    const retryMiddleware$3 = (options) => (next, context) => async (args) => {
        let retryStrategy = await options.retryStrategy();
        const maxAttempts = await options.maxAttempts();
        if (isRetryStrategyV2$3(retryStrategy)) {
            retryStrategy = retryStrategy;
            let retryToken = await retryStrategy.acquireInitialRetryToken(context["partition_id"]);
            let lastError = new Error();
            let attempts = 0;
            let totalRetryDelay = 0;
            const { request } = args;
            const isRequest = HttpRequest$4.isInstance(request);
            if (isRequest) {
                request.headers[INVOCATION_ID_HEADER$3] = v4();
            }
            while (true) {
                try {
                    if (isRequest) {
                        request.headers[REQUEST_HEADER$3] = `attempt=${attempts + 1}; max=${maxAttempts}`;
                    }
                    const { response, output } = await next(args);
                    retryStrategy.recordSuccess(retryToken);
                    output.$metadata.attempts = attempts + 1;
                    output.$metadata.totalRetryDelay = totalRetryDelay;
                    return { response, output };
                }
                catch (e) {
                    const retryErrorInfo = getRetryErrorInfo$3(e);
                    lastError = asSdkError$3(e);
                    if (isRequest && isStreamingPayload$3(request)) {
                        (context.logger instanceof NoOpLogger$3 ? console : context.logger)?.warn("An error was encountered in a non-retryable streaming request.");
                        throw lastError;
                    }
                    try {
                        retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);
                    }
                    catch (refreshError) {
                        if (!lastError.$metadata) {
                            lastError.$metadata = {};
                        }
                        lastError.$metadata.attempts = attempts + 1;
                        lastError.$metadata.totalRetryDelay = totalRetryDelay;
                        throw lastError;
                    }
                    attempts = retryToken.getRetryCount();
                    const delay = retryToken.getRetryDelay();
                    totalRetryDelay += delay;
                    await new Promise((resolve) => setTimeout(resolve, delay));
                }
            }
        }
        else {
            retryStrategy = retryStrategy;
            if (retryStrategy?.mode)
                context.userAgent = [...(context.userAgent || []), ["cfg/retry-mode", retryStrategy.mode]];
            return retryStrategy.retry(next, args);
        }
    };
    const isRetryStrategyV2$3 = (retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== "undefined" &&
        typeof retryStrategy.refreshRetryTokenForRetry !== "undefined" &&
        typeof retryStrategy.recordSuccess !== "undefined";
    const getRetryErrorInfo$3 = (error) => {
        const errorInfo = {
            error,
            errorType: getRetryErrorType$3(error),
        };
        const retryAfterHint = getRetryAfterHint$3(error.$response);
        if (retryAfterHint) {
            errorInfo.retryAfterHint = retryAfterHint;
        }
        return errorInfo;
    };
    const getRetryErrorType$3 = (error) => {
        if (isThrottlingError$3(error))
            return "THROTTLING";
        if (isTransientError$3(error))
            return "TRANSIENT";
        if (isServerError$3(error))
            return "SERVER_ERROR";
        return "CLIENT_ERROR";
    };
    const retryMiddlewareOptions$3 = {
        name: "retryMiddleware",
        tags: ["RETRY"],
        step: "finalizeRequest",
        priority: "high",
        override: true,
    };
    const getRetryPlugin$3 = (options) => ({
        applyToStack: (clientStack) => {
            clientStack.add(retryMiddleware$3(options), retryMiddlewareOptions$3);
        },
    });
    const getRetryAfterHint$3 = (response) => {
        if (!HttpResponse$4.isInstance(response))
            return;
        const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
        if (!retryAfterHeaderName)
            return;
        const retryAfter = response.headers[retryAfterHeaderName];
        const retryAfterSeconds = Number(retryAfter);
        if (!Number.isNaN(retryAfterSeconds))
            return new Date(retryAfterSeconds * 1000);
        const retryAfterDate = new Date(retryAfter);
        return retryAfterDate;
    };

    const httpSigningMiddlewareOptions = {
        step: "finalizeRequest",
        tags: ["HTTP_SIGNING"],
        name: "httpSigningMiddleware",
        aliases: ["apiKeyMiddleware", "tokenMiddleware", "awsAuthMiddleware"],
        override: true,
        relation: "after",
        toMiddleware: retryMiddlewareOptions$3.name,
    };
    const getHttpSigningPlugin = (config) => ({
        applyToStack: (clientStack) => {
            clientStack.addRelativeTo(httpSigningMiddleware(), httpSigningMiddlewareOptions);
        },
    });

    class DefaultIdentityProviderConfig {
        constructor(config) {
            this.authSchemes = new Map();
            for (const [key, value] of Object.entries(config)) {
                if (value !== undefined) {
                    this.authSchemes.set(key, value);
                }
            }
        }
        getIdentityProvider(schemeId) {
            return this.authSchemes.get(schemeId);
        }
    }

    class NoAuthSigner {
        async sign(httpRequest, identity, signingProperties) {
            return httpRequest;
        }
    }

    const createIsIdentityExpiredFunction = (expirationMs) => (identity) => doesIdentityRequireRefresh(identity) && identity.expiration.getTime() - Date.now() < expirationMs;
    const EXPIRATION_MS = 300000;
    const isIdentityExpired = createIsIdentityExpiredFunction(EXPIRATION_MS);
    const doesIdentityRequireRefresh = (identity) => identity.expiration !== undefined;
    const memoizeIdentityProvider = (provider, isExpired, requiresRefresh) => {
        if (provider === undefined) {
            return undefined;
        }
        const normalizedProvider = typeof provider !== "function" ? async () => Promise.resolve(provider) : provider;
        let resolved;
        let pending;
        let hasResult;
        let isConstant = false;
        const coalesceProvider = async (options) => {
            if (!pending) {
                pending = normalizedProvider(options);
            }
            try {
                resolved = await pending;
                hasResult = true;
                isConstant = false;
            }
            finally {
                pending = undefined;
            }
            return resolved;
        };
        if (isExpired === undefined) {
            return async (options) => {
                if (!hasResult || options?.forceRefresh) {
                    resolved = await coalesceProvider(options);
                }
                return resolved;
            };
        }
        return async (options) => {
            if (!hasResult || options?.forceRefresh) {
                resolved = await coalesceProvider(options);
            }
            if (isConstant) {
                return resolved;
            }
            if (!requiresRefresh(resolved)) {
                isConstant = true;
                return resolved;
            }
            if (isExpired(resolved)) {
                await coalesceProvider(options);
                return resolved;
            }
            return resolved;
        };
    };

    const normalizeProvider$4 = (input) => {
        if (typeof input === "function")
            return input;
        const promisified = Promise.resolve(input);
        return () => promisified;
    };

    function requestBuilder(input, context) {
        return new RequestBuilder(input, context);
    }
    class RequestBuilder {
        constructor(input, context) {
            this.input = input;
            this.context = context;
            this.query = {};
            this.method = "";
            this.headers = {};
            this.path = "";
            this.body = null;
            this.hostname = "";
            this.resolvePathStack = [];
        }
        async build() {
            const { hostname, protocol = "https", port, path: basePath } = await this.context.endpoint();
            this.path = basePath;
            for (const resolvePath of this.resolvePathStack) {
                resolvePath(this.path);
            }
            return new HttpRequest$4({
                protocol,
                hostname: this.hostname || hostname,
                port,
                method: this.method,
                path: this.path,
                query: this.query,
                body: this.body,
                headers: this.headers,
            });
        }
        hn(hostname) {
            this.hostname = hostname;
            return this;
        }
        bp(uriLabel) {
            this.resolvePathStack.push((basePath) => {
                this.path = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + uriLabel;
            });
            return this;
        }
        p(memberName, labelValueProvider, uriLabel, isGreedyLabel) {
            this.resolvePathStack.push((path) => {
                this.path = resolvedPath$2(path, this.input, memberName, labelValueProvider, uriLabel, isGreedyLabel);
            });
            return this;
        }
        h(headers) {
            this.headers = headers;
            return this;
        }
        q(query) {
            this.query = query;
            return this;
        }
        b(body) {
            this.body = body;
            return this;
        }
        m(method) {
            this.method = method;
            return this;
        }
    }

    const makePagedClientRequest = async (CommandCtor, client, input, ...args) => {
        return await client.send(new CommandCtor(input), ...args);
    };
    function createPaginator(ClientCtor, CommandCtor, inputTokenName, outputTokenName, pageSizeTokenName) {
        return async function* paginateOperation(config, input, ...additionalArguments) {
            let token = config.startingToken || undefined;
            let hasNext = true;
            let page;
            while (hasNext) {
                input[inputTokenName] = token;
                {
                    input[pageSizeTokenName] = input[pageSizeTokenName] ?? config.pageSize;
                }
                if (config.client instanceof ClientCtor) {
                    page = await makePagedClientRequest(CommandCtor, config.client, input, ...additionalArguments);
                }
                else {
                    throw new Error(`Invalid client, expected instance of ${ClientCtor.name}`);
                }
                yield page;
                const prevToken = token;
                token = get(page, outputTokenName);
                hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
            }
            return undefined;
        };
    }
    const get = (fromObject, path) => {
        let cursor = fromObject;
        const pathComponents = path.split(".");
        for (const step of pathComponents) {
            if (!cursor || typeof cursor !== "object") {
                return undefined;
            }
            cursor = cursor[step];
        }
        return cursor;
    };

    const CONTENT_LENGTH_HEADER$3 = "content-length";
    function contentLengthMiddleware$3(bodyLengthChecker) {
        return (next) => async (args) => {
            const request = args.request;
            if (HttpRequest$4.isInstance(request)) {
                const { body, headers } = request;
                if (body &&
                    Object.keys(headers)
                        .map((str) => str.toLowerCase())
                        .indexOf(CONTENT_LENGTH_HEADER$3) === -1) {
                    try {
                        const length = bodyLengthChecker(body);
                        request.headers = {
                            ...request.headers,
                            [CONTENT_LENGTH_HEADER$3]: String(length),
                        };
                    }
                    catch (error) {
                    }
                }
            }
            return next({
                ...args,
                request,
            });
        };
    }
    const contentLengthMiddlewareOptions$3 = {
        step: "build",
        tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
        name: "contentLengthMiddleware",
        override: true,
    };
    const getContentLengthPlugin$3 = (options) => ({
        applyToStack: (clientStack) => {
            clientStack.add(contentLengthMiddleware$3(options.bodyLengthChecker), contentLengthMiddlewareOptions$3);
        },
    });

    const getDateHeader$1 = (response) => HttpResponse$4.isInstance(response) ? response.headers?.date ?? response.headers?.Date : undefined;

    const getSkewCorrectedDate$1 = (systemClockOffset) => new Date(Date.now() + systemClockOffset);

    const isClockSkewed$1 = (clockTime, systemClockOffset) => Math.abs(getSkewCorrectedDate$1(systemClockOffset).getTime() - clockTime) >= 300000;

    const getUpdatedSystemClockOffset$1 = (clockTime, currentSystemClockOffset) => {
        const clockTimeInMs = Date.parse(clockTime);
        if (isClockSkewed$1(clockTimeInMs, currentSystemClockOffset)) {
            return clockTimeInMs - Date.now();
        }
        return currentSystemClockOffset;
    };

    const throwSigningPropertyError = (name, property) => {
        if (!property) {
            throw new Error(`Property \`${name}\` is not resolved for AWS SDK SigV4Auth`);
        }
        return property;
    };
    const validateSigningProperties = async (signingProperties) => {
        const context = throwSigningPropertyError("context", signingProperties.context);
        const config = throwSigningPropertyError("config", signingProperties.config);
        const authScheme = context.endpointV2?.properties?.authSchemes?.[0];
        const signerFunction = throwSigningPropertyError("signer", config.signer);
        const signer = await signerFunction(authScheme);
        const signingRegion = signingProperties?.signingRegion;
        const signingName = signingProperties?.signingName;
        return {
            config,
            signer,
            signingRegion,
            signingName,
        };
    };
    class AwsSdkSigV4Signer {
        async sign(httpRequest, identity, signingProperties) {
            if (!HttpRequest$4.isInstance(httpRequest)) {
                throw new Error("The request is not an instance of `HttpRequest` and cannot be signed");
            }
            const { config, signer, signingRegion, signingName } = await validateSigningProperties(signingProperties);
            const signedRequest = await signer.sign(httpRequest, {
                signingDate: getSkewCorrectedDate$1(config.systemClockOffset),
                signingRegion: signingRegion,
                signingService: signingName,
            });
            return signedRequest;
        }
        errorHandler(signingProperties) {
            return (error) => {
                const serverTime = error.ServerTime ?? getDateHeader$1(error.$response);
                if (serverTime) {
                    const config = throwSigningPropertyError("config", signingProperties.config);
                    const initialSystemClockOffset = config.systemClockOffset;
                    config.systemClockOffset = getUpdatedSystemClockOffset$1(serverTime, config.systemClockOffset);
                    const clockSkewCorrected = config.systemClockOffset !== initialSystemClockOffset;
                    if (clockSkewCorrected && error.$metadata) {
                        error.$metadata.clockSkewCorrected = true;
                    }
                }
                throw error;
            };
        }
        successHandler(httpResponse, signingProperties) {
            const dateHeader = getDateHeader$1(httpResponse);
            if (dateHeader) {
                const config = throwSigningPropertyError("config", signingProperties.config);
                config.systemClockOffset = getUpdatedSystemClockOffset$1(dateHeader, config.systemClockOffset);
            }
        }
    }

    const ALGORITHM_QUERY_PARAM$1 = "X-Amz-Algorithm";
    const CREDENTIAL_QUERY_PARAM$1 = "X-Amz-Credential";
    const AMZ_DATE_QUERY_PARAM$1 = "X-Amz-Date";
    const SIGNED_HEADERS_QUERY_PARAM$1 = "X-Amz-SignedHeaders";
    const EXPIRES_QUERY_PARAM$1 = "X-Amz-Expires";
    const SIGNATURE_QUERY_PARAM$1 = "X-Amz-Signature";
    const TOKEN_QUERY_PARAM$1 = "X-Amz-Security-Token";
    const AUTH_HEADER$1 = "authorization";
    const AMZ_DATE_HEADER$1 = AMZ_DATE_QUERY_PARAM$1.toLowerCase();
    const DATE_HEADER$1 = "date";
    const GENERATED_HEADERS$1 = [AUTH_HEADER$1, AMZ_DATE_HEADER$1, DATE_HEADER$1];
    const SIGNATURE_HEADER$1 = SIGNATURE_QUERY_PARAM$1.toLowerCase();
    const SHA256_HEADER$1 = "x-amz-content-sha256";
    const TOKEN_HEADER$1 = TOKEN_QUERY_PARAM$1.toLowerCase();
    const ALWAYS_UNSIGNABLE_HEADERS$1 = {
        authorization: true,
        "cache-control": true,
        connection: true,
        expect: true,
        from: true,
        "keep-alive": true,
        "max-forwards": true,
        pragma: true,
        referer: true,
        te: true,
        trailer: true,
        "transfer-encoding": true,
        upgrade: true,
        "user-agent": true,
        "x-amzn-trace-id": true,
    };
    const PROXY_HEADER_PATTERN$1 = /^proxy-/;
    const SEC_HEADER_PATTERN$1 = /^sec-/;
    const ALGORITHM_IDENTIFIER$1 = "AWS4-HMAC-SHA256";
    const EVENT_ALGORITHM_IDENTIFIER$1 = "AWS4-HMAC-SHA256-PAYLOAD";
    const UNSIGNED_PAYLOAD$1 = "UNSIGNED-PAYLOAD";
    const MAX_CACHE_SIZE$1 = 50;
    const KEY_TYPE_IDENTIFIER$1 = "aws4_request";
    const MAX_PRESIGNED_TTL$1 = 60 * 60 * 24 * 7;

    const signingKeyCache$1 = {};
    const cacheQueue$1 = [];
    const createScope$1 = (shortDate, region, service) => `${shortDate}/${region}/${service}/${KEY_TYPE_IDENTIFIER$1}`;
    const getSigningKey$1 = async (sha256Constructor, credentials, shortDate, region, service) => {
        const credsHash = await hmac$1(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId);
        const cacheKey = `${shortDate}:${region}:${service}:${toHex$1(credsHash)}:${credentials.sessionToken}`;
        if (cacheKey in signingKeyCache$1) {
            return signingKeyCache$1[cacheKey];
        }
        cacheQueue$1.push(cacheKey);
        while (cacheQueue$1.length > MAX_CACHE_SIZE$1) {
            delete signingKeyCache$1[cacheQueue$1.shift()];
        }
        let key = `AWS4${credentials.secretAccessKey}`;
        for (const signable of [shortDate, region, service, KEY_TYPE_IDENTIFIER$1]) {
            key = await hmac$1(sha256Constructor, key, signable);
        }
        return (signingKeyCache$1[cacheKey] = key);
    };
    const hmac$1 = (ctor, secret, data) => {
        const hash = new ctor(secret);
        hash.update(toUint8Array$1(data));
        return hash.digest();
    };

    const getCanonicalHeaders$1 = ({ headers }, unsignableHeaders, signableHeaders) => {
        const canonical = {};
        for (const headerName of Object.keys(headers).sort()) {
            if (headers[headerName] == undefined) {
                continue;
            }
            const canonicalHeaderName = headerName.toLowerCase();
            if (canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS$1 ||
                unsignableHeaders?.has(canonicalHeaderName) ||
                PROXY_HEADER_PATTERN$1.test(canonicalHeaderName) ||
                SEC_HEADER_PATTERN$1.test(canonicalHeaderName)) {
                if (!signableHeaders || (signableHeaders && !signableHeaders.has(canonicalHeaderName))) {
                    continue;
                }
            }
            canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\s+/g, " ");
        }
        return canonical;
    };

    const getCanonicalQuery$1 = ({ query = {} }) => {
        const keys = [];
        const serialized = {};
        for (const key of Object.keys(query).sort()) {
            if (key.toLowerCase() === SIGNATURE_HEADER$1) {
                continue;
            }
            keys.push(key);
            const value = query[key];
            if (typeof value === "string") {
                serialized[key] = `${escapeUri$4(key)}=${escapeUri$4(value)}`;
            }
            else if (Array.isArray(value)) {
                serialized[key] = value
                    .slice(0)
                    .reduce((encoded, value) => encoded.concat([`${escapeUri$4(key)}=${escapeUri$4(value)}`]), [])
                    .sort()
                    .join("&");
            }
        }
        return keys
            .map((key) => serialized[key])
            .filter((serialized) => serialized)
            .join("&");
    };

    const isArrayBuffer$1 = (arg) => (typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer) ||
        Object.prototype.toString.call(arg) === "[object ArrayBuffer]";

    const getPayloadHash$1 = async ({ headers, body }, hashConstructor) => {
        for (const headerName of Object.keys(headers)) {
            if (headerName.toLowerCase() === SHA256_HEADER$1) {
                return headers[headerName];
            }
        }
        if (body == undefined) {
            return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
        }
        else if (typeof body === "string" || ArrayBuffer.isView(body) || isArrayBuffer$1(body)) {
            const hashCtor = new hashConstructor();
            hashCtor.update(toUint8Array$1(body));
            return toHex$1(await hashCtor.digest());
        }
        return UNSIGNED_PAYLOAD$1;
    };

    let HeaderFormatter$1 = class HeaderFormatter {
        format(headers) {
            const chunks = [];
            for (const headerName of Object.keys(headers)) {
                const bytes = fromUtf8$9(headerName);
                chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
            }
            const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
            let position = 0;
            for (const chunk of chunks) {
                out.set(chunk, position);
                position += chunk.byteLength;
            }
            return out;
        }
        formatHeaderValue(header) {
            switch (header.type) {
                case "boolean":
                    return Uint8Array.from([header.value ? 0 : 1]);
                case "byte":
                    return Uint8Array.from([2, header.value]);
                case "short":
                    const shortView = new DataView(new ArrayBuffer(3));
                    shortView.setUint8(0, 3);
                    shortView.setInt16(1, header.value, false);
                    return new Uint8Array(shortView.buffer);
                case "integer":
                    const intView = new DataView(new ArrayBuffer(5));
                    intView.setUint8(0, 4);
                    intView.setInt32(1, header.value, false);
                    return new Uint8Array(intView.buffer);
                case "long":
                    const longBytes = new Uint8Array(9);
                    longBytes[0] = 5;
                    longBytes.set(header.value.bytes, 1);
                    return longBytes;
                case "binary":
                    const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
                    binView.setUint8(0, 6);
                    binView.setUint16(1, header.value.byteLength, false);
                    const binBytes = new Uint8Array(binView.buffer);
                    binBytes.set(header.value, 3);
                    return binBytes;
                case "string":
                    const utf8Bytes = fromUtf8$9(header.value);
                    const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
                    strView.setUint8(0, 7);
                    strView.setUint16(1, utf8Bytes.byteLength, false);
                    const strBytes = new Uint8Array(strView.buffer);
                    strBytes.set(utf8Bytes, 3);
                    return strBytes;
                case "timestamp":
                    const tsBytes = new Uint8Array(9);
                    tsBytes[0] = 8;
                    tsBytes.set(Int64$1.fromNumber(header.value.valueOf()).bytes, 1);
                    return tsBytes;
                case "uuid":
                    if (!UUID_PATTERN$1.test(header.value)) {
                        throw new Error(`Invalid UUID received: ${header.value}`);
                    }
                    const uuidBytes = new Uint8Array(17);
                    uuidBytes[0] = 9;
                    uuidBytes.set(fromHex$1(header.value.replace(/\-/g, "")), 1);
                    return uuidBytes;
            }
        }
    };
    var HEADER_VALUE_TYPE$1;
    (function (HEADER_VALUE_TYPE) {
        HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["boolTrue"] = 0] = "boolTrue";
        HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["boolFalse"] = 1] = "boolFalse";
        HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["byte"] = 2] = "byte";
        HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["short"] = 3] = "short";
        HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["integer"] = 4] = "integer";
        HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["long"] = 5] = "long";
        HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["byteArray"] = 6] = "byteArray";
        HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["string"] = 7] = "string";
        HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["timestamp"] = 8] = "timestamp";
        HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["uuid"] = 9] = "uuid";
    })(HEADER_VALUE_TYPE$1 || (HEADER_VALUE_TYPE$1 = {}));
    const UUID_PATTERN$1 = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
    let Int64$1 = class Int64 {
        constructor(bytes) {
            this.bytes = bytes;
            if (bytes.byteLength !== 8) {
                throw new Error("Int64 buffers must be exactly 8 bytes");
            }
        }
        static fromNumber(number) {
            if (number > 9223372036854776000 || number < -9223372036854776000) {
                throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
            }
            const bytes = new Uint8Array(8);
            for (let i = 7, remaining = Math.abs(Math.round(number)); i > -1 && remaining > 0; i--, remaining /= 256) {
                bytes[i] = remaining;
            }
            if (number < 0) {
                negate$1(bytes);
            }
            return new Int64(bytes);
        }
        valueOf() {
            const bytes = this.bytes.slice(0);
            const negative = bytes[0] & 0b10000000;
            if (negative) {
                negate$1(bytes);
            }
            return parseInt(toHex$1(bytes), 16) * (negative ? -1 : 1);
        }
        toString() {
            return String(this.valueOf());
        }
    };
    function negate$1(bytes) {
        for (let i = 0; i < 8; i++) {
            bytes[i] ^= 0xff;
        }
        for (let i = 7; i > -1; i--) {
            bytes[i]++;
            if (bytes[i] !== 0)
                break;
        }
    }

    const hasHeader$1 = (soughtHeader, headers) => {
        soughtHeader = soughtHeader.toLowerCase();
        for (const headerName of Object.keys(headers)) {
            if (soughtHeader === headerName.toLowerCase()) {
                return true;
            }
        }
        return false;
    };

    const moveHeadersToQuery$1 = (request, options = {}) => {
        const { headers, query = {} } = HttpRequest$4.clone(request);
        for (const name of Object.keys(headers)) {
            const lname = name.toLowerCase();
            if (lname.slice(0, 6) === "x-amz-" && !options.unhoistableHeaders?.has(lname)) {
                query[name] = headers[name];
                delete headers[name];
            }
        }
        return {
            ...request,
            headers,
            query,
        };
    };

    const prepareRequest$1 = (request) => {
        request = HttpRequest$4.clone(request);
        for (const headerName of Object.keys(request.headers)) {
            if (GENERATED_HEADERS$1.indexOf(headerName.toLowerCase()) > -1) {
                delete request.headers[headerName];
            }
        }
        return request;
    };

    const iso8601$1 = (time) => toDate$1(time)
        .toISOString()
        .replace(/\.\d{3}Z$/, "Z");
    const toDate$1 = (time) => {
        if (typeof time === "number") {
            return new Date(time * 1000);
        }
        if (typeof time === "string") {
            if (Number(time)) {
                return new Date(Number(time) * 1000);
            }
            return new Date(time);
        }
        return time;
    };

    let SignatureV4$1 = class SignatureV4 {
        constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true, }) {
            this.headerFormatter = new HeaderFormatter$1();
            this.service = service;
            this.sha256 = sha256;
            this.uriEscapePath = uriEscapePath;
            this.applyChecksum = typeof applyChecksum === "boolean" ? applyChecksum : true;
            this.regionProvider = normalizeProvider$5(region);
            this.credentialProvider = normalizeProvider$5(credentials);
        }
        async presign(originalRequest, options = {}) {
            const { signingDate = new Date(), expiresIn = 3600, unsignableHeaders, unhoistableHeaders, signableHeaders, signingRegion, signingService, } = options;
            const credentials = await this.credentialProvider();
            this.validateResolvedCredentials(credentials);
            const region = signingRegion ?? (await this.regionProvider());
            const { longDate, shortDate } = formatDate$1(signingDate);
            if (expiresIn > MAX_PRESIGNED_TTL$1) {
                return Promise.reject("Signature version 4 presigned URLs" + " must have an expiration date less than one week in" + " the future");
            }
            const scope = createScope$1(shortDate, region, signingService ?? this.service);
            const request = moveHeadersToQuery$1(prepareRequest$1(originalRequest), { unhoistableHeaders });
            if (credentials.sessionToken) {
                request.query[TOKEN_QUERY_PARAM$1] = credentials.sessionToken;
            }
            request.query[ALGORITHM_QUERY_PARAM$1] = ALGORITHM_IDENTIFIER$1;
            request.query[CREDENTIAL_QUERY_PARAM$1] = `${credentials.accessKeyId}/${scope}`;
            request.query[AMZ_DATE_QUERY_PARAM$1] = longDate;
            request.query[EXPIRES_QUERY_PARAM$1] = expiresIn.toString(10);
            const canonicalHeaders = getCanonicalHeaders$1(request, unsignableHeaders, signableHeaders);
            request.query[SIGNED_HEADERS_QUERY_PARAM$1] = getCanonicalHeaderList$1(canonicalHeaders);
            request.query[SIGNATURE_QUERY_PARAM$1] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await getPayloadHash$1(originalRequest, this.sha256)));
            return request;
        }
        async sign(toSign, options) {
            if (typeof toSign === "string") {
                return this.signString(toSign, options);
            }
            else if (toSign.headers && toSign.payload) {
                return this.signEvent(toSign, options);
            }
            else if (toSign.message) {
                return this.signMessage(toSign, options);
            }
            else {
                return this.signRequest(toSign, options);
            }
        }
        async signEvent({ headers, payload }, { signingDate = new Date(), priorSignature, signingRegion, signingService }) {
            const region = signingRegion ?? (await this.regionProvider());
            const { shortDate, longDate } = formatDate$1(signingDate);
            const scope = createScope$1(shortDate, region, signingService ?? this.service);
            const hashedPayload = await getPayloadHash$1({ headers: {}, body: payload }, this.sha256);
            const hash = new this.sha256();
            hash.update(headers);
            const hashedHeaders = toHex$1(await hash.digest());
            const stringToSign = [
                EVENT_ALGORITHM_IDENTIFIER$1,
                longDate,
                scope,
                priorSignature,
                hashedHeaders,
                hashedPayload,
            ].join("\n");
            return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });
        }
        async signMessage(signableMessage, { signingDate = new Date(), signingRegion, signingService }) {
            const promise = this.signEvent({
                headers: this.headerFormatter.format(signableMessage.message.headers),
                payload: signableMessage.message.body,
            }, {
                signingDate,
                signingRegion,
                signingService,
                priorSignature: signableMessage.priorSignature,
            });
            return promise.then((signature) => {
                return { message: signableMessage.message, signature };
            });
        }
        async signString(stringToSign, { signingDate = new Date(), signingRegion, signingService } = {}) {
            const credentials = await this.credentialProvider();
            this.validateResolvedCredentials(credentials);
            const region = signingRegion ?? (await this.regionProvider());
            const { shortDate } = formatDate$1(signingDate);
            const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));
            hash.update(toUint8Array$1(stringToSign));
            return toHex$1(await hash.digest());
        }
        async signRequest(requestToSign, { signingDate = new Date(), signableHeaders, unsignableHeaders, signingRegion, signingService, } = {}) {
            const credentials = await this.credentialProvider();
            this.validateResolvedCredentials(credentials);
            const region = signingRegion ?? (await this.regionProvider());
            const request = prepareRequest$1(requestToSign);
            const { longDate, shortDate } = formatDate$1(signingDate);
            const scope = createScope$1(shortDate, region, signingService ?? this.service);
            request.headers[AMZ_DATE_HEADER$1] = longDate;
            if (credentials.sessionToken) {
                request.headers[TOKEN_HEADER$1] = credentials.sessionToken;
            }
            const payloadHash = await getPayloadHash$1(request, this.sha256);
            if (!hasHeader$1(SHA256_HEADER$1, request.headers) && this.applyChecksum) {
                request.headers[SHA256_HEADER$1] = payloadHash;
            }
            const canonicalHeaders = getCanonicalHeaders$1(request, unsignableHeaders, signableHeaders);
            const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));
            request.headers[AUTH_HEADER$1] =
                `${ALGORITHM_IDENTIFIER$1} ` +
                    `Credential=${credentials.accessKeyId}/${scope}, ` +
                    `SignedHeaders=${getCanonicalHeaderList$1(canonicalHeaders)}, ` +
                    `Signature=${signature}`;
            return request;
        }
        createCanonicalRequest(request, canonicalHeaders, payloadHash) {
            const sortedHeaders = Object.keys(canonicalHeaders).sort();
            return `${request.method}
${this.getCanonicalPath(request)}
${getCanonicalQuery$1(request)}
${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join("\n")}

${sortedHeaders.join(";")}
${payloadHash}`;
        }
        async createStringToSign(longDate, credentialScope, canonicalRequest) {
            const hash = new this.sha256();
            hash.update(toUint8Array$1(canonicalRequest));
            const hashedRequest = await hash.digest();
            return `${ALGORITHM_IDENTIFIER$1}
${longDate}
${credentialScope}
${toHex$1(hashedRequest)}`;
        }
        getCanonicalPath({ path }) {
            if (this.uriEscapePath) {
                const normalizedPathSegments = [];
                for (const pathSegment of path.split("/")) {
                    if (pathSegment?.length === 0)
                        continue;
                    if (pathSegment === ".")
                        continue;
                    if (pathSegment === "..") {
                        normalizedPathSegments.pop();
                    }
                    else {
                        normalizedPathSegments.push(pathSegment);
                    }
                }
                const normalizedPath = `${path?.startsWith("/") ? "/" : ""}${normalizedPathSegments.join("/")}${normalizedPathSegments.length > 0 && path?.endsWith("/") ? "/" : ""}`;
                const doubleEncoded = escapeUri$4(normalizedPath);
                return doubleEncoded.replace(/%2F/g, "/");
            }
            return path;
        }
        async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {
            const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);
            const hash = new this.sha256(await keyPromise);
            hash.update(toUint8Array$1(stringToSign));
            return toHex$1(await hash.digest());
        }
        getSigningKey(credentials, region, shortDate, service) {
            return getSigningKey$1(this.sha256, credentials, shortDate, region, service || this.service);
        }
        validateResolvedCredentials(credentials) {
            if (typeof credentials !== "object" ||
                typeof credentials.accessKeyId !== "string" ||
                typeof credentials.secretAccessKey !== "string") {
                throw new Error("Resolved credential object is not valid");
            }
        }
    };
    const formatDate$1 = (now) => {
        const longDate = iso8601$1(now).replace(/[\-:]/g, "");
        return {
            longDate,
            shortDate: longDate.slice(0, 8),
        };
    };
    const getCanonicalHeaderList$1 = (headers) => Object.keys(headers).sort().join(";");

    const resolveAwsSdkSigV4Config = (config) => {
        let normalizedCreds;
        if (config.credentials) {
            normalizedCreds = memoizeIdentityProvider(config.credentials, isIdentityExpired, doesIdentityRequireRefresh);
        }
        if (!normalizedCreds) {
            if (config.credentialDefaultProvider) {
                normalizedCreds = normalizeProvider$4(config.credentialDefaultProvider(Object.assign({}, config, {
                    parentClientConfig: config,
                })));
            }
            else {
                normalizedCreds = async () => {
                    throw new Error("`credentials` is missing");
                };
            }
        }
        const { signingEscapePath = true, systemClockOffset = config.systemClockOffset || 0, sha256, } = config;
        let signer;
        if (config.signer) {
            signer = normalizeProvider$4(config.signer);
        }
        else if (config.regionInfoProvider) {
            signer = () => normalizeProvider$4(config.region)()
                .then(async (region) => [
                (await config.regionInfoProvider(region, {
                    useFipsEndpoint: await config.useFipsEndpoint(),
                    useDualstackEndpoint: await config.useDualstackEndpoint(),
                })) || {},
                region,
            ])
                .then(([regionInfo, region]) => {
                const { signingRegion, signingService } = regionInfo;
                config.signingRegion = config.signingRegion || signingRegion || region;
                config.signingName = config.signingName || signingService || config.serviceId;
                const params = {
                    ...config,
                    credentials: normalizedCreds,
                    region: config.signingRegion,
                    service: config.signingName,
                    sha256,
                    uriEscapePath: signingEscapePath,
                };
                const SignerCtor = config.signerConstructor || SignatureV4$1;
                return new SignerCtor(params);
            });
        }
        else {
            signer = async (authScheme) => {
                authScheme = Object.assign({}, {
                    name: "sigv4",
                    signingName: config.signingName || config.defaultSigningName,
                    signingRegion: await normalizeProvider$4(config.region)(),
                    properties: {},
                }, authScheme);
                const signingRegion = authScheme.signingRegion;
                const signingService = authScheme.signingName;
                config.signingRegion = config.signingRegion || signingRegion;
                config.signingName = config.signingName || signingService || config.serviceId;
                const params = {
                    ...config,
                    credentials: normalizedCreds,
                    region: config.signingRegion,
                    service: config.signingName,
                    sha256,
                    uriEscapePath: signingEscapePath,
                };
                const SignerCtor = config.signerConstructor || SignatureV4$1;
                return new SignerCtor(params);
            };
        }
        return {
            ...config,
            systemClockOffset,
            signingEscapePath,
            credentials: normalizedCreds,
            signer,
        };
    };

    const collectBodyString$3 = (streamBody, context) => collectBody$3(streamBody, context).then((body) => context.utf8Encoder(body));

    const parseJsonBody = (streamBody, context) => collectBodyString$3(streamBody, context).then((encoded) => {
        if (encoded.length) {
            try {
                return JSON.parse(encoded);
            }
            catch (e) {
                if (e?.name === "SyntaxError") {
                    Object.defineProperty(e, "$responseBodyText", {
                        value: encoded,
                    });
                }
                throw e;
            }
        }
        return {};
    });
    const parseJsonErrorBody = async (errorBody, context) => {
        const value = await parseJsonBody(errorBody, context);
        value.message = value.message ?? value.Message;
        return value;
    };
    const loadRestJsonErrorCode$3 = (output, data) => {
        const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
        const sanitizeErrorCode = (rawValue) => {
            let cleanValue = rawValue;
            if (typeof cleanValue === "number") {
                cleanValue = cleanValue.toString();
            }
            if (cleanValue.indexOf(",") >= 0) {
                cleanValue = cleanValue.split(",")[0];
            }
            if (cleanValue.indexOf(":") >= 0) {
                cleanValue = cleanValue.split(":")[0];
            }
            if (cleanValue.indexOf("#") >= 0) {
                cleanValue = cleanValue.split("#")[1];
            }
            return cleanValue;
        };
        const headerKey = findKey(output.headers, "x-amzn-errortype");
        if (headerKey !== undefined) {
            return sanitizeErrorCode(output.headers[headerKey]);
        }
        if (data.code !== undefined) {
            return sanitizeErrorCode(data.code);
        }
        if (data["__type"] !== undefined) {
            return sanitizeErrorCode(data["__type"]);
        }
    };

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getDefaultExportFromCjs (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function getAugmentedNamespace(n) {
      if (n.__esModule) return n;
      var f = n.default;
    	if (typeof f == "function") {
    		var a = function a () {
    			if (this instanceof a) {
            return Reflect.construct(f, arguments, this.constructor);
    			}
    			return f.apply(this, arguments);
    		};
    		a.prototype = f.prototype;
      } else a = {};
      Object.defineProperty(a, '__esModule', {value: true});
    	Object.keys(n).forEach(function (k) {
    		var d = Object.getOwnPropertyDescriptor(n, k);
    		Object.defineProperty(a, k, d.get ? d : {
    			enumerable: true,
    			get: function () {
    				return n[k];
    			}
    		});
    	});
    	return a;
    }

    var validator = {};

    var util = {};

    var hasRequiredUtil;

    function requireUtil () {
    	if (hasRequiredUtil) return util;
    	hasRequiredUtil = 1;
    	(function (exports) {

    		const nameStartChar = ':A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
    		const nameChar = nameStartChar + '\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040';
    		const nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*';
    		const regexName = new RegExp('^' + nameRegexp + '$');

    		const getAllMatches = function(string, regex) {
    		  const matches = [];
    		  let match = regex.exec(string);
    		  while (match) {
    		    const allmatches = [];
    		    allmatches.startIndex = regex.lastIndex - match[0].length;
    		    const len = match.length;
    		    for (let index = 0; index < len; index++) {
    		      allmatches.push(match[index]);
    		    }
    		    matches.push(allmatches);
    		    match = regex.exec(string);
    		  }
    		  return matches;
    		};

    		const isName = function(string) {
    		  const match = regexName.exec(string);
    		  return !(match === null || typeof match === 'undefined');
    		};

    		exports.isExist = function(v) {
    		  return typeof v !== 'undefined';
    		};

    		exports.isEmptyObject = function(obj) {
    		  return Object.keys(obj).length === 0;
    		};

    		/**
    		 * Copy all the properties of a into b.
    		 * @param {*} target
    		 * @param {*} a
    		 */
    		exports.merge = function(target, a, arrayMode) {
    		  if (a) {
    		    const keys = Object.keys(a); // will return an array of own properties
    		    const len = keys.length; //don't make it inline
    		    for (let i = 0; i < len; i++) {
    		      if (arrayMode === 'strict') {
    		        target[keys[i]] = [ a[keys[i]] ];
    		      } else {
    		        target[keys[i]] = a[keys[i]];
    		      }
    		    }
    		  }
    		};
    		/* exports.merge =function (b,a){
    		  return Object.assign(b,a);
    		} */

    		exports.getValue = function(v) {
    		  if (exports.isExist(v)) {
    		    return v;
    		  } else {
    		    return '';
    		  }
    		};

    		// const fakeCall = function(a) {return a;};
    		// const fakeCallNoReturn = function() {};

    		exports.isName = isName;
    		exports.getAllMatches = getAllMatches;
    		exports.nameRegexp = nameRegexp; 
    	} (util));
    	return util;
    }

    var hasRequiredValidator;

    function requireValidator () {
    	if (hasRequiredValidator) return validator;
    	hasRequiredValidator = 1;

    	const util = requireUtil();

    	const defaultOptions = {
    	  allowBooleanAttributes: false, //A tag can have attributes without any value
    	  unpairedTags: []
    	};

    	//const tagsPattern = new RegExp("<\\/?([\\w:\\-_\.]+)\\s*\/?>","g");
    	validator.validate = function (xmlData, options) {
    	  options = Object.assign({}, defaultOptions, options);

    	  //xmlData = xmlData.replace(/(\r\n|\n|\r)/gm,"");//make it single line
    	  //xmlData = xmlData.replace(/(^\s*<\?xml.*?\?>)/g,"");//Remove XML starting tag
    	  //xmlData = xmlData.replace(/(<!DOCTYPE[\s\w\"\.\/\-\:]+(\[.*\])*\s*>)/g,"");//Remove DOCTYPE
    	  const tags = [];
    	  let tagFound = false;

    	  //indicates that the root tag has been closed (aka. depth 0 has been reached)
    	  let reachedRoot = false;

    	  if (xmlData[0] === '\ufeff') {
    	    // check for byte order mark (BOM)
    	    xmlData = xmlData.substr(1);
    	  }
    	  
    	  for (let i = 0; i < xmlData.length; i++) {

    	    if (xmlData[i] === '<' && xmlData[i+1] === '?') {
    	      i+=2;
    	      i = readPI(xmlData,i);
    	      if (i.err) return i;
    	    }else if (xmlData[i] === '<') {
    	      //starting of tag
    	      //read until you reach to '>' avoiding any '>' in attribute value
    	      let tagStartPos = i;
    	      i++;
    	      
    	      if (xmlData[i] === '!') {
    	        i = readCommentAndCDATA(xmlData, i);
    	        continue;
    	      } else {
    	        let closingTag = false;
    	        if (xmlData[i] === '/') {
    	          //closing tag
    	          closingTag = true;
    	          i++;
    	        }
    	        //read tagname
    	        let tagName = '';
    	        for (; i < xmlData.length &&
    	          xmlData[i] !== '>' &&
    	          xmlData[i] !== ' ' &&
    	          xmlData[i] !== '\t' &&
    	          xmlData[i] !== '\n' &&
    	          xmlData[i] !== '\r'; i++
    	        ) {
    	          tagName += xmlData[i];
    	        }
    	        tagName = tagName.trim();
    	        //console.log(tagName);

    	        if (tagName[tagName.length - 1] === '/') {
    	          //self closing tag without attributes
    	          tagName = tagName.substring(0, tagName.length - 1);
    	          //continue;
    	          i--;
    	        }
    	        if (!validateTagName(tagName)) {
    	          let msg;
    	          if (tagName.trim().length === 0) {
    	            msg = "Invalid space after '<'.";
    	          } else {
    	            msg = "Tag '"+tagName+"' is an invalid name.";
    	          }
    	          return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));
    	        }

    	        const result = readAttributeStr(xmlData, i);
    	        if (result === false) {
    	          return getErrorObject('InvalidAttr', "Attributes for '"+tagName+"' have open quote.", getLineNumberForPosition(xmlData, i));
    	        }
    	        let attrStr = result.value;
    	        i = result.index;

    	        if (attrStr[attrStr.length - 1] === '/') {
    	          //self closing tag
    	          const attrStrStart = i - attrStr.length;
    	          attrStr = attrStr.substring(0, attrStr.length - 1);
    	          const isValid = validateAttributeString(attrStr, options);
    	          if (isValid === true) {
    	            tagFound = true;
    	            //continue; //text may presents after self closing tag
    	          } else {
    	            //the result from the nested function returns the position of the error within the attribute
    	            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
    	            //this gives us the absolute index in the entire xml, which we can use to find the line at last
    	            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
    	          }
    	        } else if (closingTag) {
    	          if (!result.tagClosed) {
    	            return getErrorObject('InvalidTag', "Closing tag '"+tagName+"' doesn't have proper closing.", getLineNumberForPosition(xmlData, i));
    	          } else if (attrStr.trim().length > 0) {
    	            return getErrorObject('InvalidTag', "Closing tag '"+tagName+"' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
    	          } else if (tags.length === 0) {
    	            return getErrorObject('InvalidTag', "Closing tag '"+tagName+"' has not been opened.", getLineNumberForPosition(xmlData, tagStartPos));
    	          } else {
    	            const otg = tags.pop();
    	            if (tagName !== otg.tagName) {
    	              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
    	              return getErrorObject('InvalidTag',
    	                "Expected closing tag '"+otg.tagName+"' (opened in line "+openPos.line+", col "+openPos.col+") instead of closing tag '"+tagName+"'.",
    	                getLineNumberForPosition(xmlData, tagStartPos));
    	            }

    	            //when there are no more tags, we reached the root level.
    	            if (tags.length == 0) {
    	              reachedRoot = true;
    	            }
    	          }
    	        } else {
    	          const isValid = validateAttributeString(attrStr, options);
    	          if (isValid !== true) {
    	            //the result from the nested function returns the position of the error within the attribute
    	            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
    	            //this gives us the absolute index in the entire xml, which we can use to find the line at last
    	            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));
    	          }

    	          //if the root level has been reached before ...
    	          if (reachedRoot === true) {
    	            return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));
    	          } else if(options.unpairedTags.indexOf(tagName) !== -1); else {
    	            tags.push({tagName, tagStartPos});
    	          }
    	          tagFound = true;
    	        }

    	        //skip tag text value
    	        //It may include comments and CDATA value
    	        for (i++; i < xmlData.length; i++) {
    	          if (xmlData[i] === '<') {
    	            if (xmlData[i + 1] === '!') {
    	              //comment or CADATA
    	              i++;
    	              i = readCommentAndCDATA(xmlData, i);
    	              continue;
    	            } else if (xmlData[i+1] === '?') {
    	              i = readPI(xmlData, ++i);
    	              if (i.err) return i;
    	            } else {
    	              break;
    	            }
    	          } else if (xmlData[i] === '&') {
    	            const afterAmp = validateAmpersand(xmlData, i);
    	            if (afterAmp == -1)
    	              return getErrorObject('InvalidChar', "char '&' is not expected.", getLineNumberForPosition(xmlData, i));
    	            i = afterAmp;
    	          }else {
    	            if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {
    	              return getErrorObject('InvalidXml', "Extra text at the end", getLineNumberForPosition(xmlData, i));
    	            }
    	          }
    	        } //end of reading tag text value
    	        if (xmlData[i] === '<') {
    	          i--;
    	        }
    	      }
    	    } else {
    	      if ( isWhiteSpace(xmlData[i])) {
    	        continue;
    	      }
    	      return getErrorObject('InvalidChar', "char '"+xmlData[i]+"' is not expected.", getLineNumberForPosition(xmlData, i));
    	    }
    	  }

    	  if (!tagFound) {
    	    return getErrorObject('InvalidXml', 'Start tag expected.', 1);
    	  }else if (tags.length == 1) {
    	      return getErrorObject('InvalidTag', "Unclosed tag '"+tags[0].tagName+"'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
    	  }else if (tags.length > 0) {
    	      return getErrorObject('InvalidXml', "Invalid '"+
    	          JSON.stringify(tags.map(t => t.tagName), null, 4).replace(/\r?\n/g, '')+
    	          "' found.", {line: 1, col: 1});
    	  }

    	  return true;
    	};

    	function isWhiteSpace(char){
    	  return char === ' ' || char === '\t' || char === '\n'  || char === '\r';
    	}
    	/**
    	 * Read Processing insstructions and skip
    	 * @param {*} xmlData
    	 * @param {*} i
    	 */
    	function readPI(xmlData, i) {
    	  const start = i;
    	  for (; i < xmlData.length; i++) {
    	    if (xmlData[i] == '?' || xmlData[i] == ' ') {
    	      //tagname
    	      const tagname = xmlData.substr(start, i - start);
    	      if (i > 5 && tagname === 'xml') {
    	        return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));
    	      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {
    	        //check if valid attribut string
    	        i++;
    	        break;
    	      } else {
    	        continue;
    	      }
    	    }
    	  }
    	  return i;
    	}

    	function readCommentAndCDATA(xmlData, i) {
    	  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {
    	    //comment
    	    for (i += 3; i < xmlData.length; i++) {
    	      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {
    	        i += 2;
    	        break;
    	      }
    	    }
    	  } else if (
    	    xmlData.length > i + 8 &&
    	    xmlData[i + 1] === 'D' &&
    	    xmlData[i + 2] === 'O' &&
    	    xmlData[i + 3] === 'C' &&
    	    xmlData[i + 4] === 'T' &&
    	    xmlData[i + 5] === 'Y' &&
    	    xmlData[i + 6] === 'P' &&
    	    xmlData[i + 7] === 'E'
    	  ) {
    	    let angleBracketsCount = 1;
    	    for (i += 8; i < xmlData.length; i++) {
    	      if (xmlData[i] === '<') {
    	        angleBracketsCount++;
    	      } else if (xmlData[i] === '>') {
    	        angleBracketsCount--;
    	        if (angleBracketsCount === 0) {
    	          break;
    	        }
    	      }
    	    }
    	  } else if (
    	    xmlData.length > i + 9 &&
    	    xmlData[i + 1] === '[' &&
    	    xmlData[i + 2] === 'C' &&
    	    xmlData[i + 3] === 'D' &&
    	    xmlData[i + 4] === 'A' &&
    	    xmlData[i + 5] === 'T' &&
    	    xmlData[i + 6] === 'A' &&
    	    xmlData[i + 7] === '['
    	  ) {
    	    for (i += 8; i < xmlData.length; i++) {
    	      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {
    	        i += 2;
    	        break;
    	      }
    	    }
    	  }

    	  return i;
    	}

    	const doubleQuote = '"';
    	const singleQuote = "'";

    	/**
    	 * Keep reading xmlData until '<' is found outside the attribute value.
    	 * @param {string} xmlData
    	 * @param {number} i
    	 */
    	function readAttributeStr(xmlData, i) {
    	  let attrStr = '';
    	  let startChar = '';
    	  let tagClosed = false;
    	  for (; i < xmlData.length; i++) {
    	    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
    	      if (startChar === '') {
    	        startChar = xmlData[i];
    	      } else if (startChar !== xmlData[i]) ; else {
    	        startChar = '';
    	      }
    	    } else if (xmlData[i] === '>') {
    	      if (startChar === '') {
    	        tagClosed = true;
    	        break;
    	      }
    	    }
    	    attrStr += xmlData[i];
    	  }
    	  if (startChar !== '') {
    	    return false;
    	  }

    	  return {
    	    value: attrStr,
    	    index: i,
    	    tagClosed: tagClosed
    	  };
    	}

    	/**
    	 * Select all the attributes whether valid or invalid.
    	 */
    	const validAttrStrRegxp = new RegExp('(\\s*)([^\\s=]+)(\\s*=)?(\\s*([\'"])(([\\s\\S])*?)\\5)?', 'g');

    	//attr, ="sd", a="amit's", a="sd"b="saf", ab  cd=""

    	function validateAttributeString(attrStr, options) {
    	  //console.log("start:"+attrStr+":end");

    	  //if(attrStr.trim().length === 0) return true; //empty string

    	  const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
    	  const attrNames = {};

    	  for (let i = 0; i < matches.length; i++) {
    	    if (matches[i][1].length === 0) {
    	      //nospace before attribute name: a="sd"b="saf"
    	      return getErrorObject('InvalidAttr', "Attribute '"+matches[i][2]+"' has no space in starting.", getPositionFromMatch(matches[i]))
    	    } else if (matches[i][3] !== undefined && matches[i][4] === undefined) {
    	      return getErrorObject('InvalidAttr', "Attribute '"+matches[i][2]+"' is without value.", getPositionFromMatch(matches[i]));
    	    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {
    	      //independent attribute: ab
    	      return getErrorObject('InvalidAttr', "boolean attribute '"+matches[i][2]+"' is not allowed.", getPositionFromMatch(matches[i]));
    	    }
    	    /* else if(matches[i][6] === undefined){//attribute without value: ab=
    	                    return { err: { code:"InvalidAttr",msg:"attribute " + matches[i][2] + " has no value assigned."}};
    	                } */
    	    const attrName = matches[i][2];
    	    if (!validateAttrName(attrName)) {
    	      return getErrorObject('InvalidAttr', "Attribute '"+attrName+"' is an invalid name.", getPositionFromMatch(matches[i]));
    	    }
    	    if (!attrNames.hasOwnProperty(attrName)) {
    	      //check for duplicate attribute.
    	      attrNames[attrName] = 1;
    	    } else {
    	      return getErrorObject('InvalidAttr', "Attribute '"+attrName+"' is repeated.", getPositionFromMatch(matches[i]));
    	    }
    	  }

    	  return true;
    	}

    	function validateNumberAmpersand(xmlData, i) {
    	  let re = /\d/;
    	  if (xmlData[i] === 'x') {
    	    i++;
    	    re = /[\da-fA-F]/;
    	  }
    	  for (; i < xmlData.length; i++) {
    	    if (xmlData[i] === ';')
    	      return i;
    	    if (!xmlData[i].match(re))
    	      break;
    	  }
    	  return -1;
    	}

    	function validateAmpersand(xmlData, i) {
    	  // https://www.w3.org/TR/xml/#dt-charref
    	  i++;
    	  if (xmlData[i] === ';')
    	    return -1;
    	  if (xmlData[i] === '#') {
    	    i++;
    	    return validateNumberAmpersand(xmlData, i);
    	  }
    	  let count = 0;
    	  for (; i < xmlData.length; i++, count++) {
    	    if (xmlData[i].match(/\w/) && count < 20)
    	      continue;
    	    if (xmlData[i] === ';')
    	      break;
    	    return -1;
    	  }
    	  return i;
    	}

    	function getErrorObject(code, message, lineNumber) {
    	  return {
    	    err: {
    	      code: code,
    	      msg: message,
    	      line: lineNumber.line || lineNumber,
    	      col: lineNumber.col,
    	    },
    	  };
    	}

    	function validateAttrName(attrName) {
    	  return util.isName(attrName);
    	}

    	// const startsWithXML = /^xml/i;

    	function validateTagName(tagname) {
    	  return util.isName(tagname) /* && !tagname.match(startsWithXML) */;
    	}

    	//this function returns the line number for the character at the given index
    	function getLineNumberForPosition(xmlData, index) {
    	  const lines = xmlData.substring(0, index).split(/\r?\n/);
    	  return {
    	    line: lines.length,

    	    // column number is last line's length + 1, because column numbering starts at 1:
    	    col: lines[lines.length - 1].length + 1
    	  };
    	}

    	//this function returns the position of the first character of match within attrStr
    	function getPositionFromMatch(match) {
    	  return match.startIndex + match[1].length;
    	}
    	return validator;
    }

    var OptionsBuilder = {};

    var hasRequiredOptionsBuilder;

    function requireOptionsBuilder () {
    	if (hasRequiredOptionsBuilder) return OptionsBuilder;
    	hasRequiredOptionsBuilder = 1;
    	const defaultOptions = {
    	    preserveOrder: false,
    	    attributeNamePrefix: '@_',
    	    attributesGroupName: false,
    	    textNodeName: '#text',
    	    ignoreAttributes: true,
    	    removeNSPrefix: false, // remove NS from tag name or attribute name if true
    	    allowBooleanAttributes: false, //a tag can have attributes without any value
    	    //ignoreRootElement : false,
    	    parseTagValue: true,
    	    parseAttributeValue: false,
    	    trimValues: true, //Trim string values of tag and attributes
    	    cdataPropName: false,
    	    numberParseOptions: {
    	      hex: true,
    	      leadingZeros: true,
    	      eNotation: true
    	    },
    	    tagValueProcessor: function(tagName, val) {
    	      return val;
    	    },
    	    attributeValueProcessor: function(attrName, val) {
    	      return val;
    	    },
    	    stopNodes: [], //nested tags will not be parsed even for errors
    	    alwaysCreateTextNode: false,
    	    isArray: () => false,
    	    commentPropName: false,
    	    unpairedTags: [],
    	    processEntities: true,
    	    htmlEntities: false,
    	    ignoreDeclaration: false,
    	    ignorePiTags: false,
    	    transformTagName: false,
    	    transformAttributeName: false,
    	    updateTag: function(tagName, jPath, attrs){
    	      return tagName
    	    },
    	    // skipEmptyListItem: false
    	};
    	   
    	const buildOptions = function(options) {
    	    return Object.assign({}, defaultOptions, options);
    	};

    	OptionsBuilder.buildOptions = buildOptions;
    	OptionsBuilder.defaultOptions = defaultOptions;
    	return OptionsBuilder;
    }

    var xmlNode;
    var hasRequiredXmlNode;

    function requireXmlNode () {
    	if (hasRequiredXmlNode) return xmlNode;
    	hasRequiredXmlNode = 1;

    	class XmlNode{
    	  constructor(tagname) {
    	    this.tagname = tagname;
    	    this.child = []; //nested tags, text, cdata, comments in order
    	    this[":@"] = {}; //attributes map
    	  }
    	  add(key,val){
    	    // this.child.push( {name : key, val: val, isCdata: isCdata });
    	    if(key === "__proto__") key = "#__proto__";
    	    this.child.push( {[key]: val });
    	  }
    	  addChild(node) {
    	    if(node.tagname === "__proto__") node.tagname = "#__proto__";
    	    if(node[":@"] && Object.keys(node[":@"]).length > 0){
    	      this.child.push( { [node.tagname]: node.child, [":@"]: node[":@"] });
    	    }else {
    	      this.child.push( { [node.tagname]: node.child });
    	    }
    	  };
    	}

    	xmlNode = XmlNode;
    	return xmlNode;
    }

    var DocTypeReader;
    var hasRequiredDocTypeReader;

    function requireDocTypeReader () {
    	if (hasRequiredDocTypeReader) return DocTypeReader;
    	hasRequiredDocTypeReader = 1;
    	const util = requireUtil();

    	//TODO: handle comments
    	function readDocType(xmlData, i){
    	    
    	    const entities = {};
    	    if( xmlData[i + 3] === 'O' &&
    	         xmlData[i + 4] === 'C' &&
    	         xmlData[i + 5] === 'T' &&
    	         xmlData[i + 6] === 'Y' &&
    	         xmlData[i + 7] === 'P' &&
    	         xmlData[i + 8] === 'E')
    	    {    
    	        i = i+9;
    	        let angleBracketsCount = 1;
    	        let hasBody = false, comment = false;
    	        let exp = "";
    	        for(;i<xmlData.length;i++){
    	            if (xmlData[i] === '<' && !comment) { //Determine the tag type
    	                if( hasBody && isEntity(xmlData, i)){
    	                    i += 7; 
    	                    [entityName, val,i] = readEntityExp(xmlData,i+1);
    	                    if(val.indexOf("&") === -1) //Parameter entities are not supported
    	                        entities[ validateEntityName(entityName) ] = {
    	                            regx : RegExp( `&${entityName};`,"g"),
    	                            val: val
    	                        };
    	                }
    	                else if( hasBody && isElement(xmlData, i))  i += 8;//Not supported
    	                else if( hasBody && isAttlist(xmlData, i))  i += 8;//Not supported
    	                else if( hasBody && isNotation(xmlData, i)) i += 9;//Not supported
    	                else if( isComment)                         comment = true;
    	                else                                        throw new Error("Invalid DOCTYPE");

    	                angleBracketsCount++;
    	                exp = "";
    	            } else if (xmlData[i] === '>') { //Read tag content
    	                if(comment){
    	                    if( xmlData[i - 1] === "-" && xmlData[i - 2] === "-"){
    	                        comment = false;
    	                        angleBracketsCount--;
    	                    }
    	                }else {
    	                    angleBracketsCount--;
    	                }
    	                if (angleBracketsCount === 0) {
    	                  break;
    	                }
    	            }else if( xmlData[i] === '['){
    	                hasBody = true;
    	            }else {
    	                exp += xmlData[i];
    	            }
    	        }
    	        if(angleBracketsCount !== 0){
    	            throw new Error(`Unclosed DOCTYPE`);
    	        }
    	    }else {
    	        throw new Error(`Invalid Tag instead of DOCTYPE`);
    	    }
    	    return {entities, i};
    	}

    	function readEntityExp(xmlData,i){
    	    //External entities are not supported
    	    //    <!ENTITY ext SYSTEM "http://normal-website.com" >

    	    //Parameter entities are not supported
    	    //    <!ENTITY entityname "&anotherElement;">

    	    //Internal entities are supported
    	    //    <!ENTITY entityname "replacement text">
    	    
    	    //read EntityName
    	    let entityName = "";
    	    for (; i < xmlData.length && (xmlData[i] !== "'" && xmlData[i] !== '"' ); i++) {
    	        // if(xmlData[i] === " ") continue;
    	        // else 
    	        entityName += xmlData[i];
    	    }
    	    entityName = entityName.trim();
    	    if(entityName.indexOf(" ") !== -1) throw new Error("External entites are not supported");

    	    //read Entity Value
    	    const startChar = xmlData[i++];
    	    let val = "";
    	    for (; i < xmlData.length && xmlData[i] !== startChar ; i++) {
    	        val += xmlData[i];
    	    }
    	    return [entityName, val, i];
    	}

    	function isComment(xmlData, i){
    	    if(xmlData[i+1] === '!' &&
    	    xmlData[i+2] === '-' &&
    	    xmlData[i+3] === '-') return true
    	    return false
    	}
    	function isEntity(xmlData, i){
    	    if(xmlData[i+1] === '!' &&
    	    xmlData[i+2] === 'E' &&
    	    xmlData[i+3] === 'N' &&
    	    xmlData[i+4] === 'T' &&
    	    xmlData[i+5] === 'I' &&
    	    xmlData[i+6] === 'T' &&
    	    xmlData[i+7] === 'Y') return true
    	    return false
    	}
    	function isElement(xmlData, i){
    	    if(xmlData[i+1] === '!' &&
    	    xmlData[i+2] === 'E' &&
    	    xmlData[i+3] === 'L' &&
    	    xmlData[i+4] === 'E' &&
    	    xmlData[i+5] === 'M' &&
    	    xmlData[i+6] === 'E' &&
    	    xmlData[i+7] === 'N' &&
    	    xmlData[i+8] === 'T') return true
    	    return false
    	}

    	function isAttlist(xmlData, i){
    	    if(xmlData[i+1] === '!' &&
    	    xmlData[i+2] === 'A' &&
    	    xmlData[i+3] === 'T' &&
    	    xmlData[i+4] === 'T' &&
    	    xmlData[i+5] === 'L' &&
    	    xmlData[i+6] === 'I' &&
    	    xmlData[i+7] === 'S' &&
    	    xmlData[i+8] === 'T') return true
    	    return false
    	}
    	function isNotation(xmlData, i){
    	    if(xmlData[i+1] === '!' &&
    	    xmlData[i+2] === 'N' &&
    	    xmlData[i+3] === 'O' &&
    	    xmlData[i+4] === 'T' &&
    	    xmlData[i+5] === 'A' &&
    	    xmlData[i+6] === 'T' &&
    	    xmlData[i+7] === 'I' &&
    	    xmlData[i+8] === 'O' &&
    	    xmlData[i+9] === 'N') return true
    	    return false
    	}

    	function validateEntityName(name){
    	    if (util.isName(name))
    		return name;
    	    else
    	        throw new Error(`Invalid entity name ${name}`);
    	}

    	DocTypeReader = readDocType;
    	return DocTypeReader;
    }

    var strnum;
    var hasRequiredStrnum;

    function requireStrnum () {
    	if (hasRequiredStrnum) return strnum;
    	hasRequiredStrnum = 1;
    	const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
    	const numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
    	// const octRegex = /0x[a-z0-9]+/;
    	// const binRegex = /0x[a-z0-9]+/;


    	//polyfill
    	if (!Number.parseInt && window.parseInt) {
    	    Number.parseInt = window.parseInt;
    	}
    	if (!Number.parseFloat && window.parseFloat) {
    	    Number.parseFloat = window.parseFloat;
    	}

    	  
    	const consider = {
    	    hex :  true,
    	    leadingZeros: true,
    	    decimalPoint: "\.",
    	    eNotation: true
    	    //skipLike: /regex/
    	};

    	function toNumber(str, options = {}){
    	    // const options = Object.assign({}, consider);
    	    // if(opt.leadingZeros === false){
    	    //     options.leadingZeros = false;
    	    // }else if(opt.hex === false){
    	    //     options.hex = false;
    	    // }

    	    options = Object.assign({}, consider, options );
    	    if(!str || typeof str !== "string" ) return str;
    	    
    	    let trimmedStr  = str.trim();
    	    // if(trimmedStr === "0.0") return 0;
    	    // else if(trimmedStr === "+0.0") return 0;
    	    // else if(trimmedStr === "-0.0") return -0;

    	    if(options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;
    	    else if (options.hex && hexRegex.test(trimmedStr)) {
    	        return Number.parseInt(trimmedStr, 16);
    	    // } else if (options.parseOct && octRegex.test(str)) {
    	    //     return Number.parseInt(val, 8);
    	    // }else if (options.parseBin && binRegex.test(str)) {
    	    //     return Number.parseInt(val, 2);
    	    }else {
    	        //separate negative sign, leading zeros, and rest number
    	        const match = numRegex.exec(trimmedStr);
    	        if(match){
    	            const sign = match[1];
    	            const leadingZeros = match[2];
    	            let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros
    	            //trim ending zeros for floating number
    	            
    	            const eNotation = match[4] || match[6];
    	            if(!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".") return str; //-0123
    	            else if(!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".") return str; //0123
    	            else {//no leading zeros or leading zeros are allowed
    	                const num = Number(trimmedStr);
    	                const numStr = "" + num;
    	                if(numStr.search(/[eE]/) !== -1){ //given number is long and parsed to eNotation
    	                    if(options.eNotation) return num;
    	                    else return str;
    	                }else if(eNotation){ //given number has enotation
    	                    if(options.eNotation) return num;
    	                    else return str;
    	                }else if(trimmedStr.indexOf(".") !== -1){ //floating number
    	                    // const decimalPart = match[5].substr(1);
    	                    // const intPart = trimmedStr.substr(0,trimmedStr.indexOf("."));

    	                    
    	                    // const p = numStr.indexOf(".");
    	                    // const givenIntPart = numStr.substr(0,p);
    	                    // const givenDecPart = numStr.substr(p+1);
    	                    if(numStr === "0" && (numTrimmedByZeros === "") ) return num; //0.0
    	                    else if(numStr === numTrimmedByZeros) return num; //0.456. 0.79000
    	                    else if( sign && numStr === "-"+numTrimmedByZeros) return num;
    	                    else return str;
    	                }
    	                
    	                if(leadingZeros){
    	                    // if(numTrimmedByZeros === numStr){
    	                    //     if(options.leadingZeros) return num;
    	                    //     else return str;
    	                    // }else return str;
    	                    if(numTrimmedByZeros === numStr) return num;
    	                    else if(sign+numTrimmedByZeros === numStr) return num;
    	                    else return str;
    	                }

    	                if(trimmedStr === numStr) return num;
    	                else if(trimmedStr === sign+numStr) return num;
    	                // else{
    	                //     //number with +/- sign
    	                //     trimmedStr.test(/[-+][0-9]);

    	                // }
    	                return str;
    	            }
    	            // else if(!eNotation && trimmedStr && trimmedStr !== Number(trimmedStr) ) return str;
    	            
    	        }else { //non-numeric string
    	            return str;
    	        }
    	    }
    	}

    	/**
    	 * 
    	 * @param {string} numStr without leading zeros
    	 * @returns 
    	 */
    	function trimZeros(numStr){
    	    if(numStr && numStr.indexOf(".") !== -1){//float
    	        numStr = numStr.replace(/0+$/, ""); //remove ending zeros
    	        if(numStr === ".")  numStr = "0";
    	        else if(numStr[0] === ".")  numStr = "0"+numStr;
    	        else if(numStr[numStr.length-1] === ".")  numStr = numStr.substr(0,numStr.length-1);
    	        return numStr;
    	    }
    	    return numStr;
    	}
    	strnum = toNumber;
    	return strnum;
    }

    var OrderedObjParser_1;
    var hasRequiredOrderedObjParser;

    function requireOrderedObjParser () {
    	if (hasRequiredOrderedObjParser) return OrderedObjParser_1;
    	hasRequiredOrderedObjParser = 1;
    	///@ts-check

    	const util = requireUtil();
    	const xmlNode = requireXmlNode();
    	const readDocType = requireDocTypeReader();
    	const toNumber = requireStrnum();

    	// const regx =
    	//   '<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)'
    	//   .replace(/NAME/g, util.nameRegexp);

    	//const tagsRegx = new RegExp("<(\\/?[\\w:\\-\._]+)([^>]*)>(\\s*"+cdataRegx+")*([^<]+)?","g");
    	//const tagsRegx = new RegExp("<(\\/?)((\\w*:)?([\\w:\\-\._]+))([^>]*)>([^<]*)("+cdataRegx+"([^<]*))*([^<]+)?","g");

    	class OrderedObjParser{
    	  constructor(options){
    	    this.options = options;
    	    this.currentNode = null;
    	    this.tagsNodeStack = [];
    	    this.docTypeEntities = {};
    	    this.lastEntities = {
    	      "apos" : { regex: /&(apos|#39|#x27);/g, val : "'"},
    	      "gt" : { regex: /&(gt|#62|#x3E);/g, val : ">"},
    	      "lt" : { regex: /&(lt|#60|#x3C);/g, val : "<"},
    	      "quot" : { regex: /&(quot|#34|#x22);/g, val : "\""},
    	    };
    	    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val : "&"};
    	    this.htmlEntities = {
    	      "space": { regex: /&(nbsp|#160);/g, val: " " },
    	      // "lt" : { regex: /&(lt|#60);/g, val: "<" },
    	      // "gt" : { regex: /&(gt|#62);/g, val: ">" },
    	      // "amp" : { regex: /&(amp|#38);/g, val: "&" },
    	      // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
    	      // "apos" : { regex: /&(apos|#39);/g, val: "'" },
    	      "cent" : { regex: /&(cent|#162);/g, val: "" },
    	      "pound" : { regex: /&(pound|#163);/g, val: "" },
    	      "yen" : { regex: /&(yen|#165);/g, val: "" },
    	      "euro" : { regex: /&(euro|#8364);/g, val: "" },
    	      "copyright" : { regex: /&(copy|#169);/g, val: "" },
    	      "reg" : { regex: /&(reg|#174);/g, val: "" },
    	      "inr" : { regex: /&(inr|#8377);/g, val: "" },
    	      "num_dec": { regex: /&#([0-9]{1,7});/g, val : (_, str) => String.fromCharCode(Number.parseInt(str, 10)) },
    	      "num_hex": { regex: /&#x([0-9a-fA-F]{1,6});/g, val : (_, str) => String.fromCharCode(Number.parseInt(str, 16)) },
    	    };
    	    this.addExternalEntities = addExternalEntities;
    	    this.parseXml = parseXml;
    	    this.parseTextData = parseTextData;
    	    this.resolveNameSpace = resolveNameSpace;
    	    this.buildAttributesMap = buildAttributesMap;
    	    this.isItStopNode = isItStopNode;
    	    this.replaceEntitiesValue = replaceEntitiesValue;
    	    this.readStopNodeData = readStopNodeData;
    	    this.saveTextToParentTag = saveTextToParentTag;
    	    this.addChild = addChild;
    	  }

    	}

    	function addExternalEntities(externalEntities){
    	  const entKeys = Object.keys(externalEntities);
    	  for (let i = 0; i < entKeys.length; i++) {
    	    const ent = entKeys[i];
    	    this.lastEntities[ent] = {
    	       regex: new RegExp("&"+ent+";","g"),
    	       val : externalEntities[ent]
    	    };
    	  }
    	}

    	/**
    	 * @param {string} val
    	 * @param {string} tagName
    	 * @param {string} jPath
    	 * @param {boolean} dontTrim
    	 * @param {boolean} hasAttributes
    	 * @param {boolean} isLeafNode
    	 * @param {boolean} escapeEntities
    	 */
    	function parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
    	  if (val !== undefined) {
    	    if (this.options.trimValues && !dontTrim) {
    	      val = val.trim();
    	    }
    	    if(val.length > 0){
    	      if(!escapeEntities) val = this.replaceEntitiesValue(val);
    	      
    	      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);
    	      if(newval === null || newval === undefined){
    	        //don't parse
    	        return val;
    	      }else if(typeof newval !== typeof val || newval !== val){
    	        //overwrite
    	        return newval;
    	      }else if(this.options.trimValues){
    	        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
    	      }else {
    	        const trimmedVal = val.trim();
    	        if(trimmedVal === val){
    	          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
    	        }else {
    	          return val;
    	        }
    	      }
    	    }
    	  }
    	}

    	function resolveNameSpace(tagname) {
    	  if (this.options.removeNSPrefix) {
    	    const tags = tagname.split(':');
    	    const prefix = tagname.charAt(0) === '/' ? '/' : '';
    	    if (tags[0] === 'xmlns') {
    	      return '';
    	    }
    	    if (tags.length === 2) {
    	      tagname = prefix + tags[1];
    	    }
    	  }
    	  return tagname;
    	}

    	//TODO: change regex to capture NS
    	//const attrsRegx = new RegExp("([\\w\\-\\.\\:]+)\\s*=\\s*(['\"])((.|\n)*?)\\2","gm");
    	const attrsRegx = new RegExp('([^\\s=]+)\\s*(=\\s*([\'"])([\\s\\S]*?)\\3)?', 'gm');

    	function buildAttributesMap(attrStr, jPath, tagName) {
    	  if (!this.options.ignoreAttributes && typeof attrStr === 'string') {
    	    // attrStr = attrStr.replace(/\r?\n/g, ' ');
    	    //attrStr = attrStr || attrStr.trim();

    	    const matches = util.getAllMatches(attrStr, attrsRegx);
    	    const len = matches.length; //don't make it inline
    	    const attrs = {};
    	    for (let i = 0; i < len; i++) {
    	      const attrName = this.resolveNameSpace(matches[i][1]);
    	      let oldVal = matches[i][4];
    	      let aName = this.options.attributeNamePrefix + attrName;
    	      if (attrName.length) {
    	        if (this.options.transformAttributeName) {
    	          aName = this.options.transformAttributeName(aName);
    	        }
    	        if(aName === "__proto__") aName  = "#__proto__";
    	        if (oldVal !== undefined) {
    	          if (this.options.trimValues) {
    	            oldVal = oldVal.trim();
    	          }
    	          oldVal = this.replaceEntitiesValue(oldVal);
    	          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
    	          if(newVal === null || newVal === undefined){
    	            //don't parse
    	            attrs[aName] = oldVal;
    	          }else if(typeof newVal !== typeof oldVal || newVal !== oldVal){
    	            //overwrite
    	            attrs[aName] = newVal;
    	          }else {
    	            //parse
    	            attrs[aName] = parseValue(
    	              oldVal,
    	              this.options.parseAttributeValue,
    	              this.options.numberParseOptions
    	            );
    	          }
    	        } else if (this.options.allowBooleanAttributes) {
    	          attrs[aName] = true;
    	        }
    	      }
    	    }
    	    if (!Object.keys(attrs).length) {
    	      return;
    	    }
    	    if (this.options.attributesGroupName) {
    	      const attrCollection = {};
    	      attrCollection[this.options.attributesGroupName] = attrs;
    	      return attrCollection;
    	    }
    	    return attrs
    	  }
    	}

    	const parseXml = function(xmlData) {
    	  xmlData = xmlData.replace(/\r\n?/g, "\n"); //TODO: remove this line
    	  const xmlObj = new xmlNode('!xml');
    	  let currentNode = xmlObj;
    	  let textData = "";
    	  let jPath = "";
    	  for(let i=0; i< xmlData.length; i++){//for each char in XML data
    	    const ch = xmlData[i];
    	    if(ch === '<'){
    	      // const nextIndex = i+1;
    	      // const _2ndChar = xmlData[nextIndex];
    	      if( xmlData[i+1] === '/') {//Closing Tag
    	        const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.");
    	        let tagName = xmlData.substring(i+2,closeIndex).trim();

    	        if(this.options.removeNSPrefix){
    	          const colonIndex = tagName.indexOf(":");
    	          if(colonIndex !== -1){
    	            tagName = tagName.substr(colonIndex+1);
    	          }
    	        }

    	        if(this.options.transformTagName) {
    	          tagName = this.options.transformTagName(tagName);
    	        }

    	        if(currentNode){
    	          textData = this.saveTextToParentTag(textData, currentNode, jPath);
    	        }

    	        //check if last tag of nested tag was unpaired tag
    	        const lastTagName = jPath.substring(jPath.lastIndexOf(".")+1);
    	        if(tagName && this.options.unpairedTags.indexOf(tagName) !== -1 ){
    	          throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
    	        }
    	        let propIndex = 0;
    	        if(lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1 ){
    	          propIndex = jPath.lastIndexOf('.', jPath.lastIndexOf('.')-1);
    	          this.tagsNodeStack.pop();
    	        }else {
    	          propIndex = jPath.lastIndexOf(".");
    	        }
    	        jPath = jPath.substring(0, propIndex);

    	        currentNode = this.tagsNodeStack.pop();//avoid recursion, set the parent tag scope
    	        textData = "";
    	        i = closeIndex;
    	      } else if( xmlData[i+1] === '?') {

    	        let tagData = readTagExp(xmlData,i, false, "?>");
    	        if(!tagData) throw new Error("Pi Tag is not closed.");

    	        textData = this.saveTextToParentTag(textData, currentNode, jPath);
    	        if( (this.options.ignoreDeclaration && tagData.tagName === "?xml") || this.options.ignorePiTags);else {
    	  
    	          const childNode = new xmlNode(tagData.tagName);
    	          childNode.add(this.options.textNodeName, "");
    	          
    	          if(tagData.tagName !== tagData.tagExp && tagData.attrExpPresent){
    	            childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
    	          }
    	          this.addChild(currentNode, childNode, jPath);

    	        }


    	        i = tagData.closeIndex + 1;
    	      } else if(xmlData.substr(i + 1, 3) === '!--') {
    	        const endIndex = findClosingIndex(xmlData, "-->", i+4, "Comment is not closed.");
    	        if(this.options.commentPropName){
    	          const comment = xmlData.substring(i + 4, endIndex - 2);

    	          textData = this.saveTextToParentTag(textData, currentNode, jPath);

    	          currentNode.add(this.options.commentPropName, [ { [this.options.textNodeName] : comment } ]);
    	        }
    	        i = endIndex;
    	      } else if( xmlData.substr(i + 1, 2) === '!D') {
    	        const result = readDocType(xmlData, i);
    	        this.docTypeEntities = result.entities;
    	        i = result.i;
    	      }else if(xmlData.substr(i + 1, 2) === '![') {
    	        const closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2;
    	        const tagExp = xmlData.substring(i + 9,closeIndex);

    	        textData = this.saveTextToParentTag(textData, currentNode, jPath);

    	        let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);
    	        if(val == undefined) val = "";

    	        //cdata should be set even if it is 0 length string
    	        if(this.options.cdataPropName){
    	          currentNode.add(this.options.cdataPropName, [ { [this.options.textNodeName] : tagExp } ]);
    	        }else {
    	          currentNode.add(this.options.textNodeName, val);
    	        }
    	        
    	        i = closeIndex + 2;
    	      }else {//Opening tag
    	        let result = readTagExp(xmlData,i, this.options.removeNSPrefix);
    	        let tagName= result.tagName;
    	        const rawTagName = result.rawTagName;
    	        let tagExp = result.tagExp;
    	        let attrExpPresent = result.attrExpPresent;
    	        let closeIndex = result.closeIndex;

    	        if (this.options.transformTagName) {
    	          tagName = this.options.transformTagName(tagName);
    	        }
    	        
    	        //save text as child node
    	        if (currentNode && textData) {
    	          if(currentNode.tagname !== '!xml'){
    	            //when nested tag is found
    	            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
    	          }
    	        }

    	        //check if last tag was unpaired tag
    	        const lastTag = currentNode;
    	        if(lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1 ){
    	          currentNode = this.tagsNodeStack.pop();
    	          jPath = jPath.substring(0, jPath.lastIndexOf("."));
    	        }
    	        if(tagName !== xmlObj.tagname){
    	          jPath += jPath ? "." + tagName : tagName;
    	        }
    	        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
    	          let tagContent = "";
    	          //self-closing tag
    	          if(tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1){
    	            if(tagName[tagName.length - 1] === "/"){ //remove trailing '/'
    	              tagName = tagName.substr(0, tagName.length - 1);
    	              jPath = jPath.substr(0, jPath.length - 1);
    	              tagExp = tagName;
    	            }else {
    	              tagExp = tagExp.substr(0, tagExp.length - 1);
    	            }
    	            i = result.closeIndex;
    	          }
    	          //unpaired tag
    	          else if(this.options.unpairedTags.indexOf(tagName) !== -1){
    	            
    	            i = result.closeIndex;
    	          }
    	          //normal tag
    	          else {
    	            //read until closing tag is found
    	            const result = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);
    	            if(!result) throw new Error(`Unexpected end of ${rawTagName}`);
    	            i = result.i;
    	            tagContent = result.tagContent;
    	          }

    	          const childNode = new xmlNode(tagName);
    	          if(tagName !== tagExp && attrExpPresent){
    	            childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
    	          }
    	          if(tagContent) {
    	            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
    	          }
    	          
    	          jPath = jPath.substr(0, jPath.lastIndexOf("."));
    	          childNode.add(this.options.textNodeName, tagContent);
    	          
    	          this.addChild(currentNode, childNode, jPath);
    	        }else {
    	  //selfClosing tag
    	          if(tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1){
    	            if(tagName[tagName.length - 1] === "/"){ //remove trailing '/'
    	              tagName = tagName.substr(0, tagName.length - 1);
    	              jPath = jPath.substr(0, jPath.length - 1);
    	              tagExp = tagName;
    	            }else {
    	              tagExp = tagExp.substr(0, tagExp.length - 1);
    	            }
    	            
    	            if(this.options.transformTagName) {
    	              tagName = this.options.transformTagName(tagName);
    	            }

    	            const childNode = new xmlNode(tagName);
    	            if(tagName !== tagExp && attrExpPresent){
    	              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
    	            }
    	            this.addChild(currentNode, childNode, jPath);
    	            jPath = jPath.substr(0, jPath.lastIndexOf("."));
    	          }
    	    //opening tag
    	          else {
    	            const childNode = new xmlNode( tagName);
    	            this.tagsNodeStack.push(currentNode);
    	            
    	            if(tagName !== tagExp && attrExpPresent){
    	              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
    	            }
    	            this.addChild(currentNode, childNode, jPath);
    	            currentNode = childNode;
    	          }
    	          textData = "";
    	          i = closeIndex;
    	        }
    	      }
    	    }else {
    	      textData += xmlData[i];
    	    }
    	  }
    	  return xmlObj.child;
    	};

    	function addChild(currentNode, childNode, jPath){
    	  const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
    	  if(result === false);else if(typeof result === "string"){
    	    childNode.tagname = result;
    	    currentNode.addChild(childNode);
    	  }else {
    	    currentNode.addChild(childNode);
    	  }
    	}

    	const replaceEntitiesValue = function(val){

    	  if(this.options.processEntities){
    	    for(let entityName in this.docTypeEntities){
    	      const entity = this.docTypeEntities[entityName];
    	      val = val.replace( entity.regx, entity.val);
    	    }
    	    for(let entityName in this.lastEntities){
    	      const entity = this.lastEntities[entityName];
    	      val = val.replace( entity.regex, entity.val);
    	    }
    	    if(this.options.htmlEntities){
    	      for(let entityName in this.htmlEntities){
    	        const entity = this.htmlEntities[entityName];
    	        val = val.replace( entity.regex, entity.val);
    	      }
    	    }
    	    val = val.replace( this.ampEntity.regex, this.ampEntity.val);
    	  }
    	  return val;
    	};
    	function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
    	  if (textData) { //store previously collected data as textNode
    	    if(isLeafNode === undefined) isLeafNode = Object.keys(currentNode.child).length === 0;
    	    
    	    textData = this.parseTextData(textData,
    	      currentNode.tagname,
    	      jPath,
    	      false,
    	      currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
    	      isLeafNode);

    	    if (textData !== undefined && textData !== "")
    	      currentNode.add(this.options.textNodeName, textData);
    	    textData = "";
    	  }
    	  return textData;
    	}

    	//TODO: use jPath to simplify the logic
    	/**
    	 * 
    	 * @param {string[]} stopNodes 
    	 * @param {string} jPath
    	 * @param {string} currentTagName 
    	 */
    	function isItStopNode(stopNodes, jPath, currentTagName){
    	  const allNodesExp = "*." + currentTagName;
    	  for (const stopNodePath in stopNodes) {
    	    const stopNodeExp = stopNodes[stopNodePath];
    	    if( allNodesExp === stopNodeExp || jPath === stopNodeExp  ) return true;
    	  }
    	  return false;
    	}

    	/**
    	 * Returns the tag Expression and where it is ending handling single-double quotes situation
    	 * @param {string} xmlData 
    	 * @param {number} i starting index
    	 * @returns 
    	 */
    	function tagExpWithClosingIndex(xmlData, i, closingChar = ">"){
    	  let attrBoundary;
    	  let tagExp = "";
    	  for (let index = i; index < xmlData.length; index++) {
    	    let ch = xmlData[index];
    	    if (attrBoundary) {
    	        if (ch === attrBoundary) attrBoundary = "";//reset
    	    } else if (ch === '"' || ch === "'") {
    	        attrBoundary = ch;
    	    } else if (ch === closingChar[0]) {
    	      if(closingChar[1]){
    	        if(xmlData[index + 1] === closingChar[1]){
    	          return {
    	            data: tagExp,
    	            index: index
    	          }
    	        }
    	      }else {
    	        return {
    	          data: tagExp,
    	          index: index
    	        }
    	      }
    	    } else if (ch === '\t') {
    	      ch = " ";
    	    }
    	    tagExp += ch;
    	  }
    	}

    	function findClosingIndex(xmlData, str, i, errMsg){
    	  const closingIndex = xmlData.indexOf(str, i);
    	  if(closingIndex === -1){
    	    throw new Error(errMsg)
    	  }else {
    	    return closingIndex + str.length - 1;
    	  }
    	}

    	function readTagExp(xmlData,i, removeNSPrefix, closingChar = ">"){
    	  const result = tagExpWithClosingIndex(xmlData, i+1, closingChar);
    	  if(!result) return;
    	  let tagExp = result.data;
    	  const closeIndex = result.index;
    	  const separatorIndex = tagExp.search(/\s/);
    	  let tagName = tagExp;
    	  let attrExpPresent = true;
    	  if(separatorIndex !== -1){//separate tag name and attributes expression
    	    tagName = tagExp.substring(0, separatorIndex);
    	    tagExp = tagExp.substring(separatorIndex + 1).trimStart();
    	  }

    	  const rawTagName = tagName;
    	  if(removeNSPrefix){
    	    const colonIndex = tagName.indexOf(":");
    	    if(colonIndex !== -1){
    	      tagName = tagName.substr(colonIndex+1);
    	      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
    	    }
    	  }

    	  return {
    	    tagName: tagName,
    	    tagExp: tagExp,
    	    closeIndex: closeIndex,
    	    attrExpPresent: attrExpPresent,
    	    rawTagName: rawTagName,
    	  }
    	}
    	/**
    	 * find paired tag for a stop node
    	 * @param {string} xmlData 
    	 * @param {string} tagName 
    	 * @param {number} i 
    	 */
    	function readStopNodeData(xmlData, tagName, i){
    	  const startIndex = i;
    	  // Starting at 1 since we already have an open tag
    	  let openTagCount = 1;

    	  for (; i < xmlData.length; i++) {
    	    if( xmlData[i] === "<"){ 
    	      if (xmlData[i+1] === "/") {//close tag
    	          const closeIndex = findClosingIndex(xmlData, ">", i, `${tagName} is not closed`);
    	          let closeTagName = xmlData.substring(i+2,closeIndex).trim();
    	          if(closeTagName === tagName){
    	            openTagCount--;
    	            if (openTagCount === 0) {
    	              return {
    	                tagContent: xmlData.substring(startIndex, i),
    	                i : closeIndex
    	              }
    	            }
    	          }
    	          i=closeIndex;
    	        } else if(xmlData[i+1] === '?') { 
    	          const closeIndex = findClosingIndex(xmlData, "?>", i+1, "StopNode is not closed.");
    	          i=closeIndex;
    	        } else if(xmlData.substr(i + 1, 3) === '!--') { 
    	          const closeIndex = findClosingIndex(xmlData, "-->", i+3, "StopNode is not closed.");
    	          i=closeIndex;
    	        } else if(xmlData.substr(i + 1, 2) === '![') { 
    	          const closeIndex = findClosingIndex(xmlData, "]]>", i, "StopNode is not closed.") - 2;
    	          i=closeIndex;
    	        } else {
    	          const tagData = readTagExp(xmlData, i, '>');

    	          if (tagData) {
    	            const openTagName = tagData && tagData.tagName;
    	            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length-1] !== "/") {
    	              openTagCount++;
    	            }
    	            i=tagData.closeIndex;
    	          }
    	        }
    	      }
    	  }//end for loop
    	}

    	function parseValue(val, shouldParse, options) {
    	  if (shouldParse && typeof val === 'string') {
    	    //console.log(options)
    	    const newval = val.trim();
    	    if(newval === 'true' ) return true;
    	    else if(newval === 'false' ) return false;
    	    else return toNumber(val, options);
    	  } else {
    	    if (util.isExist(val)) {
    	      return val;
    	    } else {
    	      return '';
    	    }
    	  }
    	}


    	OrderedObjParser_1 = OrderedObjParser;
    	return OrderedObjParser_1;
    }

    var node2json = {};

    var hasRequiredNode2json;

    function requireNode2json () {
    	if (hasRequiredNode2json) return node2json;
    	hasRequiredNode2json = 1;

    	/**
    	 * 
    	 * @param {array} node 
    	 * @param {any} options 
    	 * @returns 
    	 */
    	function prettify(node, options){
    	  return compress( node, options);
    	}

    	/**
    	 * 
    	 * @param {array} arr 
    	 * @param {object} options 
    	 * @param {string} jPath 
    	 * @returns object
    	 */
    	function compress(arr, options, jPath){
    	  let text;
    	  const compressedObj = {};
    	  for (let i = 0; i < arr.length; i++) {
    	    const tagObj = arr[i];
    	    const property = propName(tagObj);
    	    let newJpath = "";
    	    if(jPath === undefined) newJpath = property;
    	    else newJpath = jPath + "." + property;

    	    if(property === options.textNodeName){
    	      if(text === undefined) text = tagObj[property];
    	      else text += "" + tagObj[property];
    	    }else if(property === undefined){
    	      continue;
    	    }else if(tagObj[property]){
    	      
    	      let val = compress(tagObj[property], options, newJpath);
    	      const isLeaf = isLeafTag(val, options);

    	      if(tagObj[":@"]){
    	        assignAttributes( val, tagObj[":@"], newJpath, options);
    	      }else if(Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode){
    	        val = val[options.textNodeName];
    	      }else if(Object.keys(val).length === 0){
    	        if(options.alwaysCreateTextNode) val[options.textNodeName] = "";
    	        else val = "";
    	      }

    	      if(compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {
    	        if(!Array.isArray(compressedObj[property])) {
    	            compressedObj[property] = [ compressedObj[property] ];
    	        }
    	        compressedObj[property].push(val);
    	      }else {
    	        //TODO: if a node is not an array, then check if it should be an array
    	        //also determine if it is a leaf node
    	        if (options.isArray(property, newJpath, isLeaf )) {
    	          compressedObj[property] = [val];
    	        }else {
    	          compressedObj[property] = val;
    	        }
    	      }
    	    }
    	    
    	  }
    	  // if(text && text.length > 0) compressedObj[options.textNodeName] = text;
    	  if(typeof text === "string"){
    	    if(text.length > 0) compressedObj[options.textNodeName] = text;
    	  }else if(text !== undefined) compressedObj[options.textNodeName] = text;
    	  return compressedObj;
    	}

    	function propName(obj){
    	  const keys = Object.keys(obj);
    	  for (let i = 0; i < keys.length; i++) {
    	    const key = keys[i];
    	    if(key !== ":@") return key;
    	  }
    	}

    	function assignAttributes(obj, attrMap, jpath, options){
    	  if (attrMap) {
    	    const keys = Object.keys(attrMap);
    	    const len = keys.length; //don't make it inline
    	    for (let i = 0; i < len; i++) {
    	      const atrrName = keys[i];
    	      if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
    	        obj[atrrName] = [ attrMap[atrrName] ];
    	      } else {
    	        obj[atrrName] = attrMap[atrrName];
    	      }
    	    }
    	  }
    	}

    	function isLeafTag(obj, options){
    	  const { textNodeName } = options;
    	  const propCount = Object.keys(obj).length;
    	  
    	  if (propCount === 0) {
    	    return true;
    	  }

    	  if (
    	    propCount === 1 &&
    	    (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)
    	  ) {
    	    return true;
    	  }

    	  return false;
    	}
    	node2json.prettify = prettify;
    	return node2json;
    }

    var XMLParser_1;
    var hasRequiredXMLParser;

    function requireXMLParser () {
    	if (hasRequiredXMLParser) return XMLParser_1;
    	hasRequiredXMLParser = 1;
    	const { buildOptions} = requireOptionsBuilder();
    	const OrderedObjParser = requireOrderedObjParser();
    	const { prettify} = requireNode2json();
    	const validator = requireValidator();

    	class XMLParser{
    	    
    	    constructor(options){
    	        this.externalEntities = {};
    	        this.options = buildOptions(options);
    	        
    	    }
    	    /**
    	     * Parse XML dats to JS object 
    	     * @param {string|Buffer} xmlData 
    	     * @param {boolean|Object} validationOption 
    	     */
    	    parse(xmlData,validationOption){
    	        if(typeof xmlData === "string");else if( xmlData.toString){
    	            xmlData = xmlData.toString();
    	        }else {
    	            throw new Error("XML data is accepted in String or Bytes[] form.")
    	        }
    	        if( validationOption){
    	            if(validationOption === true) validationOption = {}; //validate with default options
    	            
    	            const result = validator.validate(xmlData, validationOption);
    	            if (result !== true) {
    	              throw Error( `${result.err.msg}:${result.err.line}:${result.err.col}` )
    	            }
    	          }
    	        const orderedObjParser = new OrderedObjParser(this.options);
    	        orderedObjParser.addExternalEntities(this.externalEntities);
    	        const orderedResult = orderedObjParser.parseXml(xmlData);
    	        if(this.options.preserveOrder || orderedResult === undefined) return orderedResult;
    	        else return prettify(orderedResult, this.options);
    	    }

    	    /**
    	     * Add Entity which is not by default supported by this library
    	     * @param {string} key 
    	     * @param {string} value 
    	     */
    	    addEntity(key, value){
    	        if(value.indexOf("&") !== -1){
    	            throw new Error("Entity value can't have '&'")
    	        }else if(key.indexOf("&") !== -1 || key.indexOf(";") !== -1){
    	            throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'")
    	        }else if(value === "&"){
    	            throw new Error("An entity with value '&' is not permitted");
    	        }else {
    	            this.externalEntities[key] = value;
    	        }
    	    }
    	}

    	XMLParser_1 = XMLParser;
    	return XMLParser_1;
    }

    var orderedJs2Xml;
    var hasRequiredOrderedJs2Xml;

    function requireOrderedJs2Xml () {
    	if (hasRequiredOrderedJs2Xml) return orderedJs2Xml;
    	hasRequiredOrderedJs2Xml = 1;
    	const EOL = "\n";

    	/**
    	 * 
    	 * @param {array} jArray 
    	 * @param {any} options 
    	 * @returns 
    	 */
    	function toXml(jArray, options) {
    	    let indentation = "";
    	    if (options.format && options.indentBy.length > 0) {
    	        indentation = EOL;
    	    }
    	    return arrToStr(jArray, options, "", indentation);
    	}

    	function arrToStr(arr, options, jPath, indentation) {
    	    let xmlStr = "";
    	    let isPreviousElementTag = false;

    	    for (let i = 0; i < arr.length; i++) {
    	        const tagObj = arr[i];
    	        const tagName = propName(tagObj);
    	        if(tagName === undefined) continue;

    	        let newJPath = "";
    	        if (jPath.length === 0) newJPath = tagName;
    	        else newJPath = `${jPath}.${tagName}`;

    	        if (tagName === options.textNodeName) {
    	            let tagText = tagObj[tagName];
    	            if (!isStopNode(newJPath, options)) {
    	                tagText = options.tagValueProcessor(tagName, tagText);
    	                tagText = replaceEntitiesValue(tagText, options);
    	            }
    	            if (isPreviousElementTag) {
    	                xmlStr += indentation;
    	            }
    	            xmlStr += tagText;
    	            isPreviousElementTag = false;
    	            continue;
    	        } else if (tagName === options.cdataPropName) {
    	            if (isPreviousElementTag) {
    	                xmlStr += indentation;
    	            }
    	            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
    	            isPreviousElementTag = false;
    	            continue;
    	        } else if (tagName === options.commentPropName) {
    	            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
    	            isPreviousElementTag = true;
    	            continue;
    	        } else if (tagName[0] === "?") {
    	            const attStr = attr_to_str(tagObj[":@"], options);
    	            const tempInd = tagName === "?xml" ? "" : indentation;
    	            let piTextNodeName = tagObj[tagName][0][options.textNodeName];
    	            piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : ""; //remove extra spacing
    	            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;
    	            isPreviousElementTag = true;
    	            continue;
    	        }
    	        let newIdentation = indentation;
    	        if (newIdentation !== "") {
    	            newIdentation += options.indentBy;
    	        }
    	        const attStr = attr_to_str(tagObj[":@"], options);
    	        const tagStart = indentation + `<${tagName}${attStr}`;
    	        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
    	        if (options.unpairedTags.indexOf(tagName) !== -1) {
    	            if (options.suppressUnpairedNode) xmlStr += tagStart + ">";
    	            else xmlStr += tagStart + "/>";
    	        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
    	            xmlStr += tagStart + "/>";
    	        } else if (tagValue && tagValue.endsWith(">")) {
    	            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
    	        } else {
    	            xmlStr += tagStart + ">";
    	            if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
    	                xmlStr += indentation + options.indentBy + tagValue + indentation;
    	            } else {
    	                xmlStr += tagValue;
    	            }
    	            xmlStr += `</${tagName}>`;
    	        }
    	        isPreviousElementTag = true;
    	    }

    	    return xmlStr;
    	}

    	function propName(obj) {
    	    const keys = Object.keys(obj);
    	    for (let i = 0; i < keys.length; i++) {
    	        const key = keys[i];
    	        if(!obj.hasOwnProperty(key)) continue;
    	        if (key !== ":@") return key;
    	    }
    	}

    	function attr_to_str(attrMap, options) {
    	    let attrStr = "";
    	    if (attrMap && !options.ignoreAttributes) {
    	        for (let attr in attrMap) {
    	            if(!attrMap.hasOwnProperty(attr)) continue;
    	            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
    	            attrVal = replaceEntitiesValue(attrVal, options);
    	            if (attrVal === true && options.suppressBooleanAttributes) {
    	                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
    	            } else {
    	                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
    	            }
    	        }
    	    }
    	    return attrStr;
    	}

    	function isStopNode(jPath, options) {
    	    jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
    	    let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
    	    for (let index in options.stopNodes) {
    	        if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName) return true;
    	    }
    	    return false;
    	}

    	function replaceEntitiesValue(textValue, options) {
    	    if (textValue && textValue.length > 0 && options.processEntities) {
    	        for (let i = 0; i < options.entities.length; i++) {
    	            const entity = options.entities[i];
    	            textValue = textValue.replace(entity.regex, entity.val);
    	        }
    	    }
    	    return textValue;
    	}
    	orderedJs2Xml = toXml;
    	return orderedJs2Xml;
    }

    var json2xml;
    var hasRequiredJson2xml;

    function requireJson2xml () {
    	if (hasRequiredJson2xml) return json2xml;
    	hasRequiredJson2xml = 1;
    	//parse Empty Node as self closing node
    	const buildFromOrderedJs = requireOrderedJs2Xml();

    	const defaultOptions = {
    	  attributeNamePrefix: '@_',
    	  attributesGroupName: false,
    	  textNodeName: '#text',
    	  ignoreAttributes: true,
    	  cdataPropName: false,
    	  format: false,
    	  indentBy: '  ',
    	  suppressEmptyNode: false,
    	  suppressUnpairedNode: true,
    	  suppressBooleanAttributes: true,
    	  tagValueProcessor: function(key, a) {
    	    return a;
    	  },
    	  attributeValueProcessor: function(attrName, a) {
    	    return a;
    	  },
    	  preserveOrder: false,
    	  commentPropName: false,
    	  unpairedTags: [],
    	  entities: [
    	    { regex: new RegExp("&", "g"), val: "&amp;" },//it must be on top
    	    { regex: new RegExp(">", "g"), val: "&gt;" },
    	    { regex: new RegExp("<", "g"), val: "&lt;" },
    	    { regex: new RegExp("\'", "g"), val: "&apos;" },
    	    { regex: new RegExp("\"", "g"), val: "&quot;" }
    	  ],
    	  processEntities: true,
    	  stopNodes: [],
    	  // transformTagName: false,
    	  // transformAttributeName: false,
    	  oneListGroup: false
    	};

    	function Builder(options) {
    	  this.options = Object.assign({}, defaultOptions, options);
    	  if (this.options.ignoreAttributes || this.options.attributesGroupName) {
    	    this.isAttribute = function(/*a*/) {
    	      return false;
    	    };
    	  } else {
    	    this.attrPrefixLen = this.options.attributeNamePrefix.length;
    	    this.isAttribute = isAttribute;
    	  }

    	  this.processTextOrObjNode = processTextOrObjNode;

    	  if (this.options.format) {
    	    this.indentate = indentate;
    	    this.tagEndChar = '>\n';
    	    this.newLine = '\n';
    	  } else {
    	    this.indentate = function() {
    	      return '';
    	    };
    	    this.tagEndChar = '>';
    	    this.newLine = '';
    	  }
    	}

    	Builder.prototype.build = function(jObj) {
    	  if(this.options.preserveOrder){
    	    return buildFromOrderedJs(jObj, this.options);
    	  }else {
    	    if(Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1){
    	      jObj = {
    	        [this.options.arrayNodeName] : jObj
    	      };
    	    }
    	    return this.j2x(jObj, 0).val;
    	  }
    	};

    	Builder.prototype.j2x = function(jObj, level) {
    	  let attrStr = '';
    	  let val = '';
    	  for (let key in jObj) {
    	    if(!Object.prototype.hasOwnProperty.call(jObj, key)) continue;
    	    if (typeof jObj[key] === 'undefined') {
    	      // supress undefined node only if it is not an attribute
    	      if (this.isAttribute(key)) {
    	        val += '';
    	      }
    	    } else if (jObj[key] === null) {
    	      // null attribute should be ignored by the attribute list, but should not cause the tag closing
    	      if (this.isAttribute(key)) {
    	        val += '';
    	      } else if (key[0] === '?') {
    	        val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;
    	      } else {
    	        val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
    	      }
    	      // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
    	    } else if (jObj[key] instanceof Date) {
    	      val += this.buildTextValNode(jObj[key], key, '', level);
    	    } else if (typeof jObj[key] !== 'object') {
    	      //premitive type
    	      const attr = this.isAttribute(key);
    	      if (attr) {
    	        attrStr += this.buildAttrPairStr(attr, '' + jObj[key]);
    	      }else {
    	        //tag value
    	        if (key === this.options.textNodeName) {
    	          let newval = this.options.tagValueProcessor(key, '' + jObj[key]);
    	          val += this.replaceEntitiesValue(newval);
    	        } else {
    	          val += this.buildTextValNode(jObj[key], key, '', level);
    	        }
    	      }
    	    } else if (Array.isArray(jObj[key])) {
    	      //repeated nodes
    	      const arrLen = jObj[key].length;
    	      let listTagVal = "";
    	      let listTagAttr = "";
    	      for (let j = 0; j < arrLen; j++) {
    	        const item = jObj[key][j];
    	        if (typeof item === 'undefined') ; else if (item === null) {
    	          if(key[0] === "?") val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;
    	          else val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
    	          // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
    	        } else if (typeof item === 'object') {
    	          if(this.options.oneListGroup){
    	            const result = this.j2x(item, level + 1);
    	            listTagVal += result.val;
    	            if (this.options.attributesGroupName && item.hasOwnProperty(this.options.attributesGroupName)) {
    	              listTagAttr += result.attrStr;
    	            }
    	          }else {
    	            listTagVal += this.processTextOrObjNode(item, key, level);
    	          }
    	        } else {
    	          if (this.options.oneListGroup) {
    	            let textValue = this.options.tagValueProcessor(key, item);
    	            textValue = this.replaceEntitiesValue(textValue);
    	            listTagVal += textValue;
    	          } else {
    	            listTagVal += this.buildTextValNode(item, key, '', level);
    	          }
    	        }
    	      }
    	      if(this.options.oneListGroup){
    	        listTagVal = this.buildObjectNode(listTagVal, key, listTagAttr, level);
    	      }
    	      val += listTagVal;
    	    } else {
    	      //nested node
    	      if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
    	        const Ks = Object.keys(jObj[key]);
    	        const L = Ks.length;
    	        for (let j = 0; j < L; j++) {
    	          attrStr += this.buildAttrPairStr(Ks[j], '' + jObj[key][Ks[j]]);
    	        }
    	      } else {
    	        val += this.processTextOrObjNode(jObj[key], key, level);
    	      }
    	    }
    	  }
    	  return {attrStr: attrStr, val: val};
    	};

    	Builder.prototype.buildAttrPairStr = function(attrName, val){
    	  val = this.options.attributeValueProcessor(attrName, '' + val);
    	  val = this.replaceEntitiesValue(val);
    	  if (this.options.suppressBooleanAttributes && val === "true") {
    	    return ' ' + attrName;
    	  } else return ' ' + attrName + '="' + val + '"';
    	};

    	function processTextOrObjNode (object, key, level) {
    	  const result = this.j2x(object, level + 1);
    	  if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {
    	    return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
    	  } else {
    	    return this.buildObjectNode(result.val, key, result.attrStr, level);
    	  }
    	}

    	Builder.prototype.buildObjectNode = function(val, key, attrStr, level) {
    	  if(val === ""){
    	    if(key[0] === "?") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;
    	    else {
    	      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;
    	    }
    	  }else {

    	    let tagEndExp = '</' + key + this.tagEndChar;
    	    let piClosingChar = "";
    	    
    	    if(key[0] === "?") {
    	      piClosingChar = "?";
    	      tagEndExp = "";
    	    }
    	  
    	    // attrStr is an empty string in case the attribute came as undefined or null
    	    if ((attrStr || attrStr === '') && val.indexOf('<') === -1) {
    	      return ( this.indentate(level) + '<' +  key + attrStr + piClosingChar + '>' + val + tagEndExp );
    	    } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
    	      return this.indentate(level) + `<!--${val}-->` + this.newLine;
    	    }else {
    	      return (
    	        this.indentate(level) + '<' + key + attrStr + piClosingChar + this.tagEndChar +
    	        val +
    	        this.indentate(level) + tagEndExp    );
    	    }
    	  }
    	};

    	Builder.prototype.closeTag = function(key){
    	  let closeTag = "";
    	  if(this.options.unpairedTags.indexOf(key) !== -1){ //unpaired
    	    if(!this.options.suppressUnpairedNode) closeTag = "/";
    	  }else if(this.options.suppressEmptyNode){ //empty
    	    closeTag = "/";
    	  }else {
    	    closeTag = `></${key}`;
    	  }
    	  return closeTag;
    	};

    	Builder.prototype.buildTextValNode = function(val, key, attrStr, level) {
    	  if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
    	    return this.indentate(level) + `<![CDATA[${val}]]>` +  this.newLine;
    	  }else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
    	    return this.indentate(level) + `<!--${val}-->` +  this.newLine;
    	  }else if(key[0] === "?") {//PI tag
    	    return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar; 
    	  }else {
    	    let textValue = this.options.tagValueProcessor(key, val);
    	    textValue = this.replaceEntitiesValue(textValue);
    	  
    	    if( textValue === ''){
    	      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;
    	    }else {
    	      return this.indentate(level) + '<' + key + attrStr + '>' +
    	         textValue +
    	        '</' + key + this.tagEndChar;
    	    }
    	  }
    	};

    	Builder.prototype.replaceEntitiesValue = function(textValue){
    	  if(textValue && textValue.length > 0 && this.options.processEntities){
    	    for (let i=0; i<this.options.entities.length; i++) {
    	      const entity = this.options.entities[i];
    	      textValue = textValue.replace(entity.regex, entity.val);
    	    }
    	  }
    	  return textValue;
    	};

    	function indentate(level) {
    	  return this.options.indentBy.repeat(level);
    	}

    	function isAttribute(name /*, options*/) {
    	  if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {
    	    return name.substr(this.attrPrefixLen);
    	  } else {
    	    return false;
    	  }
    	}

    	json2xml = Builder;
    	return json2xml;
    }

    var fxp;
    var hasRequiredFxp;

    function requireFxp () {
    	if (hasRequiredFxp) return fxp;
    	hasRequiredFxp = 1;

    	const validator = requireValidator();
    	const XMLParser = requireXMLParser();
    	const XMLBuilder = requireJson2xml();

    	fxp = {
    	  XMLParser: XMLParser,
    	  XMLValidator: validator,
    	  XMLBuilder: XMLBuilder
    	};
    	return fxp;
    }

    var fxpExports = requireFxp();

    const parseXmlBody = (streamBody, context) => collectBodyString$3(streamBody, context).then((encoded) => {
        if (encoded.length) {
            const parser = new fxpExports.XMLParser({
                attributeNamePrefix: "",
                htmlEntities: true,
                ignoreAttributes: false,
                ignoreDeclaration: true,
                parseTagValue: false,
                trimValues: false,
                tagValueProcessor: (_, val) => (val.trim() === "" && val.includes("\n") ? "" : undefined),
            });
            parser.addEntity("#xD", "\r");
            parser.addEntity("#10", "\n");
            let parsedObj;
            try {
                parsedObj = parser.parse(encoded, true);
            }
            catch (e) {
                if (e && typeof e === "object") {
                    Object.defineProperty(e, "$responseBodyText", {
                        value: encoded,
                    });
                }
                throw e;
            }
            const textNodeName = "#text";
            const key = Object.keys(parsedObj)[0];
            const parsedObjToReturn = parsedObj[key];
            if (parsedObjToReturn[textNodeName]) {
                parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
                delete parsedObjToReturn[textNodeName];
            }
            return getValueFromTextNode(parsedObjToReturn);
        }
        return {};
    });
    const parseXmlErrorBody = async (errorBody, context) => {
        const value = await parseXmlBody(errorBody, context);
        if (value.Error) {
            value.Error.message = value.Error.message ?? value.Error.Message;
        }
        return value;
    };

    const defaultLocationHttpAuthSchemeParametersProvider = async (config, context, input) => {
        return {
            operation: getSmithyContext(context).operation,
            region: (await normalizeProvider$5(config.region)()) ||
                (() => {
                    throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
                })(),
        };
    };
    function createAwsAuthSigv4HttpAuthOption$2(authParameters) {
        return {
            schemeId: "aws.auth#sigv4",
            signingProperties: {
                name: "geo",
                region: authParameters.region,
            },
            propertiesExtractor: (config, context) => ({
                signingProperties: {
                    config,
                    context,
                },
            }),
        };
    }
    const defaultLocationHttpAuthSchemeProvider = (authParameters) => {
        const options = [];
        switch (authParameters.operation) {
            default: {
                options.push(createAwsAuthSigv4HttpAuthOption$2(authParameters));
            }
        }
        return options;
    };
    const resolveHttpAuthSchemeConfig$2 = (config) => {
        const config_0 = resolveAwsSdkSigV4Config(config);
        return {
            ...config_0,
        };
    };

    const resolveClientEndpointParameters$2 = (options) => {
        return {
            ...options,
            useDualstackEndpoint: options.useDualstackEndpoint ?? false,
            useFipsEndpoint: options.useFipsEndpoint ?? false,
            defaultSigningName: "geo",
        };
    };
    const commonParams$2 = {
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
    };

    var name$5 = "@aws-sdk/client-location";
    var description$5 = "AWS SDK for JavaScript Location Client for Node.js, Browser and React Native";
    var version$5 = "3.621.0";
    var scripts$5 = {
    	build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    	"build:cjs": "node ../../scripts/compilation/inline client-location",
    	"build:es": "tsc -p tsconfig.es.json",
    	"build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    	"build:types": "tsc -p tsconfig.types.json",
    	"build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    	clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    	"extract:docs": "api-extractor run --local",
    	"generate:client": "node ../../scripts/generate-clients/single-service --solo location"
    };
    var main$5 = "./dist-cjs/index.js";
    var types$5 = "./dist-types/index.d.ts";
    var module$5 = "./dist-es/index.js";
    var sideEffects$5 = false;
    var dependencies$5 = {
    	"@aws-crypto/sha256-browser": "5.2.0",
    	"@aws-crypto/sha256-js": "5.2.0",
    	"@aws-sdk/client-sso-oidc": "3.621.0",
    	"@aws-sdk/client-sts": "3.621.0",
    	"@aws-sdk/core": "3.621.0",
    	"@aws-sdk/credential-provider-node": "3.621.0",
    	"@aws-sdk/middleware-host-header": "3.620.0",
    	"@aws-sdk/middleware-logger": "3.609.0",
    	"@aws-sdk/middleware-recursion-detection": "3.620.0",
    	"@aws-sdk/middleware-user-agent": "3.620.0",
    	"@aws-sdk/region-config-resolver": "3.614.0",
    	"@aws-sdk/types": "3.609.0",
    	"@aws-sdk/util-endpoints": "3.614.0",
    	"@aws-sdk/util-user-agent-browser": "3.609.0",
    	"@aws-sdk/util-user-agent-node": "3.614.0",
    	"@smithy/config-resolver": "^3.0.5",
    	"@smithy/core": "^2.3.1",
    	"@smithy/fetch-http-handler": "^3.2.4",
    	"@smithy/hash-node": "^3.0.3",
    	"@smithy/invalid-dependency": "^3.0.3",
    	"@smithy/middleware-content-length": "^3.0.5",
    	"@smithy/middleware-endpoint": "^3.1.0",
    	"@smithy/middleware-retry": "^3.0.13",
    	"@smithy/middleware-serde": "^3.0.3",
    	"@smithy/middleware-stack": "^3.0.3",
    	"@smithy/node-config-provider": "^3.1.4",
    	"@smithy/node-http-handler": "^3.1.4",
    	"@smithy/protocol-http": "^4.1.0",
    	"@smithy/smithy-client": "^3.1.11",
    	"@smithy/types": "^3.3.0",
    	"@smithy/url-parser": "^3.0.3",
    	"@smithy/util-base64": "^3.0.0",
    	"@smithy/util-body-length-browser": "^3.0.0",
    	"@smithy/util-body-length-node": "^3.0.0",
    	"@smithy/util-defaults-mode-browser": "^3.0.13",
    	"@smithy/util-defaults-mode-node": "^3.0.13",
    	"@smithy/util-endpoints": "^2.0.5",
    	"@smithy/util-middleware": "^3.0.3",
    	"@smithy/util-retry": "^3.0.3",
    	"@smithy/util-stream": "^3.1.3",
    	"@smithy/util-utf8": "^3.0.0",
    	tslib: "^2.6.2"
    };
    var devDependencies$5 = {
    	"@tsconfig/node16": "16.1.3",
    	"@types/node": "^16.18.96",
    	concurrently: "7.0.0",
    	"downlevel-dts": "0.10.1",
    	rimraf: "3.0.2",
    	typescript: "~4.9.5"
    };
    var engines$5 = {
    	node: ">=16.0.0"
    };
    var typesVersions$5 = {
    	"<4.0": {
    		"dist-types/*": [
    			"dist-types/ts3.4/*"
    		]
    	}
    };
    var files$5 = [
    	"dist-*/**"
    ];
    var author$2 = {
    	name: "AWS SDK for JavaScript Team",
    	url: "https://aws.amazon.com/javascript/"
    };
    var license$2 = "Apache-2.0";
    var browser$5 = {
    	"./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
    };
    var homepage$2 = "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-location";
    var repository$2 = {
    	type: "git",
    	url: "https://github.com/aws/aws-sdk-js-v3.git",
    	directory: "clients/client-location"
    };
    var packageInfo$5 = {
    	name: name$5,
    	description: description$5,
    	version: version$5,
    	scripts: scripts$5,
    	main: main$5,
    	types: types$5,
    	module: module$5,
    	sideEffects: sideEffects$5,
    	dependencies: dependencies$5,
    	devDependencies: devDependencies$5,
    	engines: engines$5,
    	typesVersions: typesVersions$5,
    	files: files$5,
    	author: author$2,
    	license: license$2,
    	browser: browser$5,
    	"react-native": {
    	"./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
    },
    	homepage: homepage$2,
    	repository: repository$2
    };

    const fromUtf8$8 = (input) => new TextEncoder().encode(input);

    // Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
    // SPDX-License-Identifier: Apache-2.0
    // Quick polyfill
    var fromUtf8$7 = typeof Buffer !== "undefined" && Buffer.from
        ? function (input) { return Buffer.from(input, "utf8"); }
        : fromUtf8$8;
    function convertToBuffer$3(data) {
        // Already a Uint8, do nothing
        if (data instanceof Uint8Array)
            return data;
        if (typeof data === "string") {
            return fromUtf8$7(data);
        }
        if (ArrayBuffer.isView(data)) {
            return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
        }
        return new Uint8Array(data);
    }

    // Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
    // SPDX-License-Identifier: Apache-2.0
    function isEmptyData$6(data) {
        if (typeof data === "string") {
            return data.length === 0;
        }
        return data.byteLength === 0;
    }

    var SHA_256_HASH = { name: "SHA-256" };
    var SHA_256_HMAC_ALGO = {
        name: "HMAC",
        hash: SHA_256_HASH
    };
    var EMPTY_DATA_SHA_256 = new Uint8Array([
        227,
        176,
        196,
        66,
        152,
        252,
        28,
        20,
        154,
        251,
        244,
        200,
        153,
        111,
        185,
        36,
        39,
        174,
        65,
        228,
        100,
        155,
        147,
        76,
        164,
        149,
        153,
        27,
        120,
        82,
        184,
        85
    ]);

    const fallbackWindow = {};
    function locateWindow() {
        if (typeof window !== "undefined") {
            return window;
        }
        else if (typeof self !== "undefined") {
            return self;
        }
        return fallbackWindow;
    }

    var distEs$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        locateWindow: locateWindow
    });

    var Sha256$2 = /** @class */ (function () {
        function Sha256(secret) {
            this.toHash = new Uint8Array(0);
            this.secret = secret;
            this.reset();
        }
        Sha256.prototype.update = function (data) {
            if (isEmptyData$6(data)) {
                return;
            }
            var update = convertToBuffer$3(data);
            var typedArray = new Uint8Array(this.toHash.byteLength + update.byteLength);
            typedArray.set(this.toHash, 0);
            typedArray.set(update, this.toHash.byteLength);
            this.toHash = typedArray;
        };
        Sha256.prototype.digest = function () {
            var _this = this;
            if (this.key) {
                return this.key.then(function (key) {
                    return locateWindow()
                        .crypto.subtle.sign(SHA_256_HMAC_ALGO, key, _this.toHash)
                        .then(function (data) { return new Uint8Array(data); });
                });
            }
            if (isEmptyData$6(this.toHash)) {
                return Promise.resolve(EMPTY_DATA_SHA_256);
            }
            return Promise.resolve()
                .then(function () {
                return locateWindow().crypto.subtle.digest(SHA_256_HASH, _this.toHash);
            })
                .then(function (data) { return Promise.resolve(new Uint8Array(data)); });
        };
        Sha256.prototype.reset = function () {
            var _this = this;
            this.toHash = new Uint8Array(0);
            if (this.secret && this.secret !== void 0) {
                this.key = new Promise(function (resolve, reject) {
                    locateWindow()
                        .crypto.subtle.importKey("raw", convertToBuffer$3(_this.secret), SHA_256_HMAC_ALGO, false, ["sign"])
                        .then(resolve, reject);
                });
                this.key.catch(function () { });
            }
        };
        return Sha256;
    }());

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise, SuppressedError, Symbol */


    function __awaiter$a(thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }

    function __generator$a(thisArg, body) {
      var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
      function verb(n) { return function (v) { return step([n, v]); }; }
      function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (g && (g = 0, op[0] && (_ = 0)), _) try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
              if (y = 0, t) op = [op[0] & 2, t.value];
              switch (op[0]) {
                  case 0: case 1: t = op; break;
                  case 4: _.label++; return { value: op[1], done: false };
                  case 5: _.label++; y = op[1]; op = [0]; continue;
                  case 7: op = _.ops.pop(); _.trys.pop(); continue;
                  default:
                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                      if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                      if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                      if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                      if (t[2]) _.ops.pop();
                      _.trys.pop(); continue;
              }
              op = body.call(thisArg, _);
          } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
          if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
      }
    }

    typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };

    /**
     * @internal
     */
    var BLOCK_SIZE = 64;
    /**
     * @internal
     */
    var DIGEST_LENGTH = 32;
    /**
     * @internal
     */
    var KEY = new Uint32Array([
        0x428a2f98,
        0x71374491,
        0xb5c0fbcf,
        0xe9b5dba5,
        0x3956c25b,
        0x59f111f1,
        0x923f82a4,
        0xab1c5ed5,
        0xd807aa98,
        0x12835b01,
        0x243185be,
        0x550c7dc3,
        0x72be5d74,
        0x80deb1fe,
        0x9bdc06a7,
        0xc19bf174,
        0xe49b69c1,
        0xefbe4786,
        0x0fc19dc6,
        0x240ca1cc,
        0x2de92c6f,
        0x4a7484aa,
        0x5cb0a9dc,
        0x76f988da,
        0x983e5152,
        0xa831c66d,
        0xb00327c8,
        0xbf597fc7,
        0xc6e00bf3,
        0xd5a79147,
        0x06ca6351,
        0x14292967,
        0x27b70a85,
        0x2e1b2138,
        0x4d2c6dfc,
        0x53380d13,
        0x650a7354,
        0x766a0abb,
        0x81c2c92e,
        0x92722c85,
        0xa2bfe8a1,
        0xa81a664b,
        0xc24b8b70,
        0xc76c51a3,
        0xd192e819,
        0xd6990624,
        0xf40e3585,
        0x106aa070,
        0x19a4c116,
        0x1e376c08,
        0x2748774c,
        0x34b0bcb5,
        0x391c0cb3,
        0x4ed8aa4a,
        0x5b9cca4f,
        0x682e6ff3,
        0x748f82ee,
        0x78a5636f,
        0x84c87814,
        0x8cc70208,
        0x90befffa,
        0xa4506ceb,
        0xbef9a3f7,
        0xc67178f2
    ]);
    /**
     * @internal
     */
    var INIT = [
        0x6a09e667,
        0xbb67ae85,
        0x3c6ef372,
        0xa54ff53a,
        0x510e527f,
        0x9b05688c,
        0x1f83d9ab,
        0x5be0cd19
    ];
    /**
     * @internal
     */
    var MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;

    /**
     * @internal
     */
    var RawSha256$3 = /** @class */ (function () {
        function RawSha256() {
            this.state = Int32Array.from(INIT);
            this.temp = new Int32Array(64);
            this.buffer = new Uint8Array(64);
            this.bufferLength = 0;
            this.bytesHashed = 0;
            /**
             * @internal
             */
            this.finished = false;
        }
        RawSha256.prototype.update = function (data) {
            if (this.finished) {
                throw new Error("Attempted to update an already finished hash.");
            }
            var position = 0;
            var byteLength = data.byteLength;
            this.bytesHashed += byteLength;
            if (this.bytesHashed * 8 > MAX_HASHABLE_LENGTH) {
                throw new Error("Cannot hash more than 2^53 - 1 bits");
            }
            while (byteLength > 0) {
                this.buffer[this.bufferLength++] = data[position++];
                byteLength--;
                if (this.bufferLength === BLOCK_SIZE) {
                    this.hashBuffer();
                    this.bufferLength = 0;
                }
            }
        };
        RawSha256.prototype.digest = function () {
            if (!this.finished) {
                var bitsHashed = this.bytesHashed * 8;
                var bufferView = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);
                var undecoratedLength = this.bufferLength;
                bufferView.setUint8(this.bufferLength++, 0x80);
                // Ensure the final block has enough room for the hashed length
                if (undecoratedLength % BLOCK_SIZE >= BLOCK_SIZE - 8) {
                    for (var i = this.bufferLength; i < BLOCK_SIZE; i++) {
                        bufferView.setUint8(i, 0);
                    }
                    this.hashBuffer();
                    this.bufferLength = 0;
                }
                for (var i = this.bufferLength; i < BLOCK_SIZE - 8; i++) {
                    bufferView.setUint8(i, 0);
                }
                bufferView.setUint32(BLOCK_SIZE - 8, Math.floor(bitsHashed / 0x100000000), true);
                bufferView.setUint32(BLOCK_SIZE - 4, bitsHashed);
                this.hashBuffer();
                this.finished = true;
            }
            // The value in state is little-endian rather than big-endian, so flip
            // each word into a new Uint8Array
            var out = new Uint8Array(DIGEST_LENGTH);
            for (var i = 0; i < 8; i++) {
                out[i * 4] = (this.state[i] >>> 24) & 0xff;
                out[i * 4 + 1] = (this.state[i] >>> 16) & 0xff;
                out[i * 4 + 2] = (this.state[i] >>> 8) & 0xff;
                out[i * 4 + 3] = (this.state[i] >>> 0) & 0xff;
            }
            return out;
        };
        RawSha256.prototype.hashBuffer = function () {
            var _a = this, buffer = _a.buffer, state = _a.state;
            var state0 = state[0], state1 = state[1], state2 = state[2], state3 = state[3], state4 = state[4], state5 = state[5], state6 = state[6], state7 = state[7];
            for (var i = 0; i < BLOCK_SIZE; i++) {
                if (i < 16) {
                    this.temp[i] =
                        ((buffer[i * 4] & 0xff) << 24) |
                            ((buffer[i * 4 + 1] & 0xff) << 16) |
                            ((buffer[i * 4 + 2] & 0xff) << 8) |
                            (buffer[i * 4 + 3] & 0xff);
                }
                else {
                    var u = this.temp[i - 2];
                    var t1_1 = ((u >>> 17) | (u << 15)) ^ ((u >>> 19) | (u << 13)) ^ (u >>> 10);
                    u = this.temp[i - 15];
                    var t2_1 = ((u >>> 7) | (u << 25)) ^ ((u >>> 18) | (u << 14)) ^ (u >>> 3);
                    this.temp[i] =
                        ((t1_1 + this.temp[i - 7]) | 0) + ((t2_1 + this.temp[i - 16]) | 0);
                }
                var t1 = ((((((state4 >>> 6) | (state4 << 26)) ^
                    ((state4 >>> 11) | (state4 << 21)) ^
                    ((state4 >>> 25) | (state4 << 7))) +
                    ((state4 & state5) ^ (~state4 & state6))) |
                    0) +
                    ((state7 + ((KEY[i] + this.temp[i]) | 0)) | 0)) |
                    0;
                var t2 = ((((state0 >>> 2) | (state0 << 30)) ^
                    ((state0 >>> 13) | (state0 << 19)) ^
                    ((state0 >>> 22) | (state0 << 10))) +
                    ((state0 & state1) ^ (state0 & state2) ^ (state1 & state2))) |
                    0;
                state7 = state6;
                state6 = state5;
                state5 = state4;
                state4 = (state3 + t1) | 0;
                state3 = state2;
                state2 = state1;
                state1 = state0;
                state0 = (t1 + t2) | 0;
            }
            state[0] += state0;
            state[1] += state1;
            state[2] += state2;
            state[3] += state3;
            state[4] += state4;
            state[5] += state5;
            state[6] += state6;
            state[7] += state7;
        };
        return RawSha256;
    }());

    var Sha256$1 = /** @class */ (function () {
        function Sha256(secret) {
            this.secret = secret;
            this.hash = new RawSha256$3();
            this.reset();
        }
        Sha256.prototype.update = function (toHash) {
            if (isEmptyData$6(toHash) || this.error) {
                return;
            }
            try {
                this.hash.update(convertToBuffer$3(toHash));
            }
            catch (e) {
                this.error = e;
            }
        };
        /* This synchronous method keeps compatibility
         * with the v2 aws-sdk.
         */
        Sha256.prototype.digestSync = function () {
            if (this.error) {
                throw this.error;
            }
            if (this.outer) {
                if (!this.outer.finished) {
                    this.outer.update(this.hash.digest());
                }
                return this.outer.digest();
            }
            return this.hash.digest();
        };
        /* The underlying digest method here is synchronous.
         * To keep the same interface with the other hash functions
         * the default is to expose this as an async method.
         * However, it can sometimes be useful to have a sync method.
         */
        Sha256.prototype.digest = function () {
            return __awaiter$a(this, void 0, void 0, function () {
                return __generator$a(this, function (_a) {
                    return [2 /*return*/, this.digestSync()];
                });
            });
        };
        Sha256.prototype.reset = function () {
            this.hash = new RawSha256$3();
            if (this.secret) {
                this.outer = new RawSha256$3();
                var inner = bufferFromSecret(this.secret);
                var outer = new Uint8Array(BLOCK_SIZE);
                outer.set(inner);
                for (var i = 0; i < BLOCK_SIZE; i++) {
                    inner[i] ^= 0x36;
                    outer[i] ^= 0x5c;
                }
                this.hash.update(inner);
                this.outer.update(outer);
                // overwrite the copied key in memory
                for (var i = 0; i < inner.byteLength; i++) {
                    inner[i] = 0;
                }
            }
        };
        return Sha256;
    }());
    function bufferFromSecret(secret) {
        var input = convertToBuffer$3(secret);
        if (input.byteLength > BLOCK_SIZE) {
            var bufferHash = new RawSha256$3();
            bufferHash.update(input);
            input = bufferHash.digest();
        }
        var buffer = new Uint8Array(BLOCK_SIZE);
        buffer.set(input);
        return buffer;
    }

    var subtleCryptoMethods = [
        "decrypt",
        "digest",
        "encrypt",
        "exportKey",
        "generateKey",
        "importKey",
        "sign",
        "verify"
    ];
    function supportsWebCrypto$3(window) {
        if (supportsSecureRandom(window) &&
            typeof window.crypto.subtle === "object") {
            var subtle = window.crypto.subtle;
            return supportsSubtleCrypto(subtle);
        }
        return false;
    }
    function supportsSecureRandom(window) {
        if (typeof window === "object" && typeof window.crypto === "object") {
            var getRandomValues = window.crypto.getRandomValues;
            return typeof getRandomValues === "function";
        }
        return false;
    }
    function supportsSubtleCrypto(subtle) {
        return (subtle &&
            subtleCryptoMethods.every(function (methodName) { return typeof subtle[methodName] === "function"; }));
    }

    var Sha256 = /** @class */ (function () {
        function Sha256(secret) {
            if (supportsWebCrypto$3(locateWindow())) {
                this.hash = new Sha256$2(secret);
            }
            else {
                this.hash = new Sha256$1(secret);
            }
        }
        Sha256.prototype.update = function (data, encoding) {
            this.hash.update(convertToBuffer$3(data));
        };
        Sha256.prototype.digest = function () {
            return this.hash.digest();
        };
        Sha256.prototype.reset = function () {
            this.hash.reset();
        };
        return Sha256;
    }());

    var es5$1 = {exports: {}};

    var es5 = es5$1.exports;

    var hasRequiredEs5;

    function requireEs5 () {
    	if (hasRequiredEs5) return es5$1.exports;
    	hasRequiredEs5 = 1;
    	(function (module, exports) {
    		!function(e,t){module.exports=t();}(es5,(function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n});},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0});},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=90)}({17:function(e,t,r){t.__esModule=!0,t.default=void 0;var n=r(18),i=function(){function e(){}return e.getFirstMatch=function(e,t){var r=t.match(e);return r&&r.length>0&&r[1]||""},e.getSecondMatch=function(e,t){var r=t.match(e);return r&&r.length>1&&r[2]||""},e.matchAndReturnConst=function(e,t,r){if(e.test(t))return r},e.getWindowsVersionName=function(e){switch(e){case"NT":return "NT";case"XP":return "XP";case"NT 5.0":return "2000";case"NT 5.1":return "XP";case"NT 5.2":return "2003";case"NT 6.0":return "Vista";case"NT 6.1":return "7";case"NT 6.2":return "8";case"NT 6.3":return "8.1";case"NT 10.0":return "10";default:return}},e.getMacOSVersionName=function(e){var t=e.split(".").splice(0,2).map((function(e){return parseInt(e,10)||0}));if(t.push(0),10===t[0])switch(t[1]){case 5:return "Leopard";case 6:return "Snow Leopard";case 7:return "Lion";case 8:return "Mountain Lion";case 9:return "Mavericks";case 10:return "Yosemite";case 11:return "El Capitan";case 12:return "Sierra";case 13:return "High Sierra";case 14:return "Mojave";case 15:return "Catalina";default:return}},e.getAndroidVersionName=function(e){var t=e.split(".").splice(0,2).map((function(e){return parseInt(e,10)||0}));if(t.push(0),!(1===t[0]&&t[1]<5))return 1===t[0]&&t[1]<6?"Cupcake":1===t[0]&&t[1]>=6?"Donut":2===t[0]&&t[1]<2?"Eclair":2===t[0]&&2===t[1]?"Froyo":2===t[0]&&t[1]>2?"Gingerbread":3===t[0]?"Honeycomb":4===t[0]&&t[1]<1?"Ice Cream Sandwich":4===t[0]&&t[1]<4?"Jelly Bean":4===t[0]&&t[1]>=4?"KitKat":5===t[0]?"Lollipop":6===t[0]?"Marshmallow":7===t[0]?"Nougat":8===t[0]?"Oreo":9===t[0]?"Pie":void 0},e.getVersionPrecision=function(e){return e.split(".").length},e.compareVersions=function(t,r,n){void 0===n&&(n=!1);var i=e.getVersionPrecision(t),s=e.getVersionPrecision(r),a=Math.max(i,s),o=0,u=e.map([t,r],(function(t){var r=a-e.getVersionPrecision(t),n=t+new Array(r+1).join(".0");return e.map(n.split("."),(function(e){return new Array(20-e.length).join("0")+e})).reverse()}));for(n&&(o=a-Math.min(i,s)),a-=1;a>=o;){if(u[0][a]>u[1][a])return 1;if(u[0][a]===u[1][a]){if(a===o)return 0;a-=1;}else if(u[0][a]<u[1][a])return -1}},e.map=function(e,t){var r,n=[];if(Array.prototype.map)return Array.prototype.map.call(e,t);for(r=0;r<e.length;r+=1)n.push(t(e[r]));return n},e.find=function(e,t){var r,n;if(Array.prototype.find)return Array.prototype.find.call(e,t);for(r=0,n=e.length;r<n;r+=1){var i=e[r];if(t(i,r))return i}},e.assign=function(e){for(var t,r,n=e,i=arguments.length,s=new Array(i>1?i-1:0),a=1;a<i;a++)s[a-1]=arguments[a];if(Object.assign)return Object.assign.apply(Object,[e].concat(s));var o=function(){var e=s[t];"object"==typeof e&&null!==e&&Object.keys(e).forEach((function(t){n[t]=e[t];}));};for(t=0,r=s.length;t<r;t+=1)o();return e},e.getBrowserAlias=function(e){return n.BROWSER_ALIASES_MAP[e]},e.getBrowserTypeByAlias=function(e){return n.BROWSER_MAP[e]||""},e}();t.default=i,e.exports=t.default;},18:function(e,t,r){t.__esModule=!0,t.ENGINE_MAP=t.OS_MAP=t.PLATFORMS_MAP=t.BROWSER_MAP=t.BROWSER_ALIASES_MAP=void 0;t.BROWSER_ALIASES_MAP={"Amazon Silk":"amazon_silk","Android Browser":"android",Bada:"bada",BlackBerry:"blackberry",Chrome:"chrome",Chromium:"chromium",Electron:"electron",Epiphany:"epiphany",Firefox:"firefox",Focus:"focus",Generic:"generic","Google Search":"google_search",Googlebot:"googlebot","Internet Explorer":"ie","K-Meleon":"k_meleon",Maxthon:"maxthon","Microsoft Edge":"edge","MZ Browser":"mz","NAVER Whale Browser":"naver",Opera:"opera","Opera Coast":"opera_coast",PhantomJS:"phantomjs",Puffin:"puffin",QupZilla:"qupzilla",QQ:"qq",QQLite:"qqlite",Safari:"safari",Sailfish:"sailfish","Samsung Internet for Android":"samsung_internet",SeaMonkey:"seamonkey",Sleipnir:"sleipnir",Swing:"swing",Tizen:"tizen","UC Browser":"uc",Vivaldi:"vivaldi","WebOS Browser":"webos",WeChat:"wechat","Yandex Browser":"yandex",Roku:"roku"};t.BROWSER_MAP={amazon_silk:"Amazon Silk",android:"Android Browser",bada:"Bada",blackberry:"BlackBerry",chrome:"Chrome",chromium:"Chromium",electron:"Electron",epiphany:"Epiphany",firefox:"Firefox",focus:"Focus",generic:"Generic",googlebot:"Googlebot",google_search:"Google Search",ie:"Internet Explorer",k_meleon:"K-Meleon",maxthon:"Maxthon",edge:"Microsoft Edge",mz:"MZ Browser",naver:"NAVER Whale Browser",opera:"Opera",opera_coast:"Opera Coast",phantomjs:"PhantomJS",puffin:"Puffin",qupzilla:"QupZilla",qq:"QQ Browser",qqlite:"QQ Browser Lite",safari:"Safari",sailfish:"Sailfish",samsung_internet:"Samsung Internet for Android",seamonkey:"SeaMonkey",sleipnir:"Sleipnir",swing:"Swing",tizen:"Tizen",uc:"UC Browser",vivaldi:"Vivaldi",webos:"WebOS Browser",wechat:"WeChat",yandex:"Yandex Browser"};t.PLATFORMS_MAP={tablet:"tablet",mobile:"mobile",desktop:"desktop",tv:"tv"};t.OS_MAP={WindowsPhone:"Windows Phone",Windows:"Windows",MacOS:"macOS",iOS:"iOS",Android:"Android",WebOS:"WebOS",BlackBerry:"BlackBerry",Bada:"Bada",Tizen:"Tizen",Linux:"Linux",ChromeOS:"Chrome OS",PlayStation4:"PlayStation 4",Roku:"Roku"};t.ENGINE_MAP={EdgeHTML:"EdgeHTML",Blink:"Blink",Trident:"Trident",Presto:"Presto",Gecko:"Gecko",WebKit:"WebKit"};},90:function(e,t,r){t.__esModule=!0,t.default=void 0;var n,i=(n=r(91))&&n.__esModule?n:{default:n},s=r(18);function a(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n);}}var o=function(){function e(){}var t,r,n;return e.getParser=function(e,t){if(void 0===t&&(t=!1),"string"!=typeof e)throw new Error("UserAgent should be a string");return new i.default(e,t)},e.parse=function(e){return new i.default(e).getResult()},t=e,n=[{key:"BROWSER_MAP",get:function(){return s.BROWSER_MAP}},{key:"ENGINE_MAP",get:function(){return s.ENGINE_MAP}},{key:"OS_MAP",get:function(){return s.OS_MAP}},{key:"PLATFORMS_MAP",get:function(){return s.PLATFORMS_MAP}}],(r=null)&&a(t.prototype,r),n&&a(t,n),e}();t.default=o,e.exports=t.default;},91:function(e,t,r){t.__esModule=!0,t.default=void 0;var n=u(r(92)),i=u(r(93)),s=u(r(94)),a=u(r(95)),o=u(r(17));function u(e){return e&&e.__esModule?e:{default:e}}var d=function(){function e(e,t){if(void 0===t&&(t=!1),null==e||""===e)throw new Error("UserAgent parameter can't be empty");this._ua=e,this.parsedResult={},!0!==t&&this.parse();}var t=e.prototype;return t.getUA=function(){return this._ua},t.test=function(e){return e.test(this._ua)},t.parseBrowser=function(){var e=this;this.parsedResult.browser={};var t=o.default.find(n.default,(function(t){if("function"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error("Browser's test function is not valid")}));return t&&(this.parsedResult.browser=t.describe(this.getUA())),this.parsedResult.browser},t.getBrowser=function(){return this.parsedResult.browser?this.parsedResult.browser:this.parseBrowser()},t.getBrowserName=function(e){return e?String(this.getBrowser().name).toLowerCase()||"":this.getBrowser().name||""},t.getBrowserVersion=function(){return this.getBrowser().version},t.getOS=function(){return this.parsedResult.os?this.parsedResult.os:this.parseOS()},t.parseOS=function(){var e=this;this.parsedResult.os={};var t=o.default.find(i.default,(function(t){if("function"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error("Browser's test function is not valid")}));return t&&(this.parsedResult.os=t.describe(this.getUA())),this.parsedResult.os},t.getOSName=function(e){var t=this.getOS().name;return e?String(t).toLowerCase()||"":t||""},t.getOSVersion=function(){return this.getOS().version},t.getPlatform=function(){return this.parsedResult.platform?this.parsedResult.platform:this.parsePlatform()},t.getPlatformType=function(e){void 0===e&&(e=!1);var t=this.getPlatform().type;return e?String(t).toLowerCase()||"":t||""},t.parsePlatform=function(){var e=this;this.parsedResult.platform={};var t=o.default.find(s.default,(function(t){if("function"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error("Browser's test function is not valid")}));return t&&(this.parsedResult.platform=t.describe(this.getUA())),this.parsedResult.platform},t.getEngine=function(){return this.parsedResult.engine?this.parsedResult.engine:this.parseEngine()},t.getEngineName=function(e){return e?String(this.getEngine().name).toLowerCase()||"":this.getEngine().name||""},t.parseEngine=function(){var e=this;this.parsedResult.engine={};var t=o.default.find(a.default,(function(t){if("function"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error("Browser's test function is not valid")}));return t&&(this.parsedResult.engine=t.describe(this.getUA())),this.parsedResult.engine},t.parse=function(){return this.parseBrowser(),this.parseOS(),this.parsePlatform(),this.parseEngine(),this},t.getResult=function(){return o.default.assign({},this.parsedResult)},t.satisfies=function(e){var t=this,r={},n=0,i={},s=0;if(Object.keys(e).forEach((function(t){var a=e[t];"string"==typeof a?(i[t]=a,s+=1):"object"==typeof a&&(r[t]=a,n+=1);})),n>0){var a=Object.keys(r),u=o.default.find(a,(function(e){return t.isOS(e)}));if(u){var d=this.satisfies(r[u]);if(void 0!==d)return d}var c=o.default.find(a,(function(e){return t.isPlatform(e)}));if(c){var f=this.satisfies(r[c]);if(void 0!==f)return f}}if(s>0){var l=Object.keys(i),h=o.default.find(l,(function(e){return t.isBrowser(e,!0)}));if(void 0!==h)return this.compareVersion(i[h])}},t.isBrowser=function(e,t){void 0===t&&(t=!1);var r=this.getBrowserName().toLowerCase(),n=e.toLowerCase(),i=o.default.getBrowserTypeByAlias(n);return t&&i&&(n=i.toLowerCase()),n===r},t.compareVersion=function(e){var t=[0],r=e,n=!1,i=this.getBrowserVersion();if("string"==typeof i)return ">"===e[0]||"<"===e[0]?(r=e.substr(1),"="===e[1]?(n=!0,r=e.substr(2)):t=[],">"===e[0]?t.push(1):t.push(-1)):"="===e[0]?r=e.substr(1):"~"===e[0]&&(n=!0,r=e.substr(1)),t.indexOf(o.default.compareVersions(i,r,n))>-1},t.isOS=function(e){return this.getOSName(!0)===String(e).toLowerCase()},t.isPlatform=function(e){return this.getPlatformType(!0)===String(e).toLowerCase()},t.isEngine=function(e){return this.getEngineName(!0)===String(e).toLowerCase()},t.is=function(e,t){return void 0===t&&(t=!1),this.isBrowser(e,t)||this.isOS(e)||this.isPlatform(e)},t.some=function(e){var t=this;return void 0===e&&(e=[]),e.some((function(e){return t.is(e)}))},e}();t.default=d,e.exports=t.default;},92:function(e,t,r){t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n};var s=/version\/(\d+(\.?_?\d+)+)/i,a=[{test:[/googlebot/i],describe:function(e){var t={name:"Googlebot"},r=i.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/opera/i],describe:function(e){var t={name:"Opera"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/opr\/|opios/i],describe:function(e){var t={name:"Opera"},r=i.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/SamsungBrowser/i],describe:function(e){var t={name:"Samsung Internet for Android"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Whale/i],describe:function(e){var t={name:"NAVER Whale Browser"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/MZBrowser/i],describe:function(e){var t={name:"MZ Browser"},r=i.default.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/focus/i],describe:function(e){var t={name:"Focus"},r=i.default.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/swing/i],describe:function(e){var t={name:"Swing"},r=i.default.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/coast/i],describe:function(e){var t={name:"Opera Coast"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/opt\/\d+(?:.?_?\d+)+/i],describe:function(e){var t={name:"Opera Touch"},r=i.default.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/yabrowser/i],describe:function(e){var t={name:"Yandex Browser"},r=i.default.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/ucbrowser/i],describe:function(e){var t={name:"UC Browser"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Maxthon|mxios/i],describe:function(e){var t={name:"Maxthon"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/epiphany/i],describe:function(e){var t={name:"Epiphany"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/puffin/i],describe:function(e){var t={name:"Puffin"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sleipnir/i],describe:function(e){var t={name:"Sleipnir"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/k-meleon/i],describe:function(e){var t={name:"K-Meleon"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/micromessenger/i],describe:function(e){var t={name:"WeChat"},r=i.default.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/qqbrowser/i],describe:function(e){var t={name:/qqbrowserlite/i.test(e)?"QQ Browser Lite":"QQ Browser"},r=i.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/msie|trident/i],describe:function(e){var t={name:"Internet Explorer"},r=i.default.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/\sedg\//i],describe:function(e){var t={name:"Microsoft Edge"},r=i.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/edg([ea]|ios)/i],describe:function(e){var t={name:"Microsoft Edge"},r=i.default.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/vivaldi/i],describe:function(e){var t={name:"Vivaldi"},r=i.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/seamonkey/i],describe:function(e){var t={name:"SeaMonkey"},r=i.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sailfish/i],describe:function(e){var t={name:"Sailfish"},r=i.default.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i,e);return r&&(t.version=r),t}},{test:[/silk/i],describe:function(e){var t={name:"Amazon Silk"},r=i.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/phantom/i],describe:function(e){var t={name:"PhantomJS"},r=i.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/slimerjs/i],describe:function(e){var t={name:"SlimerJS"},r=i.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/blackberry|\bbb\d+/i,/rim\stablet/i],describe:function(e){var t={name:"BlackBerry"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(web|hpw)[o0]s/i],describe:function(e){var t={name:"WebOS Browser"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/bada/i],describe:function(e){var t={name:"Bada"},r=i.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/tizen/i],describe:function(e){var t={name:"Tizen"},r=i.default.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/qupzilla/i],describe:function(e){var t={name:"QupZilla"},r=i.default.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/firefox|iceweasel|fxios/i],describe:function(e){var t={name:"Firefox"},r=i.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/electron/i],describe:function(e){var t={name:"Electron"},r=i.default.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/MiuiBrowser/i],describe:function(e){var t={name:"Miui"},r=i.default.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/chromium/i],describe:function(e){var t={name:"Chromium"},r=i.default.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/chrome|crios|crmo/i],describe:function(e){var t={name:"Chrome"},r=i.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/GSA/i],describe:function(e){var t={name:"Google Search"},r=i.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){var t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe:function(e){var t={name:"Android Browser"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/playstation 4/i],describe:function(e){var t={name:"PlayStation 4"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/safari|applewebkit/i],describe:function(e){var t={name:"Safari"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/.*/i],describe:function(e){var t=-1!==e.search("\\(")?/^(.*)\/(.*)[ \t]\((.*)/:/^(.*)\/(.*) /;return {name:i.default.getFirstMatch(t,e),version:i.default.getSecondMatch(t,e)}}}];t.default=a,e.exports=t.default;},93:function(e,t,r){t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:[/Roku\/DVP/],describe:function(e){var t=i.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i,e);return {name:s.OS_MAP.Roku,version:t}}},{test:[/windows phone/i],describe:function(e){var t=i.default.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i,e);return {name:s.OS_MAP.WindowsPhone,version:t}}},{test:[/windows /i],describe:function(e){var t=i.default.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i,e),r=i.default.getWindowsVersionName(t);return {name:s.OS_MAP.Windows,version:t,versionName:r}}},{test:[/Macintosh(.*?) FxiOS(.*?)\//],describe:function(e){var t={name:s.OS_MAP.iOS},r=i.default.getSecondMatch(/(Version\/)(\d[\d.]+)/,e);return r&&(t.version=r),t}},{test:[/macintosh/i],describe:function(e){var t=i.default.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i,e).replace(/[_\s]/g,"."),r=i.default.getMacOSVersionName(t),n={name:s.OS_MAP.MacOS,version:t};return r&&(n.versionName=r),n}},{test:[/(ipod|iphone|ipad)/i],describe:function(e){var t=i.default.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i,e).replace(/[_\s]/g,".");return {name:s.OS_MAP.iOS,version:t}}},{test:function(e){var t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe:function(e){var t=i.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i,e),r=i.default.getAndroidVersionName(t),n={name:s.OS_MAP.Android,version:t};return r&&(n.versionName=r),n}},{test:[/(web|hpw)[o0]s/i],describe:function(e){var t=i.default.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i,e),r={name:s.OS_MAP.WebOS};return t&&t.length&&(r.version=t),r}},{test:[/blackberry|\bbb\d+/i,/rim\stablet/i],describe:function(e){var t=i.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i,e)||i.default.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i,e)||i.default.getFirstMatch(/\bbb(\d+)/i,e);return {name:s.OS_MAP.BlackBerry,version:t}}},{test:[/bada/i],describe:function(e){var t=i.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i,e);return {name:s.OS_MAP.Bada,version:t}}},{test:[/tizen/i],describe:function(e){var t=i.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i,e);return {name:s.OS_MAP.Tizen,version:t}}},{test:[/linux/i],describe:function(){return {name:s.OS_MAP.Linux}}},{test:[/CrOS/],describe:function(){return {name:s.OS_MAP.ChromeOS}}},{test:[/PlayStation 4/],describe:function(e){var t=i.default.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i,e);return {name:s.OS_MAP.PlayStation4,version:t}}}];t.default=a,e.exports=t.default;},94:function(e,t,r){t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:[/googlebot/i],describe:function(){return {type:"bot",vendor:"Google"}}},{test:[/huawei/i],describe:function(e){var t=i.default.getFirstMatch(/(can-l01)/i,e)&&"Nova",r={type:s.PLATFORMS_MAP.mobile,vendor:"Huawei"};return t&&(r.model=t),r}},{test:[/nexus\s*(?:7|8|9|10).*/i],describe:function(){return {type:s.PLATFORMS_MAP.tablet,vendor:"Nexus"}}},{test:[/ipad/i],describe:function(){return {type:s.PLATFORMS_MAP.tablet,vendor:"Apple",model:"iPad"}}},{test:[/Macintosh(.*?) FxiOS(.*?)\//],describe:function(){return {type:s.PLATFORMS_MAP.tablet,vendor:"Apple",model:"iPad"}}},{test:[/kftt build/i],describe:function(){return {type:s.PLATFORMS_MAP.tablet,vendor:"Amazon",model:"Kindle Fire HD 7"}}},{test:[/silk/i],describe:function(){return {type:s.PLATFORMS_MAP.tablet,vendor:"Amazon"}}},{test:[/tablet(?! pc)/i],describe:function(){return {type:s.PLATFORMS_MAP.tablet}}},{test:function(e){var t=e.test(/ipod|iphone/i),r=e.test(/like (ipod|iphone)/i);return t&&!r},describe:function(e){var t=i.default.getFirstMatch(/(ipod|iphone)/i,e);return {type:s.PLATFORMS_MAP.mobile,vendor:"Apple",model:t}}},{test:[/nexus\s*[0-6].*/i,/galaxy nexus/i],describe:function(){return {type:s.PLATFORMS_MAP.mobile,vendor:"Nexus"}}},{test:[/[^-]mobi/i],describe:function(){return {type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return "blackberry"===e.getBrowserName(!0)},describe:function(){return {type:s.PLATFORMS_MAP.mobile,vendor:"BlackBerry"}}},{test:function(e){return "bada"===e.getBrowserName(!0)},describe:function(){return {type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return "windows phone"===e.getBrowserName()},describe:function(){return {type:s.PLATFORMS_MAP.mobile,vendor:"Microsoft"}}},{test:function(e){var t=Number(String(e.getOSVersion()).split(".")[0]);return "android"===e.getOSName(!0)&&t>=3},describe:function(){return {type:s.PLATFORMS_MAP.tablet}}},{test:function(e){return "android"===e.getOSName(!0)},describe:function(){return {type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return "macos"===e.getOSName(!0)},describe:function(){return {type:s.PLATFORMS_MAP.desktop,vendor:"Apple"}}},{test:function(e){return "windows"===e.getOSName(!0)},describe:function(){return {type:s.PLATFORMS_MAP.desktop}}},{test:function(e){return "linux"===e.getOSName(!0)},describe:function(){return {type:s.PLATFORMS_MAP.desktop}}},{test:function(e){return "playstation 4"===e.getOSName(!0)},describe:function(){return {type:s.PLATFORMS_MAP.tv}}},{test:function(e){return "roku"===e.getOSName(!0)},describe:function(){return {type:s.PLATFORMS_MAP.tv}}}];t.default=a,e.exports=t.default;},95:function(e,t,r){t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:function(e){return "microsoft edge"===e.getBrowserName(!0)},describe:function(e){if(/\sedg\//i.test(e))return {name:s.ENGINE_MAP.Blink};var t=i.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i,e);return {name:s.ENGINE_MAP.EdgeHTML,version:t}}},{test:[/trident/i],describe:function(e){var t={name:s.ENGINE_MAP.Trident},r=i.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){return e.test(/presto/i)},describe:function(e){var t={name:s.ENGINE_MAP.Presto},r=i.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){var t=e.test(/gecko/i),r=e.test(/like gecko/i);return t&&!r},describe:function(e){var t={name:s.ENGINE_MAP.Gecko},r=i.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(apple)?webkit\/537\.36/i],describe:function(){return {name:s.ENGINE_MAP.Blink}}},{test:[/(apple)?webkit/i],describe:function(e){var t={name:s.ENGINE_MAP.WebKit},r=i.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}}];t.default=a,e.exports=t.default;}})})); 
    	} (es5$1));
    	return es5$1.exports;
    }

    var es5Exports = requireEs5();
    var bowser = /*@__PURE__*/getDefaultExportFromCjs(es5Exports);

    const defaultUserAgent$3 = ({ serviceId, clientVersion }) => async () => {
        const parsedUA = typeof window !== "undefined" && window?.navigator?.userAgent
            ? bowser.parse(window.navigator.userAgent)
            : undefined;
        const sections = [
            ["aws-sdk-js", clientVersion],
            ["ua", "2.0"],
            [`os/${parsedUA?.os?.name || "other"}`, parsedUA?.os?.version],
            ["lang/js"],
            ["md/browser", `${parsedUA?.browser?.name ?? "unknown"}_${parsedUA?.browser?.version ?? "unknown"}`],
        ];
        if (serviceId) {
            sections.push([`api/${serviceId}`, clientVersion]);
        }
        return sections;
    };

    const invalidProvider$3 = (message) => () => Promise.reject(message);

    const TEXT_ENCODER$3 = typeof TextEncoder == "function" ? new TextEncoder() : null;
    const calculateBodyLength$3 = (body) => {
        if (typeof body === "string") {
            if (TEXT_ENCODER$3) {
                return TEXT_ENCODER$3.encode(body).byteLength;
            }
            let len = body.length;
            for (let i = len - 1; i >= 0; i--) {
                const code = body.charCodeAt(i);
                if (code > 0x7f && code <= 0x7ff)
                    len++;
                else if (code > 0x7ff && code <= 0xffff)
                    len += 2;
                if (code >= 0xdc00 && code <= 0xdfff)
                    i--;
            }
            return len;
        }
        else if (typeof body.byteLength === "number") {
            return body.byteLength;
        }
        else if (typeof body.size === "number") {
            return body.size;
        }
        throw new Error(`Body Length computation failed for ${body}`);
    };

    const s$2 = "required", t$2 = "fn", u$2 = "argv", v$2 = "ref";
    const a$2 = true, b$2 = "isSet", c$2 = "booleanEquals", d$2 = "error", e$2 = "endpoint", f$2 = "tree", g$2 = "PartitionResult", h$2 = { [s$2]: false, "type": "String" }, i$2 = { [s$2]: true, "default": false, "type": "Boolean" }, j$2 = { [v$2]: "Endpoint" }, k$2 = { [t$2]: c$2, [u$2]: [{ [v$2]: "UseFIPS" }, true] }, l$2 = { [t$2]: c$2, [u$2]: [{ [v$2]: "UseDualStack" }, true] }, m$2 = {}, n$2 = { [t$2]: "getAttr", [u$2]: [{ [v$2]: g$2 }, "supportsFIPS"] }, o$2 = { [t$2]: c$2, [u$2]: [true, { [t$2]: "getAttr", [u$2]: [{ [v$2]: g$2 }, "supportsDualStack"] }] }, p$2 = [k$2], q$2 = [l$2], r$2 = [{ [v$2]: "Region" }];
    const _data$2 = { version: "1.0", parameters: { Region: h$2, UseDualStack: i$2, UseFIPS: i$2, Endpoint: h$2 }, rules: [{ conditions: [{ [t$2]: b$2, [u$2]: [j$2] }], rules: [{ conditions: p$2, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d$2 }, { conditions: q$2, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d$2 }, { endpoint: { url: j$2, properties: m$2, headers: m$2 }, type: e$2 }], type: f$2 }, { conditions: [{ [t$2]: b$2, [u$2]: r$2 }], rules: [{ conditions: [{ [t$2]: "aws.partition", [u$2]: r$2, assign: g$2 }], rules: [{ conditions: [k$2, l$2], rules: [{ conditions: [{ [t$2]: c$2, [u$2]: [a$2, n$2] }, o$2], rules: [{ endpoint: { url: "https://geo-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: m$2, headers: m$2 }, type: e$2 }], type: f$2 }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d$2 }], type: f$2 }, { conditions: p$2, rules: [{ conditions: [{ [t$2]: c$2, [u$2]: [n$2, a$2] }], rules: [{ endpoint: { url: "https://geo-fips.{Region}.{PartitionResult#dnsSuffix}", properties: m$2, headers: m$2 }, type: e$2 }], type: f$2 }, { error: "FIPS is enabled but this partition does not support FIPS", type: d$2 }], type: f$2 }, { conditions: q$2, rules: [{ conditions: [o$2], rules: [{ endpoint: { url: "https://geo.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: m$2, headers: m$2 }, type: e$2 }], type: f$2 }, { error: "DualStack is enabled but this partition does not support DualStack", type: d$2 }], type: f$2 }, { endpoint: { url: "https://geo.{Region}.{PartitionResult#dnsSuffix}", properties: m$2, headers: m$2 }, type: e$2 }], type: f$2 }], type: f$2 }, { error: "Invalid Configuration: Missing Region", type: d$2 }] };
    const ruleSet$2 = _data$2;

    const defaultEndpointResolver$2 = (endpointParams, context = {}) => {
        return resolveEndpoint(ruleSet$2, {
            endpointParams: endpointParams,
            logger: context.logger,
        });
    };
    customEndpointFunctions.aws = awsEndpointFunctions;

    const getRuntimeConfig$b = (config) => {
        return {
            apiVersion: "2020-11-19",
            base64Decoder: config?.base64Decoder ?? fromBase64$3,
            base64Encoder: config?.base64Encoder ?? toBase64$3,
            disableHostPrefix: config?.disableHostPrefix ?? false,
            endpointProvider: config?.endpointProvider ?? defaultEndpointResolver$2,
            extensions: config?.extensions ?? [],
            httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? defaultLocationHttpAuthSchemeProvider,
            httpAuthSchemes: config?.httpAuthSchemes ?? [
                {
                    schemeId: "aws.auth#sigv4",
                    identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
                    signer: new AwsSdkSigV4Signer(),
                },
            ],
            logger: config?.logger ?? new NoOpLogger$3(),
            serviceId: config?.serviceId ?? "Location",
            urlParser: config?.urlParser ?? parseUrl$3,
            utf8Decoder: config?.utf8Decoder ?? fromUtf8$9,
            utf8Encoder: config?.utf8Encoder ?? toUtf8$6,
        };
    };

    class ProviderError extends Error {
        constructor(message, options = true) {
            let logger;
            let tryNextLink = true;
            if (typeof options === "boolean") {
                logger = undefined;
                tryNextLink = options;
            }
            else if (options != null && typeof options === "object") {
                logger = options.logger;
                tryNextLink = options.tryNextLink ?? true;
            }
            super(message);
            this.name = "ProviderError";
            this.tryNextLink = tryNextLink;
            Object.setPrototypeOf(this, ProviderError.prototype);
            logger?.debug?.(`@smithy/property-provider ${tryNextLink ? "->" : "(!)"} ${message}`);
        }
        static from(error, options = true) {
            return Object.assign(new this(error.message, options), error);
        }
    }

    class CredentialsProviderError extends ProviderError {
        constructor(message, options = true) {
            super(message, options);
            this.name = "CredentialsProviderError";
            Object.setPrototypeOf(this, CredentialsProviderError.prototype);
        }
    }

    const memoize$4 = (provider, isExpired, requiresRefresh) => {
        let resolved;
        let pending;
        let hasResult;
        let isConstant = false;
        const coalesceProvider = async () => {
            if (!pending) {
                pending = provider();
            }
            try {
                resolved = await pending;
                hasResult = true;
                isConstant = false;
            }
            finally {
                pending = undefined;
            }
            return resolved;
        };
        {
            return async (options) => {
                if (!hasResult || options?.forceRefresh) {
                    resolved = await coalesceProvider();
                }
                return resolved;
            };
        }
    };

    const DEFAULTS_MODE_OPTIONS$3 = ["in-region", "cross-region", "mobile", "standard", "legacy"];

    const resolveDefaultsModeConfig$3 = ({ defaultsMode, } = {}) => memoize$4(async () => {
        const mode = typeof defaultsMode === "function" ? await defaultsMode() : defaultsMode;
        switch (mode?.toLowerCase()) {
            case "auto":
                return Promise.resolve(isMobileBrowser$3() ? "mobile" : "standard");
            case "mobile":
            case "in-region":
            case "cross-region":
            case "standard":
            case "legacy":
                return Promise.resolve(mode?.toLocaleLowerCase());
            case undefined:
                return Promise.resolve("legacy");
            default:
                throw new Error(`Invalid parameter for "defaultsMode", expect ${DEFAULTS_MODE_OPTIONS$3.join(", ")}, got ${mode}`);
        }
    });
    const isMobileBrowser$3 = () => {
        const parsedUA = typeof window !== "undefined" && window?.navigator?.userAgent
            ? bowser.parse(window.navigator.userAgent)
            : undefined;
        const platform = parsedUA?.platform?.type;
        return platform === "tablet" || platform === "mobile";
    };

    const getRuntimeConfig$a = (config) => {
        const defaultsMode = resolveDefaultsModeConfig$3(config);
        const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode$3);
        const clientSharedValues = getRuntimeConfig$b(config);
        return {
            ...clientSharedValues,
            ...config,
            runtime: "browser",
            defaultsMode,
            bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength$3,
            credentialDefaultProvider: config?.credentialDefaultProvider ?? ((_) => () => Promise.reject(new Error("Credential is missing"))),
            defaultUserAgentProvider: config?.defaultUserAgentProvider ??
                defaultUserAgent$3({ serviceId: clientSharedValues.serviceId, clientVersion: packageInfo$5.version }),
            maxAttempts: config?.maxAttempts ?? DEFAULT_MAX_ATTEMPTS$3,
            region: config?.region ?? invalidProvider$3("Region is missing"),
            requestHandler: FetchHttpHandler$3.create(config?.requestHandler ?? defaultConfigProvider),
            retryMode: config?.retryMode ?? (async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE$3),
            sha256: config?.sha256 ?? Sha256,
            streamCollector: config?.streamCollector ?? streamCollector$3,
            useDualstackEndpoint: config?.useDualstackEndpoint ?? (() => Promise.resolve(DEFAULT_USE_DUALSTACK_ENDPOINT$3)),
            useFipsEndpoint: config?.useFipsEndpoint ?? (() => Promise.resolve(DEFAULT_USE_FIPS_ENDPOINT$3)),
        };
    };

    const getAwsRegionExtensionConfiguration$3 = (runtimeConfig) => {
        let runtimeConfigRegion = async () => {
            if (runtimeConfig.region === undefined) {
                throw new Error("Region is missing from runtimeConfig");
            }
            const region = runtimeConfig.region;
            if (typeof region === "string") {
                return region;
            }
            return region();
        };
        return {
            setRegion(region) {
                runtimeConfigRegion = region;
            },
            region() {
                return runtimeConfigRegion;
            },
        };
    };
    const resolveAwsRegionExtensionConfiguration$3 = (awsRegionExtensionConfiguration) => {
        return {
            region: awsRegionExtensionConfiguration.region(),
        };
    };

    const getHttpAuthExtensionConfiguration$2 = (runtimeConfig) => {
        const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
        let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
        let _credentials = runtimeConfig.credentials;
        return {
            setHttpAuthScheme(httpAuthScheme) {
                const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
                if (index === -1) {
                    _httpAuthSchemes.push(httpAuthScheme);
                }
                else {
                    _httpAuthSchemes.splice(index, 1, httpAuthScheme);
                }
            },
            httpAuthSchemes() {
                return _httpAuthSchemes;
            },
            setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
                _httpAuthSchemeProvider = httpAuthSchemeProvider;
            },
            httpAuthSchemeProvider() {
                return _httpAuthSchemeProvider;
            },
            setCredentials(credentials) {
                _credentials = credentials;
            },
            credentials() {
                return _credentials;
            },
        };
    };
    const resolveHttpAuthRuntimeConfig$2 = (config) => {
        return {
            httpAuthSchemes: config.httpAuthSchemes(),
            httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
            credentials: config.credentials(),
        };
    };

    const asPartial$5 = (t) => t;
    const resolveRuntimeExtensions$5 = (runtimeConfig, extensions) => {
        const extensionConfiguration = {
            ...asPartial$5(getAwsRegionExtensionConfiguration$3(runtimeConfig)),
            ...asPartial$5(getDefaultExtensionConfiguration$3(runtimeConfig)),
            ...asPartial$5(getHttpHandlerExtensionConfiguration$3(runtimeConfig)),
            ...asPartial$5(getHttpAuthExtensionConfiguration$2(runtimeConfig)),
        };
        extensions.forEach((extension) => extension.configure(extensionConfiguration));
        return {
            ...runtimeConfig,
            ...resolveAwsRegionExtensionConfiguration$3(extensionConfiguration),
            ...resolveDefaultRuntimeConfig$3(extensionConfiguration),
            ...resolveHttpHandlerRuntimeConfig$3(extensionConfiguration),
            ...resolveHttpAuthRuntimeConfig$2(extensionConfiguration),
        };
    };

    class LocationClient extends Client$3 {
        constructor(...[configuration]) {
            const _config_0 = getRuntimeConfig$a(configuration || {});
            const _config_1 = resolveClientEndpointParameters$2(_config_0);
            const _config_2 = resolveRegionConfig$3(_config_1);
            const _config_3 = resolveEndpointConfig(_config_2);
            const _config_4 = resolveHostHeaderConfig$3(_config_3);
            const _config_5 = resolveUserAgentConfig$3(_config_4);
            const _config_6 = resolveRetryConfig$3(_config_5);
            const _config_7 = resolveHttpAuthSchemeConfig$2(_config_6);
            const _config_8 = resolveRuntimeExtensions$5(_config_7, configuration?.extensions || []);
            super(_config_8);
            this.config = _config_8;
            this.middlewareStack.use(getHostHeaderPlugin$3(this.config));
            this.middlewareStack.use(getLoggerPlugin$3(this.config));
            this.middlewareStack.use(getRecursionDetectionPlugin$3(this.config));
            this.middlewareStack.use(getUserAgentPlugin$3(this.config));
            this.middlewareStack.use(getRetryPlugin$3(this.config));
            this.middlewareStack.use(getContentLengthPlugin$3(this.config));
            this.middlewareStack.use(getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
                httpAuthSchemeParametersProvider: this.getDefaultHttpAuthSchemeParametersProvider(),
                identityProviderConfigProvider: this.getIdentityProviderConfigProvider(),
            }));
            this.middlewareStack.use(getHttpSigningPlugin(this.config));
        }
        destroy() {
            super.destroy();
        }
        getDefaultHttpAuthSchemeParametersProvider() {
            return defaultLocationHttpAuthSchemeParametersProvider;
        }
        getIdentityProviderConfigProvider() {
            return async (config) => new DefaultIdentityProviderConfig({
                "aws.auth#sigv4": config.credentials,
            });
        }
    }

    class LocationServiceException extends ServiceException$3 {
        constructor(options) {
            super(options);
            Object.setPrototypeOf(this, LocationServiceException.prototype);
        }
    }

    let AccessDeniedException$3 = class AccessDeniedException extends LocationServiceException {
        constructor(opts) {
            super({
                name: "AccessDeniedException",
                $fault: "client",
                ...opts,
            });
            this.name = "AccessDeniedException";
            this.$fault = "client";
            Object.setPrototypeOf(this, AccessDeniedException.prototype);
            this.Message = opts.Message;
        }
    };
    class ConflictException extends LocationServiceException {
        constructor(opts) {
            super({
                name: "ConflictException",
                $fault: "client",
                ...opts,
            });
            this.name = "ConflictException";
            this.$fault = "client";
            Object.setPrototypeOf(this, ConflictException.prototype);
            this.Message = opts.Message;
        }
    }
    let InternalServerException$3 = class InternalServerException extends LocationServiceException {
        constructor(opts) {
            super({
                name: "InternalServerException",
                $fault: "server",
                ...opts,
            });
            this.name = "InternalServerException";
            this.$fault = "server";
            this.$retryable = {};
            Object.setPrototypeOf(this, InternalServerException.prototype);
            this.Message = opts.Message;
        }
    };
    class ServiceQuotaExceededException extends LocationServiceException {
        constructor(opts) {
            super({
                name: "ServiceQuotaExceededException",
                $fault: "client",
                ...opts,
            });
            this.name = "ServiceQuotaExceededException";
            this.$fault = "client";
            Object.setPrototypeOf(this, ServiceQuotaExceededException.prototype);
            this.Message = opts.Message;
        }
    }
    let ThrottlingException$3 = class ThrottlingException extends LocationServiceException {
        constructor(opts) {
            super({
                name: "ThrottlingException",
                $fault: "client",
                ...opts,
            });
            this.name = "ThrottlingException";
            this.$fault = "client";
            this.$retryable = {};
            Object.setPrototypeOf(this, ThrottlingException.prototype);
            this.Message = opts.Message;
        }
    };
    let ValidationException$3 = class ValidationException extends LocationServiceException {
        constructor(opts) {
            super({
                name: "ValidationException",
                $fault: "client",
                ...opts,
            });
            this.name = "ValidationException";
            this.$fault = "client";
            Object.setPrototypeOf(this, ValidationException.prototype);
            this.Message = opts.Message;
            this.Reason = opts.Reason;
            this.FieldList = opts.FieldList;
        }
    };
    let ResourceNotFoundException$2 = class ResourceNotFoundException extends LocationServiceException {
        constructor(opts) {
            super({
                name: "ResourceNotFoundException",
                $fault: "client",
                ...opts,
            });
            this.name = "ResourceNotFoundException";
            this.$fault = "client";
            Object.setPrototypeOf(this, ResourceNotFoundException.prototype);
            this.Message = opts.Message;
        }
    };
    const CreateKeyResponseFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Key && { Key: SENSITIVE_STRING$3 }),
    });
    const DescribeKeyResponseFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Key && { Key: SENSITIVE_STRING$3 }),
    });
    const DevicePositionUpdateFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Position && { Position: SENSITIVE_STRING$3 }),
        ...(obj.PositionProperties && { PositionProperties: SENSITIVE_STRING$3 }),
    });
    const BatchEvaluateGeofencesRequestFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.DevicePositionUpdates && {
            DevicePositionUpdates: obj.DevicePositionUpdates.map((item) => DevicePositionUpdateFilterSensitiveLog(item)),
        }),
    });
    const DevicePositionFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Position && { Position: SENSITIVE_STRING$3 }),
        ...(obj.PositionProperties && { PositionProperties: SENSITIVE_STRING$3 }),
    });
    const BatchGetDevicePositionResponseFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.DevicePositions && {
            DevicePositions: obj.DevicePositions.map((item) => DevicePositionFilterSensitiveLog(item)),
        }),
    });
    const CircleFilterSensitiveLog$1 = (obj) => ({
        ...obj,
        ...(obj.Center && { Center: SENSITIVE_STRING$3 }),
    });
    const GeofenceGeometryFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Polygon && { Polygon: obj.Polygon.map((item) => SENSITIVE_STRING$3) }),
        ...(obj.Circle && { Circle: SENSITIVE_STRING$3 }),
        ...(obj.Geobuf && { Geobuf: SENSITIVE_STRING$3 }),
    });
    const BatchPutGeofenceRequestEntryFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Geometry && { Geometry: GeofenceGeometryFilterSensitiveLog(obj.Geometry) }),
        ...(obj.GeofenceProperties && { GeofenceProperties: SENSITIVE_STRING$3 }),
    });
    const BatchPutGeofenceRequestFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Entries && { Entries: obj.Entries.map((item) => BatchPutGeofenceRequestEntryFilterSensitiveLog(item)) }),
    });
    const BatchUpdateDevicePositionRequestFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Updates && { Updates: obj.Updates.map((item) => DevicePositionUpdateFilterSensitiveLog(item)) }),
    });
    const CalculateRouteRequestFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.DeparturePosition && { DeparturePosition: SENSITIVE_STRING$3 }),
        ...(obj.DestinationPosition && { DestinationPosition: SENSITIVE_STRING$3 }),
        ...(obj.WaypointPositions && { WaypointPositions: SENSITIVE_STRING$3 }),
        ...(obj.Key && { Key: SENSITIVE_STRING$3 }),
    });
    const LegGeometryFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.LineString && { LineString: SENSITIVE_STRING$3 }),
    });
    const StepFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.StartPosition && { StartPosition: SENSITIVE_STRING$3 }),
        ...(obj.EndPosition && { EndPosition: SENSITIVE_STRING$3 }),
    });
    const LegFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.StartPosition && { StartPosition: SENSITIVE_STRING$3 }),
        ...(obj.EndPosition && { EndPosition: SENSITIVE_STRING$3 }),
        ...(obj.Geometry && { Geometry: LegGeometryFilterSensitiveLog(obj.Geometry) }),
        ...(obj.Steps && { Steps: obj.Steps.map((item) => StepFilterSensitiveLog(item)) }),
    });
    const CalculateRouteSummaryFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.RouteBBox && { RouteBBox: SENSITIVE_STRING$3 }),
    });
    const CalculateRouteResponseFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Legs && { Legs: obj.Legs.map((item) => LegFilterSensitiveLog(item)) }),
        ...(obj.Summary && { Summary: CalculateRouteSummaryFilterSensitiveLog(obj.Summary) }),
    });
    const CalculateRouteMatrixRequestFilterSensitiveLog$1 = (obj) => ({
        ...obj,
        ...(obj.DeparturePositions && { DeparturePositions: SENSITIVE_STRING$3 }),
        ...(obj.DestinationPositions && { DestinationPositions: SENSITIVE_STRING$3 }),
        ...(obj.Key && { Key: SENSITIVE_STRING$3 }),
    });
    const CalculateRouteMatrixResponseFilterSensitiveLog$1 = (obj) => ({
        ...obj,
        ...(obj.SnappedDeparturePositions && { SnappedDeparturePositions: SENSITIVE_STRING$3 }),
        ...(obj.SnappedDestinationPositions && { SnappedDestinationPositions: SENSITIVE_STRING$3 }),
    });
    const DeviceStateFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Position && { Position: SENSITIVE_STRING$3 }),
    });
    const ForecastedEventFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.GeofenceProperties && { GeofenceProperties: SENSITIVE_STRING$3 }),
    });
    const ForecastGeofenceEventsDeviceStateFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Position && { Position: SENSITIVE_STRING$3 }),
    });
    const ForecastGeofenceEventsRequestFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.DeviceState && { DeviceState: ForecastGeofenceEventsDeviceStateFilterSensitiveLog(obj.DeviceState) }),
    });
    const ForecastGeofenceEventsResponseFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.ForecastedEvents && {
            ForecastedEvents: obj.ForecastedEvents.map((item) => ForecastedEventFilterSensitiveLog(item)),
        }),
    });
    const GetGeofenceResponseFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Geometry && { Geometry: GeofenceGeometryFilterSensitiveLog(obj.Geometry) }),
        ...(obj.GeofenceProperties && { GeofenceProperties: SENSITIVE_STRING$3 }),
    });
    const ListGeofenceResponseEntryFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Geometry && { Geometry: GeofenceGeometryFilterSensitiveLog(obj.Geometry) }),
        ...(obj.GeofenceProperties && { GeofenceProperties: SENSITIVE_STRING$3 }),
    });
    const ListGeofencesResponseFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Entries && { Entries: obj.Entries.map((item) => ListGeofenceResponseEntryFilterSensitiveLog(item)) }),
    });
    const PutGeofenceRequestFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Geometry && { Geometry: GeofenceGeometryFilterSensitiveLog(obj.Geometry) }),
        ...(obj.GeofenceProperties && { GeofenceProperties: SENSITIVE_STRING$3 }),
    });
    const GetDevicePositionResponseFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Position && { Position: SENSITIVE_STRING$3 }),
        ...(obj.PositionProperties && { PositionProperties: SENSITIVE_STRING$3 }),
    });
    const GetDevicePositionHistoryResponseFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.DevicePositions && {
            DevicePositions: obj.DevicePositions.map((item) => DevicePositionFilterSensitiveLog(item)),
        }),
    });
    const GetMapGlyphsRequestFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Key && { Key: SENSITIVE_STRING$3 }),
    });
    const GetMapSpritesRequestFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Key && { Key: SENSITIVE_STRING$3 }),
    });
    const GetMapStyleDescriptorRequestFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Key && { Key: SENSITIVE_STRING$3 }),
    });
    const GetMapTileRequestFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Key && { Key: SENSITIVE_STRING$3 }),
    });
    const GetPlaceRequestFilterSensitiveLog$1 = (obj) => ({
        ...obj,
        ...(obj.Key && { Key: SENSITIVE_STRING$3 }),
    });
    const PlaceGeometryFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Point && { Point: SENSITIVE_STRING$3 }),
    });
    const PlaceFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Geometry && { Geometry: PlaceGeometryFilterSensitiveLog(obj.Geometry) }),
    });
    const GetPlaceResponseFilterSensitiveLog$1 = (obj) => ({
        ...obj,
        ...(obj.Place && { Place: PlaceFilterSensitiveLog(obj.Place) }),
    });
    const InferredStateFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Position && { Position: SENSITIVE_STRING$3 }),
    });
    const TrackingFilterGeometryFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Polygon && { Polygon: obj.Polygon.map((item) => SENSITIVE_STRING$3) }),
    });
    const ListDevicePositionsRequestFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.FilterGeometry && { FilterGeometry: TrackingFilterGeometryFilterSensitiveLog(obj.FilterGeometry) }),
    });
    const ListDevicePositionsResponseEntryFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Position && { Position: SENSITIVE_STRING$3 }),
        ...(obj.PositionProperties && { PositionProperties: SENSITIVE_STRING$3 }),
    });
    const ListDevicePositionsResponseFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Entries && { Entries: obj.Entries.map((item) => ListDevicePositionsResponseEntryFilterSensitiveLog(item)) }),
    });
    const SearchPlaceIndexForPositionRequestFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Position && { Position: SENSITIVE_STRING$3 }),
        ...(obj.Key && { Key: SENSITIVE_STRING$3 }),
    });
    const SearchForPositionResultFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Place && { Place: PlaceFilterSensitiveLog(obj.Place) }),
    });
    const SearchPlaceIndexForPositionSummaryFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Position && { Position: SENSITIVE_STRING$3 }),
    });
    const SearchPlaceIndexForPositionResponseFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Summary && { Summary: SearchPlaceIndexForPositionSummaryFilterSensitiveLog(obj.Summary) }),
        ...(obj.Results && { Results: obj.Results.map((item) => SearchForPositionResultFilterSensitiveLog(item)) }),
    });
    const SearchPlaceIndexForSuggestionsRequestFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Text && { Text: SENSITIVE_STRING$3 }),
        ...(obj.BiasPosition && { BiasPosition: SENSITIVE_STRING$3 }),
        ...(obj.FilterBBox && { FilterBBox: SENSITIVE_STRING$3 }),
        ...(obj.Key && { Key: SENSITIVE_STRING$3 }),
    });
    const SearchPlaceIndexForSuggestionsSummaryFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Text && { Text: SENSITIVE_STRING$3 }),
        ...(obj.BiasPosition && { BiasPosition: SENSITIVE_STRING$3 }),
        ...(obj.FilterBBox && { FilterBBox: SENSITIVE_STRING$3 }),
    });
    const SearchPlaceIndexForSuggestionsResponseFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Summary && { Summary: SearchPlaceIndexForSuggestionsSummaryFilterSensitiveLog(obj.Summary) }),
    });
    const SearchPlaceIndexForTextRequestFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Text && { Text: SENSITIVE_STRING$3 }),
        ...(obj.BiasPosition && { BiasPosition: SENSITIVE_STRING$3 }),
        ...(obj.FilterBBox && { FilterBBox: SENSITIVE_STRING$3 }),
        ...(obj.Key && { Key: SENSITIVE_STRING$3 }),
    });
    const SearchForTextResultFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Place && { Place: PlaceFilterSensitiveLog(obj.Place) }),
    });
    const SearchPlaceIndexForTextSummaryFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Text && { Text: SENSITIVE_STRING$3 }),
        ...(obj.BiasPosition && { BiasPosition: SENSITIVE_STRING$3 }),
        ...(obj.FilterBBox && { FilterBBox: SENSITIVE_STRING$3 }),
        ...(obj.ResultBBox && { ResultBBox: SENSITIVE_STRING$3 }),
    });
    const SearchPlaceIndexForTextResponseFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Summary && { Summary: SearchPlaceIndexForTextSummaryFilterSensitiveLog(obj.Summary) }),
        ...(obj.Results && { Results: obj.Results.map((item) => SearchForTextResultFilterSensitiveLog(item)) }),
    });
    const VerifyDevicePositionRequestFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.DeviceState && { DeviceState: DeviceStateFilterSensitiveLog(obj.DeviceState) }),
    });
    const VerifyDevicePositionResponseFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.InferredState && { InferredState: InferredStateFilterSensitiveLog(obj.InferredState) }),
    });

    const se_AssociateTrackerConsumerCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/tracking/v0/trackers/{TrackerName}/consumers");
        b.p("TrackerName", () => input.TrackerName, "{TrackerName}", false);
        let body;
        body = JSON.stringify(take$3(input, {
            ConsumerArn: [],
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.tracking." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("POST").h(headers).b(body);
        return b.build();
    };
    const se_BatchDeleteDevicePositionHistoryCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/tracking/v0/trackers/{TrackerName}/delete-positions");
        b.p("TrackerName", () => input.TrackerName, "{TrackerName}", false);
        let body;
        body = JSON.stringify(take$3(input, {
            DeviceIds: (_) => _json$2(_),
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "tracking." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("POST").h(headers).b(body);
        return b.build();
    };
    const se_BatchDeleteGeofenceCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/geofencing/v0/collections/{CollectionName}/delete-geofences");
        b.p("CollectionName", () => input.CollectionName, "{CollectionName}", false);
        let body;
        body = JSON.stringify(take$3(input, {
            GeofenceIds: (_) => _json$2(_),
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "geofencing." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("POST").h(headers).b(body);
        return b.build();
    };
    const se_BatchEvaluateGeofencesCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/geofencing/v0/collections/{CollectionName}/positions");
        b.p("CollectionName", () => input.CollectionName, "{CollectionName}", false);
        let body;
        body = JSON.stringify(take$3(input, {
            DevicePositionUpdates: (_) => se_DevicePositionUpdateList(_),
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "geofencing." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("POST").h(headers).b(body);
        return b.build();
    };
    const se_BatchGetDevicePositionCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/tracking/v0/trackers/{TrackerName}/get-positions");
        b.p("TrackerName", () => input.TrackerName, "{TrackerName}", false);
        let body;
        body = JSON.stringify(take$3(input, {
            DeviceIds: (_) => _json$2(_),
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "tracking." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("POST").h(headers).b(body);
        return b.build();
    };
    const se_BatchPutGeofenceCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/geofencing/v0/collections/{CollectionName}/put-geofences");
        b.p("CollectionName", () => input.CollectionName, "{CollectionName}", false);
        let body;
        body = JSON.stringify(take$3(input, {
            Entries: (_) => se_BatchPutGeofenceRequestEntryList(_, context),
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "geofencing." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("POST").h(headers).b(body);
        return b.build();
    };
    const se_BatchUpdateDevicePositionCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/tracking/v0/trackers/{TrackerName}/positions");
        b.p("TrackerName", () => input.TrackerName, "{TrackerName}", false);
        let body;
        body = JSON.stringify(take$3(input, {
            Updates: (_) => se_DevicePositionUpdateList(_),
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "tracking." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("POST").h(headers).b(body);
        return b.build();
    };
    const se_CalculateRouteCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/routes/v0/calculators/{CalculatorName}/calculate/route");
        b.p("CalculatorName", () => input.CalculatorName, "{CalculatorName}", false);
        const query = map$3({
            [_k]: [, input[_K$1]],
        });
        let body;
        body = JSON.stringify(take$3(input, {
            ArrivalTime: (_) => serializeDateTime(_),
            CarModeOptions: (_) => _json$2(_),
            DepartNow: [],
            DeparturePosition: (_) => se_Position$2(_),
            DepartureTime: (_) => serializeDateTime(_),
            DestinationPosition: (_) => se_Position$2(_),
            DistanceUnit: [],
            IncludeLegGeometry: [],
            OptimizeFor: [],
            TravelMode: [],
            TruckModeOptions: (_) => se_CalculateRouteTruckModeOptions(_),
            WaypointPositions: (_) => se_WaypointPositionList(_),
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "routes." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("POST").h(headers).q(query).b(body);
        return b.build();
    };
    const se_CalculateRouteMatrixCommand$1 = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/routes/v0/calculators/{CalculatorName}/calculate/route-matrix");
        b.p("CalculatorName", () => input.CalculatorName, "{CalculatorName}", false);
        const query = map$3({
            [_k]: [, input[_K$1]],
        });
        let body;
        body = JSON.stringify(take$3(input, {
            CarModeOptions: (_) => _json$2(_),
            DepartNow: [],
            DeparturePositions: (_) => se_PositionList(_),
            DepartureTime: (_) => serializeDateTime(_),
            DestinationPositions: (_) => se_PositionList(_),
            DistanceUnit: [],
            TravelMode: [],
            TruckModeOptions: (_) => se_CalculateRouteTruckModeOptions(_),
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "routes." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("POST").h(headers).q(query).b(body);
        return b.build();
    };
    const se_CreateGeofenceCollectionCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/geofencing/v0/collections");
        let body;
        body = JSON.stringify(take$3(input, {
            CollectionName: [],
            Description: [],
            KmsKeyId: [],
            PricingPlan: [],
            PricingPlanDataSource: [],
            Tags: (_) => _json$2(_),
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.geofencing." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("POST").h(headers).b(body);
        return b.build();
    };
    const se_CreateKeyCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/metadata/v0/keys");
        let body;
        body = JSON.stringify(take$3(input, {
            Description: [],
            ExpireTime: (_) => serializeDateTime(_),
            KeyName: [],
            NoExpiry: [],
            Restrictions: (_) => _json$2(_),
            Tags: (_) => _json$2(_),
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.metadata." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("POST").h(headers).b(body);
        return b.build();
    };
    const se_CreateMapCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/maps/v0/maps");
        let body;
        body = JSON.stringify(take$3(input, {
            Configuration: (_) => _json$2(_),
            Description: [],
            MapName: [],
            PricingPlan: [],
            Tags: (_) => _json$2(_),
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.maps." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("POST").h(headers).b(body);
        return b.build();
    };
    const se_CreatePlaceIndexCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/places/v0/indexes");
        let body;
        body = JSON.stringify(take$3(input, {
            DataSource: [],
            DataSourceConfiguration: (_) => _json$2(_),
            Description: [],
            IndexName: [],
            PricingPlan: [],
            Tags: (_) => _json$2(_),
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.places." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("POST").h(headers).b(body);
        return b.build();
    };
    const se_CreateRouteCalculatorCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/routes/v0/calculators");
        let body;
        body = JSON.stringify(take$3(input, {
            CalculatorName: [],
            DataSource: [],
            Description: [],
            PricingPlan: [],
            Tags: (_) => _json$2(_),
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.routes." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("POST").h(headers).b(body);
        return b.build();
    };
    const se_CreateTrackerCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/tracking/v0/trackers");
        let body;
        body = JSON.stringify(take$3(input, {
            Description: [],
            EventBridgeEnabled: [],
            KmsKeyEnableGeospatialQueries: [],
            KmsKeyId: [],
            PositionFiltering: [],
            PricingPlan: [],
            PricingPlanDataSource: [],
            Tags: (_) => _json$2(_),
            TrackerName: [],
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.tracking." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("POST").h(headers).b(body);
        return b.build();
    };
    const se_DeleteGeofenceCollectionCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {};
        b.bp("/geofencing/v0/collections/{CollectionName}");
        b.p("CollectionName", () => input.CollectionName, "{CollectionName}", false);
        let body;
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.geofencing." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("DELETE").h(headers).b(body);
        return b.build();
    };
    const se_DeleteKeyCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {};
        b.bp("/metadata/v0/keys/{KeyName}");
        b.p("KeyName", () => input.KeyName, "{KeyName}", false);
        const query = map$3({
            [_fD]: [() => input.ForceDelete !== void 0, () => input[_FD].toString()],
        });
        let body;
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.metadata." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("DELETE").h(headers).q(query).b(body);
        return b.build();
    };
    const se_DeleteMapCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {};
        b.bp("/maps/v0/maps/{MapName}");
        b.p("MapName", () => input.MapName, "{MapName}", false);
        let body;
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.maps." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("DELETE").h(headers).b(body);
        return b.build();
    };
    const se_DeletePlaceIndexCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {};
        b.bp("/places/v0/indexes/{IndexName}");
        b.p("IndexName", () => input.IndexName, "{IndexName}", false);
        let body;
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.places." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("DELETE").h(headers).b(body);
        return b.build();
    };
    const se_DeleteRouteCalculatorCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {};
        b.bp("/routes/v0/calculators/{CalculatorName}");
        b.p("CalculatorName", () => input.CalculatorName, "{CalculatorName}", false);
        let body;
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.routes." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("DELETE").h(headers).b(body);
        return b.build();
    };
    const se_DeleteTrackerCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {};
        b.bp("/tracking/v0/trackers/{TrackerName}");
        b.p("TrackerName", () => input.TrackerName, "{TrackerName}", false);
        let body;
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.tracking." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("DELETE").h(headers).b(body);
        return b.build();
    };
    const se_DescribeGeofenceCollectionCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {};
        b.bp("/geofencing/v0/collections/{CollectionName}");
        b.p("CollectionName", () => input.CollectionName, "{CollectionName}", false);
        let body;
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.geofencing." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("GET").h(headers).b(body);
        return b.build();
    };
    const se_DescribeKeyCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {};
        b.bp("/metadata/v0/keys/{KeyName}");
        b.p("KeyName", () => input.KeyName, "{KeyName}", false);
        let body;
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.metadata." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("GET").h(headers).b(body);
        return b.build();
    };
    const se_DescribeMapCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {};
        b.bp("/maps/v0/maps/{MapName}");
        b.p("MapName", () => input.MapName, "{MapName}", false);
        let body;
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.maps." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("GET").h(headers).b(body);
        return b.build();
    };
    const se_DescribePlaceIndexCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {};
        b.bp("/places/v0/indexes/{IndexName}");
        b.p("IndexName", () => input.IndexName, "{IndexName}", false);
        let body;
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.places." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("GET").h(headers).b(body);
        return b.build();
    };
    const se_DescribeRouteCalculatorCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {};
        b.bp("/routes/v0/calculators/{CalculatorName}");
        b.p("CalculatorName", () => input.CalculatorName, "{CalculatorName}", false);
        let body;
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.routes." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("GET").h(headers).b(body);
        return b.build();
    };
    const se_DescribeTrackerCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {};
        b.bp("/tracking/v0/trackers/{TrackerName}");
        b.p("TrackerName", () => input.TrackerName, "{TrackerName}", false);
        let body;
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.tracking." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("GET").h(headers).b(body);
        return b.build();
    };
    const se_DisassociateTrackerConsumerCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {};
        b.bp("/tracking/v0/trackers/{TrackerName}/consumers/{ConsumerArn}");
        b.p("TrackerName", () => input.TrackerName, "{TrackerName}", false);
        b.p("ConsumerArn", () => input.ConsumerArn, "{ConsumerArn}", false);
        let body;
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.tracking." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("DELETE").h(headers).b(body);
        return b.build();
    };
    const se_ForecastGeofenceEventsCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/geofencing/v0/collections/{CollectionName}/forecast-geofence-events");
        b.p("CollectionName", () => input.CollectionName, "{CollectionName}", false);
        let body;
        body = JSON.stringify(take$3(input, {
            DeviceState: (_) => se_ForecastGeofenceEventsDeviceState(_),
            DistanceUnit: [],
            MaxResults: [],
            NextToken: [],
            SpeedUnit: [],
            TimeHorizonMinutes: (_) => serializeFloat$2(_),
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "geofencing." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("POST").h(headers).b(body);
        return b.build();
    };
    const se_GetDevicePositionCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {};
        b.bp("/tracking/v0/trackers/{TrackerName}/devices/{DeviceId}/positions/latest");
        b.p("TrackerName", () => input.TrackerName, "{TrackerName}", false);
        b.p("DeviceId", () => input.DeviceId, "{DeviceId}", false);
        let body;
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "tracking." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("GET").h(headers).b(body);
        return b.build();
    };
    const se_GetDevicePositionHistoryCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/tracking/v0/trackers/{TrackerName}/devices/{DeviceId}/list-positions");
        b.p("TrackerName", () => input.TrackerName, "{TrackerName}", false);
        b.p("DeviceId", () => input.DeviceId, "{DeviceId}", false);
        let body;
        body = JSON.stringify(take$3(input, {
            EndTimeExclusive: (_) => serializeDateTime(_),
            MaxResults: [],
            NextToken: [],
            StartTimeInclusive: (_) => serializeDateTime(_),
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "tracking." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("POST").h(headers).b(body);
        return b.build();
    };
    const se_GetGeofenceCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {};
        b.bp("/geofencing/v0/collections/{CollectionName}/geofences/{GeofenceId}");
        b.p("CollectionName", () => input.CollectionName, "{CollectionName}", false);
        b.p("GeofenceId", () => input.GeofenceId, "{GeofenceId}", false);
        let body;
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "geofencing." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("GET").h(headers).b(body);
        return b.build();
    };
    const se_GetMapGlyphsCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {};
        b.bp("/maps/v0/maps/{MapName}/glyphs/{FontStack}/{FontUnicodeRange}");
        b.p("MapName", () => input.MapName, "{MapName}", false);
        b.p("FontStack", () => input.FontStack, "{FontStack}", false);
        b.p("FontUnicodeRange", () => input.FontUnicodeRange, "{FontUnicodeRange}", false);
        const query = map$3({
            [_k]: [, input[_K$1]],
        });
        let body;
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "maps." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("GET").h(headers).q(query).b(body);
        return b.build();
    };
    const se_GetMapSpritesCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {};
        b.bp("/maps/v0/maps/{MapName}/sprites/{FileName}");
        b.p("MapName", () => input.MapName, "{MapName}", false);
        b.p("FileName", () => input.FileName, "{FileName}", false);
        const query = map$3({
            [_k]: [, input[_K$1]],
        });
        let body;
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "maps." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("GET").h(headers).q(query).b(body);
        return b.build();
    };
    const se_GetMapStyleDescriptorCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {};
        b.bp("/maps/v0/maps/{MapName}/style-descriptor");
        b.p("MapName", () => input.MapName, "{MapName}", false);
        const query = map$3({
            [_k]: [, input[_K$1]],
        });
        let body;
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "maps." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("GET").h(headers).q(query).b(body);
        return b.build();
    };
    const se_GetMapTileCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {};
        b.bp("/maps/v0/maps/{MapName}/tiles/{Z}/{X}/{Y}");
        b.p("MapName", () => input.MapName, "{MapName}", false);
        b.p("Z", () => input.Z, "{Z}", false);
        b.p("X", () => input.X, "{X}", false);
        b.p("Y", () => input.Y, "{Y}", false);
        const query = map$3({
            [_k]: [, input[_K$1]],
        });
        let body;
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "maps." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("GET").h(headers).q(query).b(body);
        return b.build();
    };
    const se_GetPlaceCommand$1 = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {};
        b.bp("/places/v0/indexes/{IndexName}/places/{PlaceId}");
        b.p("IndexName", () => input.IndexName, "{IndexName}", false);
        b.p("PlaceId", () => input.PlaceId, "{PlaceId}", false);
        const query = map$3({
            [_l]: [, input[_L]],
            [_k]: [, input[_K$1]],
        });
        let body;
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "places." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("GET").h(headers).q(query).b(body);
        return b.build();
    };
    const se_ListDevicePositionsCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/tracking/v0/trackers/{TrackerName}/list-positions");
        b.p("TrackerName", () => input.TrackerName, "{TrackerName}", false);
        let body;
        body = JSON.stringify(take$3(input, {
            FilterGeometry: (_) => se_TrackingFilterGeometry(_),
            MaxResults: [],
            NextToken: [],
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "tracking." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("POST").h(headers).b(body);
        return b.build();
    };
    const se_ListGeofenceCollectionsCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/geofencing/v0/list-collections");
        let body;
        body = JSON.stringify(take$3(input, {
            MaxResults: [],
            NextToken: [],
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.geofencing." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("POST").h(headers).b(body);
        return b.build();
    };
    const se_ListGeofencesCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/geofencing/v0/collections/{CollectionName}/list-geofences");
        b.p("CollectionName", () => input.CollectionName, "{CollectionName}", false);
        let body;
        body = JSON.stringify(take$3(input, {
            MaxResults: [],
            NextToken: [],
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "geofencing." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("POST").h(headers).b(body);
        return b.build();
    };
    const se_ListKeysCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/metadata/v0/list-keys");
        let body;
        body = JSON.stringify(take$3(input, {
            Filter: (_) => _json$2(_),
            MaxResults: [],
            NextToken: [],
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.metadata." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("POST").h(headers).b(body);
        return b.build();
    };
    const se_ListMapsCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/maps/v0/list-maps");
        let body;
        body = JSON.stringify(take$3(input, {
            MaxResults: [],
            NextToken: [],
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.maps." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("POST").h(headers).b(body);
        return b.build();
    };
    const se_ListPlaceIndexesCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/places/v0/list-indexes");
        let body;
        body = JSON.stringify(take$3(input, {
            MaxResults: [],
            NextToken: [],
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.places." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("POST").h(headers).b(body);
        return b.build();
    };
    const se_ListRouteCalculatorsCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/routes/v0/list-calculators");
        let body;
        body = JSON.stringify(take$3(input, {
            MaxResults: [],
            NextToken: [],
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.routes." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("POST").h(headers).b(body);
        return b.build();
    };
    const se_ListTagsForResourceCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {};
        b.bp("/tags/{ResourceArn}");
        b.p("ResourceArn", () => input.ResourceArn, "{ResourceArn}", false);
        let body;
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.metadata." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("GET").h(headers).b(body);
        return b.build();
    };
    const se_ListTrackerConsumersCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/tracking/v0/trackers/{TrackerName}/list-consumers");
        b.p("TrackerName", () => input.TrackerName, "{TrackerName}", false);
        let body;
        body = JSON.stringify(take$3(input, {
            MaxResults: [],
            NextToken: [],
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.tracking." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("POST").h(headers).b(body);
        return b.build();
    };
    const se_ListTrackersCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/tracking/v0/list-trackers");
        let body;
        body = JSON.stringify(take$3(input, {
            MaxResults: [],
            NextToken: [],
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.tracking." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("POST").h(headers).b(body);
        return b.build();
    };
    const se_PutGeofenceCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/geofencing/v0/collections/{CollectionName}/geofences/{GeofenceId}");
        b.p("CollectionName", () => input.CollectionName, "{CollectionName}", false);
        b.p("GeofenceId", () => input.GeofenceId, "{GeofenceId}", false);
        let body;
        body = JSON.stringify(take$3(input, {
            GeofenceProperties: (_) => _json$2(_),
            Geometry: (_) => se_GeofenceGeometry(_, context),
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "geofencing." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("PUT").h(headers).b(body);
        return b.build();
    };
    const se_SearchPlaceIndexForPositionCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/places/v0/indexes/{IndexName}/search/position");
        b.p("IndexName", () => input.IndexName, "{IndexName}", false);
        const query = map$3({
            [_k]: [, input[_K$1]],
        });
        let body;
        body = JSON.stringify(take$3(input, {
            Language: [],
            MaxResults: [],
            Position: (_) => se_Position$2(_),
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "places." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("POST").h(headers).q(query).b(body);
        return b.build();
    };
    const se_SearchPlaceIndexForSuggestionsCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/places/v0/indexes/{IndexName}/search/suggestions");
        b.p("IndexName", () => input.IndexName, "{IndexName}", false);
        const query = map$3({
            [_k]: [, input[_K$1]],
        });
        let body;
        body = JSON.stringify(take$3(input, {
            BiasPosition: (_) => se_Position$2(_),
            FilterBBox: (_) => se_BoundingBox$2(_),
            FilterCategories: (_) => _json$2(_),
            FilterCountries: (_) => _json$2(_),
            Language: [],
            MaxResults: [],
            Text: [],
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "places." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("POST").h(headers).q(query).b(body);
        return b.build();
    };
    const se_SearchPlaceIndexForTextCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/places/v0/indexes/{IndexName}/search/text");
        b.p("IndexName", () => input.IndexName, "{IndexName}", false);
        const query = map$3({
            [_k]: [, input[_K$1]],
        });
        let body;
        body = JSON.stringify(take$3(input, {
            BiasPosition: (_) => se_Position$2(_),
            FilterBBox: (_) => se_BoundingBox$2(_),
            FilterCategories: (_) => _json$2(_),
            FilterCountries: (_) => _json$2(_),
            Language: [],
            MaxResults: [],
            Text: [],
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "places." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("POST").h(headers).q(query).b(body);
        return b.build();
    };
    const se_TagResourceCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/tags/{ResourceArn}");
        b.p("ResourceArn", () => input.ResourceArn, "{ResourceArn}", false);
        let body;
        body = JSON.stringify(take$3(input, {
            Tags: (_) => _json$2(_),
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.metadata." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("POST").h(headers).b(body);
        return b.build();
    };
    const se_UntagResourceCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {};
        b.bp("/tags/{ResourceArn}");
        b.p("ResourceArn", () => input.ResourceArn, "{ResourceArn}", false);
        const query = map$3({
            [_tK]: [
                expectNonNull$3(input.TagKeys, `TagKeys`) != null,
                () => (input[_TK] || []).map((_entry) => _entry),
            ],
        });
        let body;
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.metadata." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("DELETE").h(headers).q(query).b(body);
        return b.build();
    };
    const se_UpdateGeofenceCollectionCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/geofencing/v0/collections/{CollectionName}");
        b.p("CollectionName", () => input.CollectionName, "{CollectionName}", false);
        let body;
        body = JSON.stringify(take$3(input, {
            Description: [],
            PricingPlan: [],
            PricingPlanDataSource: [],
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.geofencing." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("PATCH").h(headers).b(body);
        return b.build();
    };
    const se_UpdateKeyCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/metadata/v0/keys/{KeyName}");
        b.p("KeyName", () => input.KeyName, "{KeyName}", false);
        let body;
        body = JSON.stringify(take$3(input, {
            Description: [],
            ExpireTime: (_) => serializeDateTime(_),
            ForceUpdate: [],
            NoExpiry: [],
            Restrictions: (_) => _json$2(_),
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.metadata." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("PATCH").h(headers).b(body);
        return b.build();
    };
    const se_UpdateMapCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/maps/v0/maps/{MapName}");
        b.p("MapName", () => input.MapName, "{MapName}", false);
        let body;
        body = JSON.stringify(take$3(input, {
            ConfigurationUpdate: (_) => _json$2(_),
            Description: [],
            PricingPlan: [],
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.maps." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("PATCH").h(headers).b(body);
        return b.build();
    };
    const se_UpdatePlaceIndexCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/places/v0/indexes/{IndexName}");
        b.p("IndexName", () => input.IndexName, "{IndexName}", false);
        let body;
        body = JSON.stringify(take$3(input, {
            DataSourceConfiguration: (_) => _json$2(_),
            Description: [],
            PricingPlan: [],
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.places." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("PATCH").h(headers).b(body);
        return b.build();
    };
    const se_UpdateRouteCalculatorCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/routes/v0/calculators/{CalculatorName}");
        b.p("CalculatorName", () => input.CalculatorName, "{CalculatorName}", false);
        let body;
        body = JSON.stringify(take$3(input, {
            Description: [],
            PricingPlan: [],
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.routes." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("PATCH").h(headers).b(body);
        return b.build();
    };
    const se_UpdateTrackerCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/tracking/v0/trackers/{TrackerName}");
        b.p("TrackerName", () => input.TrackerName, "{TrackerName}", false);
        let body;
        body = JSON.stringify(take$3(input, {
            Description: [],
            EventBridgeEnabled: [],
            KmsKeyEnableGeospatialQueries: [],
            PositionFiltering: [],
            PricingPlan: [],
            PricingPlanDataSource: [],
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "cp.tracking." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("PATCH").h(headers).b(body);
        return b.build();
    };
    const se_VerifyDevicePositionCommand = async (input, context) => {
        const b = requestBuilder(input, context);
        const headers = {
            "content-type": "application/json",
        };
        b.bp("/tracking/v0/trackers/{TrackerName}/positions/verify");
        b.p("TrackerName", () => input.TrackerName, "{TrackerName}", false);
        let body;
        body = JSON.stringify(take$3(input, {
            DeviceState: (_) => se_DeviceState(_),
            DistanceUnit: [],
        }));
        let { hostname: resolvedHostname } = await context.endpoint();
        if (context.disableHostPrefix !== true) {
            resolvedHostname = "tracking." + resolvedHostname;
            if (!isValidHostname(resolvedHostname)) {
                throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
            }
        }
        b.hn(resolvedHostname);
        b.m("POST").h(headers).b(body);
        return b.build();
    };
    const de_AssociateTrackerConsumerCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        await collectBody$3(output.body, context);
        return contents;
    };
    const de_BatchDeleteDevicePositionHistoryCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            Errors: _json$2,
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_BatchDeleteGeofenceCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            Errors: _json$2,
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_BatchEvaluateGeofencesCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            Errors: (_) => de_BatchEvaluateGeofencesErrorList(_),
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_BatchGetDevicePositionCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            DevicePositions: (_) => de_DevicePositionList(_),
            Errors: _json$2,
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_BatchPutGeofenceCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            Errors: _json$2,
            Successes: (_) => de_BatchPutGeofenceSuccessList(_),
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_BatchUpdateDevicePositionCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            Errors: (_) => de_BatchUpdateDevicePositionErrorList(_),
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_CalculateRouteCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            Legs: (_) => de_LegList(_),
            Summary: (_) => de_CalculateRouteSummary(_),
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_CalculateRouteMatrixCommand$1 = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            RouteMatrix: (_) => de_RouteMatrix(_),
            SnappedDeparturePositions: (_) => de_PositionList(_),
            SnappedDestinationPositions: (_) => de_PositionList(_),
            Summary: _json$2,
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_CreateGeofenceCollectionCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            CollectionArn: expectString$3,
            CollectionName: expectString$3,
            CreateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_CreateKeyCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            CreateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
            Key: expectString$3,
            KeyArn: expectString$3,
            KeyName: expectString$3,
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_CreateMapCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            CreateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
            MapArn: expectString$3,
            MapName: expectString$3,
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_CreatePlaceIndexCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            CreateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
            IndexArn: expectString$3,
            IndexName: expectString$3,
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_CreateRouteCalculatorCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            CalculatorArn: expectString$3,
            CalculatorName: expectString$3,
            CreateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_CreateTrackerCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            CreateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
            TrackerArn: expectString$3,
            TrackerName: expectString$3,
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_DeleteGeofenceCollectionCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        await collectBody$3(output.body, context);
        return contents;
    };
    const de_DeleteKeyCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        await collectBody$3(output.body, context);
        return contents;
    };
    const de_DeleteMapCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        await collectBody$3(output.body, context);
        return contents;
    };
    const de_DeletePlaceIndexCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        await collectBody$3(output.body, context);
        return contents;
    };
    const de_DeleteRouteCalculatorCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        await collectBody$3(output.body, context);
        return contents;
    };
    const de_DeleteTrackerCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        await collectBody$3(output.body, context);
        return contents;
    };
    const de_DescribeGeofenceCollectionCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            CollectionArn: expectString$3,
            CollectionName: expectString$3,
            CreateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
            Description: expectString$3,
            GeofenceCount: expectInt32$1,
            KmsKeyId: expectString$3,
            PricingPlan: expectString$3,
            PricingPlanDataSource: expectString$3,
            Tags: _json$2,
            UpdateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_DescribeKeyCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            CreateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
            Description: expectString$3,
            ExpireTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
            Key: expectString$3,
            KeyArn: expectString$3,
            KeyName: expectString$3,
            Restrictions: _json$2,
            Tags: _json$2,
            UpdateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_DescribeMapCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            Configuration: _json$2,
            CreateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
            DataSource: expectString$3,
            Description: expectString$3,
            MapArn: expectString$3,
            MapName: expectString$3,
            PricingPlan: expectString$3,
            Tags: _json$2,
            UpdateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_DescribePlaceIndexCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            CreateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
            DataSource: expectString$3,
            DataSourceConfiguration: _json$2,
            Description: expectString$3,
            IndexArn: expectString$3,
            IndexName: expectString$3,
            PricingPlan: expectString$3,
            Tags: _json$2,
            UpdateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_DescribeRouteCalculatorCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            CalculatorArn: expectString$3,
            CalculatorName: expectString$3,
            CreateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
            DataSource: expectString$3,
            Description: expectString$3,
            PricingPlan: expectString$3,
            Tags: _json$2,
            UpdateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_DescribeTrackerCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            CreateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
            Description: expectString$3,
            EventBridgeEnabled: expectBoolean$2,
            KmsKeyEnableGeospatialQueries: expectBoolean$2,
            KmsKeyId: expectString$3,
            PositionFiltering: expectString$3,
            PricingPlan: expectString$3,
            PricingPlanDataSource: expectString$3,
            Tags: _json$2,
            TrackerArn: expectString$3,
            TrackerName: expectString$3,
            UpdateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_DisassociateTrackerConsumerCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        await collectBody$3(output.body, context);
        return contents;
    };
    const de_ForecastGeofenceEventsCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            DistanceUnit: expectString$3,
            ForecastedEvents: (_) => de_ForecastedEventsList(_),
            NextToken: expectString$3,
            SpeedUnit: expectString$3,
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_GetDevicePositionCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            Accuracy: (_) => de_PositionalAccuracy(_),
            DeviceId: expectString$3,
            Position: (_) => de_Position$2(_),
            PositionProperties: _json$2,
            ReceivedTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
            SampleTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_GetDevicePositionHistoryCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            DevicePositions: (_) => de_DevicePositionList(_),
            NextToken: expectString$3,
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_GetGeofenceCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            CreateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
            GeofenceId: expectString$3,
            GeofenceProperties: _json$2,
            Geometry: (_) => de_GeofenceGeometry(_, context),
            Status: expectString$3,
            UpdateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_GetMapGlyphsCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
            [_CT]: [, output.headers[_ct]],
            [_CC]: [, output.headers[_cc]],
        });
        const data = await collectBody$3(output.body, context);
        contents.Blob = data;
        return contents;
    };
    const de_GetMapSpritesCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
            [_CT]: [, output.headers[_ct]],
            [_CC]: [, output.headers[_cc]],
        });
        const data = await collectBody$3(output.body, context);
        contents.Blob = data;
        return contents;
    };
    const de_GetMapStyleDescriptorCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
            [_CT]: [, output.headers[_ct]],
            [_CC]: [, output.headers[_cc]],
        });
        const data = await collectBody$3(output.body, context);
        contents.Blob = data;
        return contents;
    };
    const de_GetMapTileCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
            [_CT]: [, output.headers[_ct]],
            [_CC]: [, output.headers[_cc]],
        });
        const data = await collectBody$3(output.body, context);
        contents.Blob = data;
        return contents;
    };
    const de_GetPlaceCommand$1 = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            Place: (_) => de_Place(_),
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_ListDevicePositionsCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            Entries: (_) => de_ListDevicePositionsResponseEntryList(_),
            NextToken: expectString$3,
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_ListGeofenceCollectionsCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            Entries: (_) => de_ListGeofenceCollectionsResponseEntryList(_),
            NextToken: expectString$3,
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_ListGeofencesCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            Entries: (_) => de_ListGeofenceResponseEntryList(_, context),
            NextToken: expectString$3,
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_ListKeysCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            Entries: (_) => de_ListKeysResponseEntryList(_),
            NextToken: expectString$3,
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_ListMapsCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            Entries: (_) => de_ListMapsResponseEntryList(_),
            NextToken: expectString$3,
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_ListPlaceIndexesCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            Entries: (_) => de_ListPlaceIndexesResponseEntryList(_),
            NextToken: expectString$3,
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_ListRouteCalculatorsCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            Entries: (_) => de_ListRouteCalculatorsResponseEntryList(_),
            NextToken: expectString$3,
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_ListTagsForResourceCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            Tags: _json$2,
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_ListTrackerConsumersCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            ConsumerArns: _json$2,
            NextToken: expectString$3,
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_ListTrackersCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            Entries: (_) => de_ListTrackersResponseEntryList(_),
            NextToken: expectString$3,
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_PutGeofenceCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            CreateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
            GeofenceId: expectString$3,
            UpdateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_SearchPlaceIndexForPositionCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            Results: (_) => de_SearchForPositionResultList(_),
            Summary: (_) => de_SearchPlaceIndexForPositionSummary(_),
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_SearchPlaceIndexForSuggestionsCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            Results: _json$2,
            Summary: (_) => de_SearchPlaceIndexForSuggestionsSummary(_),
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_SearchPlaceIndexForTextCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            Results: (_) => de_SearchForTextResultList(_),
            Summary: (_) => de_SearchPlaceIndexForTextSummary(_),
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_TagResourceCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        await collectBody$3(output.body, context);
        return contents;
    };
    const de_UntagResourceCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        await collectBody$3(output.body, context);
        return contents;
    };
    const de_UpdateGeofenceCollectionCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            CollectionArn: expectString$3,
            CollectionName: expectString$3,
            UpdateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_UpdateKeyCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            KeyArn: expectString$3,
            KeyName: expectString$3,
            UpdateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_UpdateMapCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            MapArn: expectString$3,
            MapName: expectString$3,
            UpdateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_UpdatePlaceIndexCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            IndexArn: expectString$3,
            IndexName: expectString$3,
            UpdateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_UpdateRouteCalculatorCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            CalculatorArn: expectString$3,
            CalculatorName: expectString$3,
            UpdateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_UpdateTrackerCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            TrackerArn: expectString$3,
            TrackerName: expectString$3,
            UpdateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_VerifyDevicePositionCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CommandError$2(output, context);
        }
        const contents = map$3({
            $metadata: deserializeMetadata$8(output),
        });
        const data = expectNonNull$3(expectObject$2(await parseJsonBody(output.body, context)), "body");
        const doc = take$3(data, {
            DeviceId: expectString$3,
            DistanceUnit: expectString$3,
            InferredState: (_) => de_InferredState(_),
            ReceivedTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
            SampleTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_CommandError$2 = async (output, context) => {
        const parsedOutput = {
            ...output,
            body: await parseJsonErrorBody(output.body, context),
        };
        const errorCode = loadRestJsonErrorCode$3(output, parsedOutput.body);
        switch (errorCode) {
            case "AccessDeniedException":
            case "com.amazonaws.location#AccessDeniedException":
                throw await de_AccessDeniedExceptionRes$3(parsedOutput);
            case "ConflictException":
            case "com.amazonaws.location#ConflictException":
                throw await de_ConflictExceptionRes(parsedOutput);
            case "InternalServerException":
            case "com.amazonaws.location#InternalServerException":
                throw await de_InternalServerExceptionRes$3(parsedOutput);
            case "ResourceNotFoundException":
            case "com.amazonaws.location#ResourceNotFoundException":
                throw await de_ResourceNotFoundExceptionRes$2(parsedOutput);
            case "ServiceQuotaExceededException":
            case "com.amazonaws.location#ServiceQuotaExceededException":
                throw await de_ServiceQuotaExceededExceptionRes(parsedOutput);
            case "ThrottlingException":
            case "com.amazonaws.location#ThrottlingException":
                throw await de_ThrottlingExceptionRes$3(parsedOutput);
            case "ValidationException":
            case "com.amazonaws.location#ValidationException":
                throw await de_ValidationExceptionRes$3(parsedOutput);
            default:
                const parsedBody = parsedOutput.body;
                return throwDefaultError$8({
                    output,
                    parsedBody,
                    errorCode,
                });
        }
    };
    const throwDefaultError$8 = withBaseException$3(LocationServiceException);
    const de_AccessDeniedExceptionRes$3 = async (parsedOutput, context) => {
        const contents = map$3({});
        const data = parsedOutput.body;
        const doc = take$3(data, {
            Message: [, expectString$3, `message`],
        });
        Object.assign(contents, doc);
        const exception = new AccessDeniedException$3({
            $metadata: deserializeMetadata$8(parsedOutput),
            ...contents,
        });
        return decorateServiceException$3(exception, parsedOutput.body);
    };
    const de_ConflictExceptionRes = async (parsedOutput, context) => {
        const contents = map$3({});
        const data = parsedOutput.body;
        const doc = take$3(data, {
            Message: [, expectString$3, `message`],
        });
        Object.assign(contents, doc);
        const exception = new ConflictException({
            $metadata: deserializeMetadata$8(parsedOutput),
            ...contents,
        });
        return decorateServiceException$3(exception, parsedOutput.body);
    };
    const de_InternalServerExceptionRes$3 = async (parsedOutput, context) => {
        const contents = map$3({});
        const data = parsedOutput.body;
        const doc = take$3(data, {
            Message: [, expectString$3, `message`],
        });
        Object.assign(contents, doc);
        const exception = new InternalServerException$3({
            $metadata: deserializeMetadata$8(parsedOutput),
            ...contents,
        });
        return decorateServiceException$3(exception, parsedOutput.body);
    };
    const de_ResourceNotFoundExceptionRes$2 = async (parsedOutput, context) => {
        const contents = map$3({});
        const data = parsedOutput.body;
        const doc = take$3(data, {
            Message: [, expectString$3, `message`],
        });
        Object.assign(contents, doc);
        const exception = new ResourceNotFoundException$2({
            $metadata: deserializeMetadata$8(parsedOutput),
            ...contents,
        });
        return decorateServiceException$3(exception, parsedOutput.body);
    };
    const de_ServiceQuotaExceededExceptionRes = async (parsedOutput, context) => {
        const contents = map$3({});
        const data = parsedOutput.body;
        const doc = take$3(data, {
            Message: [, expectString$3, `message`],
        });
        Object.assign(contents, doc);
        const exception = new ServiceQuotaExceededException({
            $metadata: deserializeMetadata$8(parsedOutput),
            ...contents,
        });
        return decorateServiceException$3(exception, parsedOutput.body);
    };
    const de_ThrottlingExceptionRes$3 = async (parsedOutput, context) => {
        const contents = map$3({});
        const data = parsedOutput.body;
        const doc = take$3(data, {
            Message: [, expectString$3, `message`],
        });
        Object.assign(contents, doc);
        const exception = new ThrottlingException$3({
            $metadata: deserializeMetadata$8(parsedOutput),
            ...contents,
        });
        return decorateServiceException$3(exception, parsedOutput.body);
    };
    const de_ValidationExceptionRes$3 = async (parsedOutput, context) => {
        const contents = map$3({});
        const data = parsedOutput.body;
        const doc = take$3(data, {
            FieldList: [, (_) => de_ValidationExceptionFieldList$3(_), `fieldList`],
            Message: [, expectString$3, `message`],
            Reason: [, expectString$3, `reason`],
        });
        Object.assign(contents, doc);
        const exception = new ValidationException$3({
            $metadata: deserializeMetadata$8(parsedOutput),
            ...contents,
        });
        return decorateServiceException$3(exception, parsedOutput.body);
    };
    const se_BatchPutGeofenceRequestEntry = (input, context) => {
        return take$3(input, {
            GeofenceId: [],
            GeofenceProperties: _json$2,
            Geometry: (_) => se_GeofenceGeometry(_, context),
        });
    };
    const se_BatchPutGeofenceRequestEntryList = (input, context) => {
        return input
            .filter((e) => e != null)
            .map((entry) => {
            return se_BatchPutGeofenceRequestEntry(entry, context);
        });
    };
    const se_BoundingBox$2 = (input, context) => {
        return input
            .filter((e) => e != null)
            .map((entry) => {
            return serializeFloat$2(entry);
        });
    };
    const se_CalculateRouteTruckModeOptions = (input, context) => {
        return take$3(input, {
            AvoidFerries: [],
            AvoidTolls: [],
            Dimensions: (_) => se_TruckDimensions(_),
            Weight: (_) => se_TruckWeight(_),
        });
    };
    const se_CellSignals = (input, context) => {
        return take$3(input, {
            LteCellDetails: (_) => se_LteCellDetailsList(_),
        });
    };
    const se_Circle$1 = (input, context) => {
        return take$3(input, {
            Center: (_) => se_Position$2(_),
            Radius: serializeFloat$2,
        });
    };
    const se_DevicePositionUpdate = (input, context) => {
        return take$3(input, {
            Accuracy: (_) => se_PositionalAccuracy(_),
            DeviceId: [],
            Position: (_) => se_Position$2(_),
            PositionProperties: _json$2,
            SampleTime: serializeDateTime,
        });
    };
    const se_DevicePositionUpdateList = (input, context) => {
        return input
            .filter((e) => e != null)
            .map((entry) => {
            return se_DevicePositionUpdate(entry);
        });
    };
    const se_DeviceState = (input, context) => {
        return take$3(input, {
            Accuracy: (_) => se_PositionalAccuracy(_),
            CellSignals: (_) => se_CellSignals(_),
            DeviceId: [],
            Ipv4Address: [],
            Position: (_) => se_Position$2(_),
            SampleTime: serializeDateTime,
            WiFiAccessPoints: _json$2,
        });
    };
    const se_ForecastGeofenceEventsDeviceState = (input, context) => {
        return take$3(input, {
            Position: (_) => se_Position$2(_),
            Speed: serializeFloat$2,
        });
    };
    const se_GeofenceGeometry = (input, context) => {
        return take$3(input, {
            Circle: (_) => se_Circle$1(_),
            Geobuf: context.base64Encoder,
            Polygon: (_) => se_LinearRings$1(_),
        });
    };
    const se_LinearRing$1 = (input, context) => {
        return input
            .filter((e) => e != null)
            .map((entry) => {
            return se_Position$2(entry);
        });
    };
    const se_LinearRings$1 = (input, context) => {
        return input
            .filter((e) => e != null)
            .map((entry) => {
            return se_LinearRing$1(entry);
        });
    };
    const se_LteCellDetails = (input, context) => {
        return take$3(input, {
            CellId: [],
            LocalId: _json$2,
            Mcc: [],
            Mnc: [],
            NetworkMeasurements: (_) => se_LteNetworkMeasurementsList(_),
            NrCapable: [],
            Rsrp: [],
            Rsrq: serializeFloat$2,
            Tac: [],
            TimingAdvance: [],
        });
    };
    const se_LteCellDetailsList = (input, context) => {
        return input
            .filter((e) => e != null)
            .map((entry) => {
            return se_LteCellDetails(entry);
        });
    };
    const se_LteNetworkMeasurements = (input, context) => {
        return take$3(input, {
            CellId: [],
            Earfcn: [],
            Pci: [],
            Rsrp: [],
            Rsrq: serializeFloat$2,
        });
    };
    const se_LteNetworkMeasurementsList = (input, context) => {
        return input
            .filter((e) => e != null)
            .map((entry) => {
            return se_LteNetworkMeasurements(entry);
        });
    };
    const se_Position$2 = (input, context) => {
        return input
            .filter((e) => e != null)
            .map((entry) => {
            return serializeFloat$2(entry);
        });
    };
    const se_PositionalAccuracy = (input, context) => {
        return take$3(input, {
            Horizontal: serializeFloat$2,
        });
    };
    const se_PositionList = (input, context) => {
        return input
            .filter((e) => e != null)
            .map((entry) => {
            return se_Position$2(entry);
        });
    };
    const se_TrackingFilterGeometry = (input, context) => {
        return take$3(input, {
            Polygon: (_) => se_LinearRings$1(_),
        });
    };
    const se_TruckDimensions = (input, context) => {
        return take$3(input, {
            Height: serializeFloat$2,
            Length: serializeFloat$2,
            Unit: [],
            Width: serializeFloat$2,
        });
    };
    const se_TruckWeight = (input, context) => {
        return take$3(input, {
            Total: serializeFloat$2,
            Unit: [],
        });
    };
    const se_WaypointPositionList = (input, context) => {
        return input
            .filter((e) => e != null)
            .map((entry) => {
            return se_Position$2(entry);
        });
    };
    const de_BatchEvaluateGeofencesError = (output, context) => {
        return take$3(output, {
            DeviceId: expectString$3,
            Error: _json$2,
            SampleTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
        });
    };
    const de_BatchEvaluateGeofencesErrorList = (output, context) => {
        const retVal = (output || [])
            .filter((e) => e != null)
            .map((entry) => {
            return de_BatchEvaluateGeofencesError(entry);
        });
        return retVal;
    };
    const de_BatchPutGeofenceSuccess = (output, context) => {
        return take$3(output, {
            CreateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
            GeofenceId: expectString$3,
            UpdateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
        });
    };
    const de_BatchPutGeofenceSuccessList = (output, context) => {
        const retVal = (output || [])
            .filter((e) => e != null)
            .map((entry) => {
            return de_BatchPutGeofenceSuccess(entry);
        });
        return retVal;
    };
    const de_BatchUpdateDevicePositionError = (output, context) => {
        return take$3(output, {
            DeviceId: expectString$3,
            Error: _json$2,
            SampleTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
        });
    };
    const de_BatchUpdateDevicePositionErrorList = (output, context) => {
        const retVal = (output || [])
            .filter((e) => e != null)
            .map((entry) => {
            return de_BatchUpdateDevicePositionError(entry);
        });
        return retVal;
    };
    const de_BoundingBox$2 = (output, context) => {
        const retVal = (output || [])
            .filter((e) => e != null)
            .map((entry) => {
            return limitedParseDouble$2(entry);
        });
        return retVal;
    };
    const de_CalculateRouteSummary = (output, context) => {
        return take$3(output, {
            DataSource: expectString$3,
            Distance: limitedParseDouble$2,
            DistanceUnit: expectString$3,
            DurationSeconds: limitedParseDouble$2,
            RouteBBox: (_) => de_BoundingBox$2(_),
        });
    };
    const de_Circle$1 = (output, context) => {
        return take$3(output, {
            Center: (_) => de_Position$2(_),
            Radius: limitedParseDouble$2,
        });
    };
    const de_DevicePosition = (output, context) => {
        return take$3(output, {
            Accuracy: (_) => de_PositionalAccuracy(_),
            DeviceId: expectString$3,
            Position: (_) => de_Position$2(_),
            PositionProperties: _json$2,
            ReceivedTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
            SampleTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
        });
    };
    const de_DevicePositionList = (output, context) => {
        const retVal = (output || [])
            .filter((e) => e != null)
            .map((entry) => {
            return de_DevicePosition(entry);
        });
        return retVal;
    };
    const de_ForecastedEvent = (output, context) => {
        return take$3(output, {
            EventId: expectString$3,
            EventType: expectString$3,
            ForecastedBreachTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
            GeofenceId: expectString$3,
            GeofenceProperties: _json$2,
            IsDeviceInGeofence: expectBoolean$2,
            NearestDistance: limitedParseDouble$2,
        });
    };
    const de_ForecastedEventsList = (output, context) => {
        const retVal = (output || [])
            .filter((e) => e != null)
            .map((entry) => {
            return de_ForecastedEvent(entry);
        });
        return retVal;
    };
    const de_GeofenceGeometry = (output, context) => {
        return take$3(output, {
            Circle: (_) => de_Circle$1(_),
            Geobuf: context.base64Decoder,
            Polygon: (_) => de_LinearRings$1(_),
        });
    };
    const de_InferredState = (output, context) => {
        return take$3(output, {
            Accuracy: (_) => de_PositionalAccuracy(_),
            DeviationDistance: limitedParseDouble$2,
            Position: (_) => de_Position$2(_),
            ProxyDetected: expectBoolean$2,
        });
    };
    const de_Leg = (output, context) => {
        return take$3(output, {
            Distance: limitedParseDouble$2,
            DurationSeconds: limitedParseDouble$2,
            EndPosition: (_) => de_Position$2(_),
            Geometry: (_) => de_LegGeometry(_),
            StartPosition: (_) => de_Position$2(_),
            Steps: (_) => de_StepList(_),
        });
    };
    const de_LegGeometry = (output, context) => {
        return take$3(output, {
            LineString: (_) => de_LineString$1(_),
        });
    };
    const de_LegList = (output, context) => {
        const retVal = (output || [])
            .filter((e) => e != null)
            .map((entry) => {
            return de_Leg(entry);
        });
        return retVal;
    };
    const de_LinearRing$1 = (output, context) => {
        const retVal = (output || [])
            .filter((e) => e != null)
            .map((entry) => {
            return de_Position$2(entry);
        });
        return retVal;
    };
    const de_LinearRings$1 = (output, context) => {
        const retVal = (output || [])
            .filter((e) => e != null)
            .map((entry) => {
            return de_LinearRing$1(entry);
        });
        return retVal;
    };
    const de_LineString$1 = (output, context) => {
        const retVal = (output || [])
            .filter((e) => e != null)
            .map((entry) => {
            return de_Position$2(entry);
        });
        return retVal;
    };
    const de_ListDevicePositionsResponseEntry = (output, context) => {
        return take$3(output, {
            Accuracy: (_) => de_PositionalAccuracy(_),
            DeviceId: expectString$3,
            Position: (_) => de_Position$2(_),
            PositionProperties: _json$2,
            SampleTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
        });
    };
    const de_ListDevicePositionsResponseEntryList = (output, context) => {
        const retVal = (output || [])
            .filter((e) => e != null)
            .map((entry) => {
            return de_ListDevicePositionsResponseEntry(entry);
        });
        return retVal;
    };
    const de_ListGeofenceCollectionsResponseEntry = (output, context) => {
        return take$3(output, {
            CollectionName: expectString$3,
            CreateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
            Description: expectString$3,
            PricingPlan: expectString$3,
            PricingPlanDataSource: expectString$3,
            UpdateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
        });
    };
    const de_ListGeofenceCollectionsResponseEntryList = (output, context) => {
        const retVal = (output || [])
            .filter((e) => e != null)
            .map((entry) => {
            return de_ListGeofenceCollectionsResponseEntry(entry);
        });
        return retVal;
    };
    const de_ListGeofenceResponseEntry = (output, context) => {
        return take$3(output, {
            CreateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
            GeofenceId: expectString$3,
            GeofenceProperties: _json$2,
            Geometry: (_) => de_GeofenceGeometry(_, context),
            Status: expectString$3,
            UpdateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
        });
    };
    const de_ListGeofenceResponseEntryList = (output, context) => {
        const retVal = (output || [])
            .filter((e) => e != null)
            .map((entry) => {
            return de_ListGeofenceResponseEntry(entry, context);
        });
        return retVal;
    };
    const de_ListKeysResponseEntry = (output, context) => {
        return take$3(output, {
            CreateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
            Description: expectString$3,
            ExpireTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
            KeyName: expectString$3,
            Restrictions: _json$2,
            UpdateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
        });
    };
    const de_ListKeysResponseEntryList = (output, context) => {
        const retVal = (output || [])
            .filter((e) => e != null)
            .map((entry) => {
            return de_ListKeysResponseEntry(entry);
        });
        return retVal;
    };
    const de_ListMapsResponseEntry = (output, context) => {
        return take$3(output, {
            CreateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
            DataSource: expectString$3,
            Description: expectString$3,
            MapName: expectString$3,
            PricingPlan: expectString$3,
            UpdateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
        });
    };
    const de_ListMapsResponseEntryList = (output, context) => {
        const retVal = (output || [])
            .filter((e) => e != null)
            .map((entry) => {
            return de_ListMapsResponseEntry(entry);
        });
        return retVal;
    };
    const de_ListPlaceIndexesResponseEntry = (output, context) => {
        return take$3(output, {
            CreateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
            DataSource: expectString$3,
            Description: expectString$3,
            IndexName: expectString$3,
            PricingPlan: expectString$3,
            UpdateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
        });
    };
    const de_ListPlaceIndexesResponseEntryList = (output, context) => {
        const retVal = (output || [])
            .filter((e) => e != null)
            .map((entry) => {
            return de_ListPlaceIndexesResponseEntry(entry);
        });
        return retVal;
    };
    const de_ListRouteCalculatorsResponseEntry = (output, context) => {
        return take$3(output, {
            CalculatorName: expectString$3,
            CreateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
            DataSource: expectString$3,
            Description: expectString$3,
            PricingPlan: expectString$3,
            UpdateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
        });
    };
    const de_ListRouteCalculatorsResponseEntryList = (output, context) => {
        const retVal = (output || [])
            .filter((e) => e != null)
            .map((entry) => {
            return de_ListRouteCalculatorsResponseEntry(entry);
        });
        return retVal;
    };
    const de_ListTrackersResponseEntry = (output, context) => {
        return take$3(output, {
            CreateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
            Description: expectString$3,
            PricingPlan: expectString$3,
            PricingPlanDataSource: expectString$3,
            TrackerName: expectString$3,
            UpdateTime: (_) => expectNonNull$3(parseRfc3339DateTimeWithOffset(_)),
        });
    };
    const de_ListTrackersResponseEntryList = (output, context) => {
        const retVal = (output || [])
            .filter((e) => e != null)
            .map((entry) => {
            return de_ListTrackersResponseEntry(entry);
        });
        return retVal;
    };
    const de_Place = (output, context) => {
        return take$3(output, {
            AddressNumber: expectString$3,
            Categories: _json$2,
            Country: expectString$3,
            Geometry: (_) => de_PlaceGeometry(_),
            Interpolated: expectBoolean$2,
            Label: expectString$3,
            Municipality: expectString$3,
            Neighborhood: expectString$3,
            PostalCode: expectString$3,
            Region: expectString$3,
            Street: expectString$3,
            SubMunicipality: expectString$3,
            SubRegion: expectString$3,
            SupplementalCategories: _json$2,
            TimeZone: _json$2,
            UnitNumber: expectString$3,
            UnitType: expectString$3,
        });
    };
    const de_PlaceGeometry = (output, context) => {
        return take$3(output, {
            Point: (_) => de_Position$2(_),
        });
    };
    const de_Position$2 = (output, context) => {
        const retVal = (output || [])
            .filter((e) => e != null)
            .map((entry) => {
            return limitedParseDouble$2(entry);
        });
        return retVal;
    };
    const de_PositionalAccuracy = (output, context) => {
        return take$3(output, {
            Horizontal: limitedParseDouble$2,
        });
    };
    const de_PositionList = (output, context) => {
        const retVal = (output || [])
            .filter((e) => e != null)
            .map((entry) => {
            return de_Position$2(entry);
        });
        return retVal;
    };
    const de_RouteMatrix = (output, context) => {
        const retVal = (output || [])
            .filter((e) => e != null)
            .map((entry) => {
            return de_RouteMatrixRow(entry);
        });
        return retVal;
    };
    const de_RouteMatrixEntry = (output, context) => {
        return take$3(output, {
            Distance: limitedParseDouble$2,
            DurationSeconds: limitedParseDouble$2,
            Error: _json$2,
        });
    };
    const de_RouteMatrixRow = (output, context) => {
        const retVal = (output || [])
            .filter((e) => e != null)
            .map((entry) => {
            return de_RouteMatrixEntry(entry);
        });
        return retVal;
    };
    const de_SearchForPositionResult = (output, context) => {
        return take$3(output, {
            Distance: limitedParseDouble$2,
            Place: (_) => de_Place(_),
            PlaceId: expectString$3,
        });
    };
    const de_SearchForPositionResultList = (output, context) => {
        const retVal = (output || [])
            .filter((e) => e != null)
            .map((entry) => {
            return de_SearchForPositionResult(entry);
        });
        return retVal;
    };
    const de_SearchForTextResult = (output, context) => {
        return take$3(output, {
            Distance: limitedParseDouble$2,
            Place: (_) => de_Place(_),
            PlaceId: expectString$3,
            Relevance: limitedParseDouble$2,
        });
    };
    const de_SearchForTextResultList = (output, context) => {
        const retVal = (output || [])
            .filter((e) => e != null)
            .map((entry) => {
            return de_SearchForTextResult(entry);
        });
        return retVal;
    };
    const de_SearchPlaceIndexForPositionSummary = (output, context) => {
        return take$3(output, {
            DataSource: expectString$3,
            Language: expectString$3,
            MaxResults: expectInt32$1,
            Position: (_) => de_Position$2(_),
        });
    };
    const de_SearchPlaceIndexForSuggestionsSummary = (output, context) => {
        return take$3(output, {
            BiasPosition: (_) => de_Position$2(_),
            DataSource: expectString$3,
            FilterBBox: (_) => de_BoundingBox$2(_),
            FilterCategories: _json$2,
            FilterCountries: _json$2,
            Language: expectString$3,
            MaxResults: expectInt32$1,
            Text: expectString$3,
        });
    };
    const de_SearchPlaceIndexForTextSummary = (output, context) => {
        return take$3(output, {
            BiasPosition: (_) => de_Position$2(_),
            DataSource: expectString$3,
            FilterBBox: (_) => de_BoundingBox$2(_),
            FilterCategories: _json$2,
            FilterCountries: _json$2,
            Language: expectString$3,
            MaxResults: expectInt32$1,
            ResultBBox: (_) => de_BoundingBox$2(_),
            Text: expectString$3,
        });
    };
    const de_Step = (output, context) => {
        return take$3(output, {
            Distance: limitedParseDouble$2,
            DurationSeconds: limitedParseDouble$2,
            EndPosition: (_) => de_Position$2(_),
            GeometryOffset: expectInt32$1,
            StartPosition: (_) => de_Position$2(_),
        });
    };
    const de_StepList = (output, context) => {
        const retVal = (output || [])
            .filter((e) => e != null)
            .map((entry) => {
            return de_Step(entry);
        });
        return retVal;
    };
    const de_ValidationExceptionField$3 = (output, context) => {
        return take$3(output, {
            Message: [, expectString$3, `message`],
            Name: [, expectString$3, `name`],
        });
    };
    const de_ValidationExceptionFieldList$3 = (output, context) => {
        const retVal = (output || [])
            .filter((e) => e != null)
            .map((entry) => {
            return de_ValidationExceptionField$3(entry);
        });
        return retVal;
    };
    const deserializeMetadata$8 = (output) => ({
        httpStatusCode: output.statusCode,
        requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
        extendedRequestId: output.headers["x-amz-id-2"],
        cfId: output.headers["x-amz-cf-id"],
    });
    const _CC = "CacheControl";
    const _CT = "ContentType";
    const _FD = "ForceDelete";
    const _K$1 = "Key";
    const _L = "Language";
    const _TK = "TagKeys";
    const _cc = "cache-control";
    const _ct = "content-type";
    const _fD = "forceDelete";
    const _k = "key";
    const _l = "language";
    const _tK = "tagKeys";

    class AssociateTrackerConsumerCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "AssociateTrackerConsumer", {})
        .n("LocationClient", "AssociateTrackerConsumerCommand")
        .f(void 0, void 0)
        .ser(se_AssociateTrackerConsumerCommand)
        .de(de_AssociateTrackerConsumerCommand)
        .build() {
    }

    class BatchDeleteDevicePositionHistoryCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "BatchDeleteDevicePositionHistory", {})
        .n("LocationClient", "BatchDeleteDevicePositionHistoryCommand")
        .f(void 0, void 0)
        .ser(se_BatchDeleteDevicePositionHistoryCommand)
        .de(de_BatchDeleteDevicePositionHistoryCommand)
        .build() {
    }

    class BatchDeleteGeofenceCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "BatchDeleteGeofence", {})
        .n("LocationClient", "BatchDeleteGeofenceCommand")
        .f(void 0, void 0)
        .ser(se_BatchDeleteGeofenceCommand)
        .de(de_BatchDeleteGeofenceCommand)
        .build() {
    }

    class BatchEvaluateGeofencesCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "BatchEvaluateGeofences", {})
        .n("LocationClient", "BatchEvaluateGeofencesCommand")
        .f(BatchEvaluateGeofencesRequestFilterSensitiveLog, void 0)
        .ser(se_BatchEvaluateGeofencesCommand)
        .de(de_BatchEvaluateGeofencesCommand)
        .build() {
    }

    class BatchGetDevicePositionCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "BatchGetDevicePosition", {})
        .n("LocationClient", "BatchGetDevicePositionCommand")
        .f(void 0, BatchGetDevicePositionResponseFilterSensitiveLog)
        .ser(se_BatchGetDevicePositionCommand)
        .de(de_BatchGetDevicePositionCommand)
        .build() {
    }

    class BatchPutGeofenceCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "BatchPutGeofence", {})
        .n("LocationClient", "BatchPutGeofenceCommand")
        .f(BatchPutGeofenceRequestFilterSensitiveLog, void 0)
        .ser(se_BatchPutGeofenceCommand)
        .de(de_BatchPutGeofenceCommand)
        .build() {
    }

    class BatchUpdateDevicePositionCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "BatchUpdateDevicePosition", {})
        .n("LocationClient", "BatchUpdateDevicePositionCommand")
        .f(BatchUpdateDevicePositionRequestFilterSensitiveLog, void 0)
        .ser(se_BatchUpdateDevicePositionCommand)
        .de(de_BatchUpdateDevicePositionCommand)
        .build() {
    }

    class CalculateRouteCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "CalculateRoute", {})
        .n("LocationClient", "CalculateRouteCommand")
        .f(CalculateRouteRequestFilterSensitiveLog, CalculateRouteResponseFilterSensitiveLog)
        .ser(se_CalculateRouteCommand)
        .de(de_CalculateRouteCommand)
        .build() {
    }

    let CalculateRouteMatrixCommand$1 = class CalculateRouteMatrixCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "CalculateRouteMatrix", {})
        .n("LocationClient", "CalculateRouteMatrixCommand")
        .f(CalculateRouteMatrixRequestFilterSensitiveLog$1, CalculateRouteMatrixResponseFilterSensitiveLog$1)
        .ser(se_CalculateRouteMatrixCommand$1)
        .de(de_CalculateRouteMatrixCommand$1)
        .build() {
    };

    class CreateGeofenceCollectionCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "CreateGeofenceCollection", {})
        .n("LocationClient", "CreateGeofenceCollectionCommand")
        .f(void 0, void 0)
        .ser(se_CreateGeofenceCollectionCommand)
        .de(de_CreateGeofenceCollectionCommand)
        .build() {
    }

    class CreateKeyCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "CreateKey", {})
        .n("LocationClient", "CreateKeyCommand")
        .f(void 0, CreateKeyResponseFilterSensitiveLog)
        .ser(se_CreateKeyCommand)
        .de(de_CreateKeyCommand)
        .build() {
    }

    class CreateMapCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "CreateMap", {})
        .n("LocationClient", "CreateMapCommand")
        .f(void 0, void 0)
        .ser(se_CreateMapCommand)
        .de(de_CreateMapCommand)
        .build() {
    }

    class CreatePlaceIndexCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "CreatePlaceIndex", {})
        .n("LocationClient", "CreatePlaceIndexCommand")
        .f(void 0, void 0)
        .ser(se_CreatePlaceIndexCommand)
        .de(de_CreatePlaceIndexCommand)
        .build() {
    }

    class CreateRouteCalculatorCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "CreateRouteCalculator", {})
        .n("LocationClient", "CreateRouteCalculatorCommand")
        .f(void 0, void 0)
        .ser(se_CreateRouteCalculatorCommand)
        .de(de_CreateRouteCalculatorCommand)
        .build() {
    }

    class CreateTrackerCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "CreateTracker", {})
        .n("LocationClient", "CreateTrackerCommand")
        .f(void 0, void 0)
        .ser(se_CreateTrackerCommand)
        .de(de_CreateTrackerCommand)
        .build() {
    }

    class DeleteGeofenceCollectionCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "DeleteGeofenceCollection", {})
        .n("LocationClient", "DeleteGeofenceCollectionCommand")
        .f(void 0, void 0)
        .ser(se_DeleteGeofenceCollectionCommand)
        .de(de_DeleteGeofenceCollectionCommand)
        .build() {
    }

    class DeleteKeyCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "DeleteKey", {})
        .n("LocationClient", "DeleteKeyCommand")
        .f(void 0, void 0)
        .ser(se_DeleteKeyCommand)
        .de(de_DeleteKeyCommand)
        .build() {
    }

    class DeleteMapCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "DeleteMap", {})
        .n("LocationClient", "DeleteMapCommand")
        .f(void 0, void 0)
        .ser(se_DeleteMapCommand)
        .de(de_DeleteMapCommand)
        .build() {
    }

    class DeletePlaceIndexCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "DeletePlaceIndex", {})
        .n("LocationClient", "DeletePlaceIndexCommand")
        .f(void 0, void 0)
        .ser(se_DeletePlaceIndexCommand)
        .de(de_DeletePlaceIndexCommand)
        .build() {
    }

    class DeleteRouteCalculatorCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "DeleteRouteCalculator", {})
        .n("LocationClient", "DeleteRouteCalculatorCommand")
        .f(void 0, void 0)
        .ser(se_DeleteRouteCalculatorCommand)
        .de(de_DeleteRouteCalculatorCommand)
        .build() {
    }

    class DeleteTrackerCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "DeleteTracker", {})
        .n("LocationClient", "DeleteTrackerCommand")
        .f(void 0, void 0)
        .ser(se_DeleteTrackerCommand)
        .de(de_DeleteTrackerCommand)
        .build() {
    }

    class DescribeGeofenceCollectionCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "DescribeGeofenceCollection", {})
        .n("LocationClient", "DescribeGeofenceCollectionCommand")
        .f(void 0, void 0)
        .ser(se_DescribeGeofenceCollectionCommand)
        .de(de_DescribeGeofenceCollectionCommand)
        .build() {
    }

    class DescribeKeyCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "DescribeKey", {})
        .n("LocationClient", "DescribeKeyCommand")
        .f(void 0, DescribeKeyResponseFilterSensitiveLog)
        .ser(se_DescribeKeyCommand)
        .de(de_DescribeKeyCommand)
        .build() {
    }

    class DescribeMapCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "DescribeMap", {})
        .n("LocationClient", "DescribeMapCommand")
        .f(void 0, void 0)
        .ser(se_DescribeMapCommand)
        .de(de_DescribeMapCommand)
        .build() {
    }

    class DescribePlaceIndexCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "DescribePlaceIndex", {})
        .n("LocationClient", "DescribePlaceIndexCommand")
        .f(void 0, void 0)
        .ser(se_DescribePlaceIndexCommand)
        .de(de_DescribePlaceIndexCommand)
        .build() {
    }

    class DescribeRouteCalculatorCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "DescribeRouteCalculator", {})
        .n("LocationClient", "DescribeRouteCalculatorCommand")
        .f(void 0, void 0)
        .ser(se_DescribeRouteCalculatorCommand)
        .de(de_DescribeRouteCalculatorCommand)
        .build() {
    }

    class DescribeTrackerCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "DescribeTracker", {})
        .n("LocationClient", "DescribeTrackerCommand")
        .f(void 0, void 0)
        .ser(se_DescribeTrackerCommand)
        .de(de_DescribeTrackerCommand)
        .build() {
    }

    class DisassociateTrackerConsumerCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "DisassociateTrackerConsumer", {})
        .n("LocationClient", "DisassociateTrackerConsumerCommand")
        .f(void 0, void 0)
        .ser(se_DisassociateTrackerConsumerCommand)
        .de(de_DisassociateTrackerConsumerCommand)
        .build() {
    }

    class ForecastGeofenceEventsCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "ForecastGeofenceEvents", {})
        .n("LocationClient", "ForecastGeofenceEventsCommand")
        .f(ForecastGeofenceEventsRequestFilterSensitiveLog, ForecastGeofenceEventsResponseFilterSensitiveLog)
        .ser(se_ForecastGeofenceEventsCommand)
        .de(de_ForecastGeofenceEventsCommand)
        .build() {
    }

    class GetDevicePositionCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "GetDevicePosition", {})
        .n("LocationClient", "GetDevicePositionCommand")
        .f(void 0, GetDevicePositionResponseFilterSensitiveLog)
        .ser(se_GetDevicePositionCommand)
        .de(de_GetDevicePositionCommand)
        .build() {
    }

    class GetDevicePositionHistoryCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "GetDevicePositionHistory", {})
        .n("LocationClient", "GetDevicePositionHistoryCommand")
        .f(void 0, GetDevicePositionHistoryResponseFilterSensitiveLog)
        .ser(se_GetDevicePositionHistoryCommand)
        .de(de_GetDevicePositionHistoryCommand)
        .build() {
    }

    class GetGeofenceCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "GetGeofence", {})
        .n("LocationClient", "GetGeofenceCommand")
        .f(void 0, GetGeofenceResponseFilterSensitiveLog)
        .ser(se_GetGeofenceCommand)
        .de(de_GetGeofenceCommand)
        .build() {
    }

    class GetMapGlyphsCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "GetMapGlyphs", {})
        .n("LocationClient", "GetMapGlyphsCommand")
        .f(GetMapGlyphsRequestFilterSensitiveLog, void 0)
        .ser(se_GetMapGlyphsCommand)
        .de(de_GetMapGlyphsCommand)
        .build() {
    }

    class GetMapSpritesCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "GetMapSprites", {})
        .n("LocationClient", "GetMapSpritesCommand")
        .f(GetMapSpritesRequestFilterSensitiveLog, void 0)
        .ser(se_GetMapSpritesCommand)
        .de(de_GetMapSpritesCommand)
        .build() {
    }

    class GetMapStyleDescriptorCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "GetMapStyleDescriptor", {})
        .n("LocationClient", "GetMapStyleDescriptorCommand")
        .f(GetMapStyleDescriptorRequestFilterSensitiveLog, void 0)
        .ser(se_GetMapStyleDescriptorCommand)
        .de(de_GetMapStyleDescriptorCommand)
        .build() {
    }

    class GetMapTileCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "GetMapTile", {})
        .n("LocationClient", "GetMapTileCommand")
        .f(GetMapTileRequestFilterSensitiveLog, void 0)
        .ser(se_GetMapTileCommand)
        .de(de_GetMapTileCommand)
        .build() {
    }

    let GetPlaceCommand$1 = class GetPlaceCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "GetPlace", {})
        .n("LocationClient", "GetPlaceCommand")
        .f(GetPlaceRequestFilterSensitiveLog$1, GetPlaceResponseFilterSensitiveLog$1)
        .ser(se_GetPlaceCommand$1)
        .de(de_GetPlaceCommand$1)
        .build() {
    };

    class ListDevicePositionsCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "ListDevicePositions", {})
        .n("LocationClient", "ListDevicePositionsCommand")
        .f(ListDevicePositionsRequestFilterSensitiveLog, ListDevicePositionsResponseFilterSensitiveLog)
        .ser(se_ListDevicePositionsCommand)
        .de(de_ListDevicePositionsCommand)
        .build() {
    }

    class ListGeofenceCollectionsCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "ListGeofenceCollections", {})
        .n("LocationClient", "ListGeofenceCollectionsCommand")
        .f(void 0, void 0)
        .ser(se_ListGeofenceCollectionsCommand)
        .de(de_ListGeofenceCollectionsCommand)
        .build() {
    }

    class ListGeofencesCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "ListGeofences", {})
        .n("LocationClient", "ListGeofencesCommand")
        .f(void 0, ListGeofencesResponseFilterSensitiveLog)
        .ser(se_ListGeofencesCommand)
        .de(de_ListGeofencesCommand)
        .build() {
    }

    class ListKeysCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "ListKeys", {})
        .n("LocationClient", "ListKeysCommand")
        .f(void 0, void 0)
        .ser(se_ListKeysCommand)
        .de(de_ListKeysCommand)
        .build() {
    }

    class ListMapsCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "ListMaps", {})
        .n("LocationClient", "ListMapsCommand")
        .f(void 0, void 0)
        .ser(se_ListMapsCommand)
        .de(de_ListMapsCommand)
        .build() {
    }

    class ListPlaceIndexesCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "ListPlaceIndexes", {})
        .n("LocationClient", "ListPlaceIndexesCommand")
        .f(void 0, void 0)
        .ser(se_ListPlaceIndexesCommand)
        .de(de_ListPlaceIndexesCommand)
        .build() {
    }

    class ListRouteCalculatorsCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "ListRouteCalculators", {})
        .n("LocationClient", "ListRouteCalculatorsCommand")
        .f(void 0, void 0)
        .ser(se_ListRouteCalculatorsCommand)
        .de(de_ListRouteCalculatorsCommand)
        .build() {
    }

    class ListTagsForResourceCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "ListTagsForResource", {})
        .n("LocationClient", "ListTagsForResourceCommand")
        .f(void 0, void 0)
        .ser(se_ListTagsForResourceCommand)
        .de(de_ListTagsForResourceCommand)
        .build() {
    }

    class ListTrackerConsumersCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "ListTrackerConsumers", {})
        .n("LocationClient", "ListTrackerConsumersCommand")
        .f(void 0, void 0)
        .ser(se_ListTrackerConsumersCommand)
        .de(de_ListTrackerConsumersCommand)
        .build() {
    }

    class ListTrackersCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "ListTrackers", {})
        .n("LocationClient", "ListTrackersCommand")
        .f(void 0, void 0)
        .ser(se_ListTrackersCommand)
        .de(de_ListTrackersCommand)
        .build() {
    }

    class PutGeofenceCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "PutGeofence", {})
        .n("LocationClient", "PutGeofenceCommand")
        .f(PutGeofenceRequestFilterSensitiveLog, void 0)
        .ser(se_PutGeofenceCommand)
        .de(de_PutGeofenceCommand)
        .build() {
    }

    class SearchPlaceIndexForPositionCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "SearchPlaceIndexForPosition", {})
        .n("LocationClient", "SearchPlaceIndexForPositionCommand")
        .f(SearchPlaceIndexForPositionRequestFilterSensitiveLog, SearchPlaceIndexForPositionResponseFilterSensitiveLog)
        .ser(se_SearchPlaceIndexForPositionCommand)
        .de(de_SearchPlaceIndexForPositionCommand)
        .build() {
    }

    class SearchPlaceIndexForSuggestionsCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "SearchPlaceIndexForSuggestions", {})
        .n("LocationClient", "SearchPlaceIndexForSuggestionsCommand")
        .f(SearchPlaceIndexForSuggestionsRequestFilterSensitiveLog, SearchPlaceIndexForSuggestionsResponseFilterSensitiveLog)
        .ser(se_SearchPlaceIndexForSuggestionsCommand)
        .de(de_SearchPlaceIndexForSuggestionsCommand)
        .build() {
    }

    class SearchPlaceIndexForTextCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "SearchPlaceIndexForText", {})
        .n("LocationClient", "SearchPlaceIndexForTextCommand")
        .f(SearchPlaceIndexForTextRequestFilterSensitiveLog, SearchPlaceIndexForTextResponseFilterSensitiveLog)
        .ser(se_SearchPlaceIndexForTextCommand)
        .de(de_SearchPlaceIndexForTextCommand)
        .build() {
    }

    class TagResourceCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "TagResource", {})
        .n("LocationClient", "TagResourceCommand")
        .f(void 0, void 0)
        .ser(se_TagResourceCommand)
        .de(de_TagResourceCommand)
        .build() {
    }

    class UntagResourceCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "UntagResource", {})
        .n("LocationClient", "UntagResourceCommand")
        .f(void 0, void 0)
        .ser(se_UntagResourceCommand)
        .de(de_UntagResourceCommand)
        .build() {
    }

    class UpdateGeofenceCollectionCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "UpdateGeofenceCollection", {})
        .n("LocationClient", "UpdateGeofenceCollectionCommand")
        .f(void 0, void 0)
        .ser(se_UpdateGeofenceCollectionCommand)
        .de(de_UpdateGeofenceCollectionCommand)
        .build() {
    }

    class UpdateKeyCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "UpdateKey", {})
        .n("LocationClient", "UpdateKeyCommand")
        .f(void 0, void 0)
        .ser(se_UpdateKeyCommand)
        .de(de_UpdateKeyCommand)
        .build() {
    }

    class UpdateMapCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "UpdateMap", {})
        .n("LocationClient", "UpdateMapCommand")
        .f(void 0, void 0)
        .ser(se_UpdateMapCommand)
        .de(de_UpdateMapCommand)
        .build() {
    }

    class UpdatePlaceIndexCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "UpdatePlaceIndex", {})
        .n("LocationClient", "UpdatePlaceIndexCommand")
        .f(void 0, void 0)
        .ser(se_UpdatePlaceIndexCommand)
        .de(de_UpdatePlaceIndexCommand)
        .build() {
    }

    class UpdateRouteCalculatorCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "UpdateRouteCalculator", {})
        .n("LocationClient", "UpdateRouteCalculatorCommand")
        .f(void 0, void 0)
        .ser(se_UpdateRouteCalculatorCommand)
        .de(de_UpdateRouteCalculatorCommand)
        .build() {
    }

    class UpdateTrackerCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "UpdateTracker", {})
        .n("LocationClient", "UpdateTrackerCommand")
        .f(void 0, void 0)
        .ser(se_UpdateTrackerCommand)
        .de(de_UpdateTrackerCommand)
        .build() {
    }

    class VerifyDevicePositionCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$2,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("LocationService", "VerifyDevicePosition", {})
        .n("LocationClient", "VerifyDevicePositionCommand")
        .f(VerifyDevicePositionRequestFilterSensitiveLog, VerifyDevicePositionResponseFilterSensitiveLog)
        .ser(se_VerifyDevicePositionCommand)
        .de(de_VerifyDevicePositionCommand)
        .build() {
    }

    const commands$3 = {
        AssociateTrackerConsumerCommand,
        BatchDeleteDevicePositionHistoryCommand,
        BatchDeleteGeofenceCommand,
        BatchEvaluateGeofencesCommand,
        BatchGetDevicePositionCommand,
        BatchPutGeofenceCommand,
        BatchUpdateDevicePositionCommand,
        CalculateRouteCommand,
        CalculateRouteMatrixCommand: CalculateRouteMatrixCommand$1,
        CreateGeofenceCollectionCommand,
        CreateKeyCommand,
        CreateMapCommand,
        CreatePlaceIndexCommand,
        CreateRouteCalculatorCommand,
        CreateTrackerCommand,
        DeleteGeofenceCollectionCommand,
        DeleteKeyCommand,
        DeleteMapCommand,
        DeletePlaceIndexCommand,
        DeleteRouteCalculatorCommand,
        DeleteTrackerCommand,
        DescribeGeofenceCollectionCommand,
        DescribeKeyCommand,
        DescribeMapCommand,
        DescribePlaceIndexCommand,
        DescribeRouteCalculatorCommand,
        DescribeTrackerCommand,
        DisassociateTrackerConsumerCommand,
        ForecastGeofenceEventsCommand,
        GetDevicePositionCommand,
        GetDevicePositionHistoryCommand,
        GetGeofenceCommand,
        GetMapGlyphsCommand,
        GetMapSpritesCommand,
        GetMapStyleDescriptorCommand,
        GetMapTileCommand,
        GetPlaceCommand: GetPlaceCommand$1,
        ListDevicePositionsCommand,
        ListGeofenceCollectionsCommand,
        ListGeofencesCommand,
        ListKeysCommand,
        ListMapsCommand,
        ListPlaceIndexesCommand,
        ListRouteCalculatorsCommand,
        ListTagsForResourceCommand,
        ListTrackerConsumersCommand,
        ListTrackersCommand,
        PutGeofenceCommand,
        SearchPlaceIndexForPositionCommand,
        SearchPlaceIndexForSuggestionsCommand,
        SearchPlaceIndexForTextCommand,
        TagResourceCommand,
        UntagResourceCommand,
        UpdateGeofenceCollectionCommand,
        UpdateKeyCommand,
        UpdateMapCommand,
        UpdatePlaceIndexCommand,
        UpdateRouteCalculatorCommand,
        UpdateTrackerCommand,
        VerifyDevicePositionCommand,
    };
    class Location extends LocationClient {
    }
    createAggregatedClient$3(commands$3, Location);

    const paginateForecastGeofenceEvents = createPaginator(LocationClient, ForecastGeofenceEventsCommand, "NextToken", "NextToken", "MaxResults");

    const paginateGetDevicePositionHistory = createPaginator(LocationClient, GetDevicePositionHistoryCommand, "NextToken", "NextToken", "MaxResults");

    const paginateListDevicePositions = createPaginator(LocationClient, ListDevicePositionsCommand, "NextToken", "NextToken", "MaxResults");

    const paginateListGeofenceCollections = createPaginator(LocationClient, ListGeofenceCollectionsCommand, "NextToken", "NextToken", "MaxResults");

    const paginateListGeofences = createPaginator(LocationClient, ListGeofencesCommand, "NextToken", "NextToken", "MaxResults");

    const paginateListKeys = createPaginator(LocationClient, ListKeysCommand, "NextToken", "NextToken", "MaxResults");

    const paginateListMaps = createPaginator(LocationClient, ListMapsCommand, "NextToken", "NextToken", "MaxResults");

    const paginateListPlaceIndexes = createPaginator(LocationClient, ListPlaceIndexesCommand, "NextToken", "NextToken", "MaxResults");

    const paginateListRouteCalculators = createPaginator(LocationClient, ListRouteCalculatorsCommand, "NextToken", "NextToken", "MaxResults");

    const paginateListTrackerConsumers = createPaginator(LocationClient, ListTrackerConsumersCommand, "NextToken", "NextToken", "MaxResults");

    const paginateListTrackers = createPaginator(LocationClient, ListTrackersCommand, "NextToken", "NextToken", "MaxResults");

    function resolveLogins(logins) {
        return Promise.all(Object.keys(logins).reduce((arr, name) => {
            const tokenOrProvider = logins[name];
            if (typeof tokenOrProvider === "string") {
                arr.push([name, tokenOrProvider]);
            }
            else {
                arr.push(tokenOrProvider().then((token) => [name, token]));
            }
            return arr;
        }, [])).then((resolvedPairs) => resolvedPairs.reduce((logins, [key, value]) => {
            logins[key] = value;
            return logins;
        }, {}));
    }

    function fromCognitoIdentity$1(parameters) {
        return async () => {
            parameters.logger?.debug("@aws-sdk/credential-provider-cognito-identity - fromCognitoIdentity");
            const { GetCredentialsForIdentityCommand, CognitoIdentityClient } = await Promise.resolve().then(function () { return loadCognitoIdentity; });
            const { Credentials: { AccessKeyId = throwOnMissingAccessKeyId(parameters.logger), Expiration, SecretKey = throwOnMissingSecretKey(parameters.logger), SessionToken, } = throwOnMissingCredentials(parameters.logger), } = await (parameters.client ??
                new CognitoIdentityClient(Object.assign({}, parameters.clientConfig ?? {}, {
                    region: parameters.clientConfig?.region ?? parameters.parentClientConfig?.region,
                }))).send(new GetCredentialsForIdentityCommand({
                CustomRoleArn: parameters.customRoleArn,
                IdentityId: parameters.identityId,
                Logins: parameters.logins ? await resolveLogins(parameters.logins) : undefined,
            }));
            return {
                identityId: parameters.identityId,
                accessKeyId: AccessKeyId,
                secretAccessKey: SecretKey,
                sessionToken: SessionToken,
                expiration: Expiration,
            };
        };
    }
    function throwOnMissingAccessKeyId(logger) {
        throw new CredentialsProviderError("Response from Amazon Cognito contained no access key ID", { logger });
    }
    function throwOnMissingCredentials(logger) {
        throw new CredentialsProviderError("Response from Amazon Cognito contained no credentials", { logger });
    }
    function throwOnMissingSecretKey(logger) {
        throw new CredentialsProviderError("Response from Amazon Cognito contained no secret key", { logger });
    }

    const STORE_NAME = "IdentityIds";
    class IndexedDbStorage {
        constructor(dbName = "aws:cognito-identity-ids") {
            this.dbName = dbName;
        }
        getItem(key) {
            return this.withObjectStore("readonly", (store) => {
                const req = store.get(key);
                return new Promise((resolve) => {
                    req.onerror = () => resolve(null);
                    req.onsuccess = () => resolve(req.result ? req.result.value : null);
                });
            }).catch(() => null);
        }
        removeItem(key) {
            return this.withObjectStore("readwrite", (store) => {
                const req = store.delete(key);
                return new Promise((resolve, reject) => {
                    req.onerror = () => reject(req.error);
                    req.onsuccess = () => resolve();
                });
            });
        }
        setItem(id, value) {
            return this.withObjectStore("readwrite", (store) => {
                const req = store.put({ id, value });
                return new Promise((resolve, reject) => {
                    req.onerror = () => reject(req.error);
                    req.onsuccess = () => resolve();
                });
            });
        }
        getDb() {
            const openDbRequest = self.indexedDB.open(this.dbName, 1);
            return new Promise((resolve, reject) => {
                openDbRequest.onsuccess = () => {
                    resolve(openDbRequest.result);
                };
                openDbRequest.onerror = () => {
                    reject(openDbRequest.error);
                };
                openDbRequest.onblocked = () => {
                    reject(new Error("Unable to access DB"));
                };
                openDbRequest.onupgradeneeded = () => {
                    const db = openDbRequest.result;
                    db.onerror = () => {
                        reject(new Error("Failed to create object store"));
                    };
                    db.createObjectStore(STORE_NAME, { keyPath: "id" });
                };
            });
        }
        withObjectStore(mode, action) {
            return this.getDb().then((db) => {
                const tx = db.transaction(STORE_NAME, mode);
                tx.oncomplete = () => db.close();
                return new Promise((resolve, reject) => {
                    tx.onerror = () => reject(tx.error);
                    resolve(action(tx.objectStore(STORE_NAME)));
                }).catch((err) => {
                    db.close();
                    throw err;
                });
            });
        }
    }

    class InMemoryStorage {
        constructor(store = {}) {
            this.store = store;
        }
        getItem(key) {
            if (key in this.store) {
                return this.store[key];
            }
            return null;
        }
        removeItem(key) {
            delete this.store[key];
        }
        setItem(key, value) {
            this.store[key] = value;
        }
    }

    const inMemoryStorage = new InMemoryStorage();
    function localStorage() {
        if (typeof self === "object" && self.indexedDB) {
            return new IndexedDbStorage();
        }
        if (typeof window === "object" && window.localStorage) {
            return window.localStorage;
        }
        return inMemoryStorage;
    }

    function fromCognitoIdentityPool$1({ accountId, cache = localStorage(), client, clientConfig, customRoleArn, identityPoolId, logins, userIdentifier = !logins || Object.keys(logins).length === 0 ? "ANONYMOUS" : undefined, logger, parentClientConfig, }) {
        logger?.debug("@aws-sdk/credential-provider-cognito-identity - fromCognitoIdentity");
        const cacheKey = userIdentifier
            ? `aws:cognito-identity-credentials:${identityPoolId}:${userIdentifier}`
            : undefined;
        let provider = async () => {
            const { GetIdCommand, CognitoIdentityClient } = await Promise.resolve().then(function () { return loadCognitoIdentity; });
            const _client = client ??
                new CognitoIdentityClient(Object.assign({}, clientConfig ?? {}, { region: clientConfig?.region ?? parentClientConfig?.region }));
            let identityId = (cacheKey && (await cache.getItem(cacheKey)));
            if (!identityId) {
                const { IdentityId = throwOnMissingId(logger) } = await _client.send(new GetIdCommand({
                    AccountId: accountId,
                    IdentityPoolId: identityPoolId,
                    Logins: logins ? await resolveLogins(logins) : undefined,
                }));
                identityId = IdentityId;
                if (cacheKey) {
                    Promise.resolve(cache.setItem(cacheKey, identityId)).catch(() => { });
                }
            }
            provider = fromCognitoIdentity$1({
                client: _client,
                customRoleArn,
                logins,
                identityId,
            });
            return provider();
        };
        return () => provider().catch(async (err) => {
            if (cacheKey) {
                Promise.resolve(cache.removeItem(cacheKey)).catch(() => { });
            }
            throw err;
        });
    }
    function throwOnMissingId(logger) {
        throw new CredentialsProviderError("Response from Amazon Cognito contained no identity ID", { logger });
    }

    const fromCognitoIdentity = (options) => fromCognitoIdentity$1({
        ...options,
    });

    const fromCognitoIdentityPool = (options) => fromCognitoIdentityPool$1({
        ...options,
    });

    const ECS_CONTAINER_HOST = "169.254.170.2";
    const EKS_CONTAINER_HOST_IPv4 = "169.254.170.23";
    const EKS_CONTAINER_HOST_IPv6 = "[fd00:ec2::23]";
    const checkUrl = (url, logger) => {
        if (url.protocol === "https:") {
            return;
        }
        if (url.hostname === ECS_CONTAINER_HOST ||
            url.hostname === EKS_CONTAINER_HOST_IPv4 ||
            url.hostname === EKS_CONTAINER_HOST_IPv6) {
            return;
        }
        if (url.hostname.includes("[")) {
            if (url.hostname === "[::1]" || url.hostname === "[0000:0000:0000:0000:0000:0000:0000:0001]") {
                return;
            }
        }
        else {
            if (url.hostname === "localhost") {
                return;
            }
            const ipComponents = url.hostname.split(".");
            const inRange = (component) => {
                const num = parseInt(component, 10);
                return 0 <= num && num <= 255;
            };
            if (ipComponents[0] === "127" &&
                inRange(ipComponents[1]) &&
                inRange(ipComponents[2]) &&
                inRange(ipComponents[3]) &&
                ipComponents.length === 4) {
                return;
            }
        }
        throw new CredentialsProviderError(`URL not accepted. It must either be HTTPS or match one of the following:
  - loopback CIDR 127.0.0.0/8 or [::1/128]
  - ECS container host 169.254.170.2
  - EKS container host 169.254.170.23 or [fd00:ec2::23]`, { logger });
    };

    function createGetRequest(url) {
        return new HttpRequest$4({
            protocol: url.protocol,
            hostname: url.hostname,
            port: Number(url.port),
            path: url.pathname,
            query: Array.from(url.searchParams.entries()).reduce((acc, [k, v]) => {
                acc[k] = v;
                return acc;
            }, {}),
            fragment: url.hash,
        });
    }
    async function getCredentials(response, logger) {
        const stream = sdkStreamMixin(response.body);
        const str = await stream.transformToString();
        if (response.statusCode === 200) {
            const parsed = JSON.parse(str);
            if (typeof parsed.AccessKeyId !== "string" ||
                typeof parsed.SecretAccessKey !== "string" ||
                typeof parsed.Token !== "string" ||
                typeof parsed.Expiration !== "string") {
                throw new CredentialsProviderError("HTTP credential provider response not of the required format, an object matching: " +
                    "{ AccessKeyId: string, SecretAccessKey: string, Token: string, Expiration: string(rfc3339) }", { logger });
            }
            return {
                accessKeyId: parsed.AccessKeyId,
                secretAccessKey: parsed.SecretAccessKey,
                sessionToken: parsed.Token,
                expiration: parseRfc3339DateTime(parsed.Expiration),
            };
        }
        if (response.statusCode >= 400 && response.statusCode < 500) {
            let parsedBody = {};
            try {
                parsedBody = JSON.parse(str);
            }
            catch (e) { }
            throw Object.assign(new CredentialsProviderError(`Server responded with status: ${response.statusCode}`, { logger }), {
                Code: parsedBody.Code,
                Message: parsedBody.Message,
            });
        }
        throw new CredentialsProviderError(`Server responded with status: ${response.statusCode}`, { logger });
    }

    const retryWrapper = (toRetry, maxRetries, delayMs) => {
        return async () => {
            for (let i = 0; i < maxRetries; ++i) {
                try {
                    return await toRetry();
                }
                catch (e) {
                    await new Promise((resolve) => setTimeout(resolve, delayMs));
                }
            }
            return await toRetry();
        };
    };

    const fromHttp = (options = {}) => {
        options.logger?.debug("@aws-sdk/credential-provider-http - fromHttp");
        let host;
        const full = options.credentialsFullUri;
        if (full) {
            host = full;
        }
        else {
            throw new CredentialsProviderError("No HTTP credential provider host provided.", { logger: options.logger });
        }
        const url = new URL(host);
        checkUrl(url, options.logger);
        const requestHandler = new FetchHttpHandler$3();
        return retryWrapper(async () => {
            const request = createGetRequest(url);
            if (options.authorizationToken) {
                request.headers.Authorization = options.authorizationToken;
            }
            const result = await requestHandler.handle(request);
            return getCredentials(result.response);
        }, options.maxRetries ?? 3, options.timeout ?? 1000);
    };

    const fromTemporaryCredentials = (options) => {
        let stsClient;
        return async () => {
            options.logger?.debug("@aws-sdk/credential-providers - fromTemporaryCredentials (STS)");
            const params = { ...options.params, RoleSessionName: options.params.RoleSessionName ?? "aws-sdk-js-" + Date.now() };
            if (params?.SerialNumber) {
                if (!options.mfaCodeProvider) {
                    throw new CredentialsProviderError(`Temporary credential requires multi-factor authentication,` + ` but no MFA code callback was provided.`, {
                        tryNextLink: false,
                        logger: options.logger,
                    });
                }
                params.TokenCode = await options.mfaCodeProvider(params?.SerialNumber);
            }
            const { AssumeRoleCommand, STSClient } = await Promise.resolve().then(function () { return loadSts; });
            if (!stsClient)
                stsClient = new STSClient({ ...options.clientConfig, credentials: options.masterCredentials });
            if (options.clientPlugins) {
                for (const plugin of options.clientPlugins) {
                    stsClient.middlewareStack.use(plugin);
                }
            }
            const { Credentials } = await stsClient.send(new AssumeRoleCommand(params));
            if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
                throw new CredentialsProviderError(`Invalid response from STS.assumeRole call with role ${params.RoleArn}`, {
                    logger: options.logger,
                });
            }
            return {
                accessKeyId: Credentials.AccessKeyId,
                secretAccessKey: Credentials.SecretAccessKey,
                sessionToken: Credentials.SessionToken,
                expiration: Credentials.Expiration,
                credentialScope: Credentials.CredentialScope,
            };
        };
    };

    const fromWebToken$1 = (init) => async () => {
        init.logger?.debug("@aws-sdk/credential-provider-web-identity - fromWebToken");
        const { roleArn, roleSessionName, webIdentityToken, providerId, policyArns, policy, durationSeconds } = init;
        let { roleAssumerWithWebIdentity } = init;
        if (!roleAssumerWithWebIdentity) {
            const { getDefaultRoleAssumerWithWebIdentity } = await Promise.resolve().then(function () { return index; });
            roleAssumerWithWebIdentity = getDefaultRoleAssumerWithWebIdentity({
                ...init.clientConfig,
                credentialProviderLogger: init.logger,
                parentClientConfig: init.parentClientConfig,
            }, init.clientPlugins);
        }
        return roleAssumerWithWebIdentity({
            RoleArn: roleArn,
            RoleSessionName: roleSessionName ?? `aws-sdk-js-session-${Date.now()}`,
            WebIdentityToken: webIdentityToken,
            ProviderId: providerId,
            PolicyArns: policyArns,
            Policy: policy,
            DurationSeconds: durationSeconds,
        });
    };

    const fromWebToken = (init) => fromWebToken$1({
        ...init,
    });

    var amazonLocationAuthHelper = {};

    var hasRequiredAmazonLocationAuthHelper;

    function requireAmazonLocationAuthHelper () {
    	if (hasRequiredAmazonLocationAuthHelper) return amazonLocationAuthHelper;
    	hasRequiredAmazonLocationAuthHelper = 1;
    	(function (exports) {
    		(function(global,factory){{factory(exports);}})(typeof globalThis!=="undefined"?globalThis:typeof self!=="undefined"?self:amazonLocationAuthHelper,function(_exports){Object.defineProperty(_exports,"__esModule",{value:true});_exports.withAPIKey=withAPIKey;_exports.withIdentityPoolId=withIdentityPoolId;// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
    		// SPDX-License-Identifier: Apache-2.0
    		// Third party license at https://github.com/aws-geospatial/amazon-location-utilities-auth-helper-js/blob/main/LICENSE-THIRD-PARTY.txt
    		class ProviderError extends Error{constructor(message){var _logger,_logger$debug;let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;let logger;let tryNextLink=true;if(typeof options==="boolean"){logger=undefined;tryNextLink=options;}else if(options!=null&&typeof options==="object"){var _options$tryNextLink;logger=options.logger;tryNextLink=(_options$tryNextLink=options.tryNextLink)!==null&&_options$tryNextLink!==void 0?_options$tryNextLink:true;}super(message);this.name="ProviderError";this.tryNextLink=tryNextLink;Object.setPrototypeOf(this,ProviderError.prototype);(_logger=logger)===null||_logger===void 0||(_logger$debug=_logger.debug)===null||_logger$debug===void 0||_logger$debug.call(_logger,"@smithy/property-provider ".concat(tryNextLink?"->":"(!)"," ").concat(message));}static from(error){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;return Object.assign(new this(error.message,options),error)}}class CredentialsProviderError extends ProviderError{constructor(message){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;super(message,options);this.name="CredentialsProviderError";Object.setPrototypeOf(this,CredentialsProviderError.prototype);}}const memoize=(provider,isExpired,requiresRefresh)=>{let resolved;let pending;let hasResult;let isConstant=false;const coalesceProvider=async()=>{if(!pending){pending=provider();}try{resolved=await pending;hasResult=true;isConstant=false;}finally{pending=undefined;}return resolved};{return async options=>{if(!hasResult||options!==null&&options!==void 0&&options.forceRefresh){resolved=await coalesceProvider();}return resolved}}};function resolveLogins(logins){return Promise.all(Object.keys(logins).reduce((arr,name)=>{const tokenOrProvider=logins[name];if(typeof tokenOrProvider==="string"){arr.push([name,tokenOrProvider]);}else {arr.push(tokenOrProvider().then(token=>[name,token]));}return arr},[])).then(resolvedPairs=>resolvedPairs.reduce((logins,_ref)=>{let[key,value]=_ref;logins[key]=value;return logins},{}))}function fromCognitoIdentity(parameters){return async()=>{var _parameters$logger,_parameters$client,_parameters$clientCon,_parameters$clientCon2,_parameters$clientCon3,_parameters$parentCli;(_parameters$logger=parameters.logger)===null||_parameters$logger===void 0||_parameters$logger.debug("@aws-sdk/credential-provider-cognito-identity - fromCognitoIdentity");const{GetCredentialsForIdentityCommand,CognitoIdentityClient}=await Promise.resolve().then(function(){return loadCognitoIdentity});const{Credentials:{AccessKeyId=throwOnMissingAccessKeyId(parameters.logger),Expiration,SecretKey=throwOnMissingSecretKey(parameters.logger),SessionToken}=throwOnMissingCredentials(parameters.logger)}=await((_parameters$client=parameters.client)!==null&&_parameters$client!==void 0?_parameters$client:new CognitoIdentityClient(Object.assign({},(_parameters$clientCon=parameters.clientConfig)!==null&&_parameters$clientCon!==void 0?_parameters$clientCon:{},{region:(_parameters$clientCon2=(_parameters$clientCon3=parameters.clientConfig)===null||_parameters$clientCon3===void 0?void 0:_parameters$clientCon3.region)!==null&&_parameters$clientCon2!==void 0?_parameters$clientCon2:(_parameters$parentCli=parameters.parentClientConfig)===null||_parameters$parentCli===void 0?void 0:_parameters$parentCli.region}))).send(new GetCredentialsForIdentityCommand({CustomRoleArn:parameters.customRoleArn,IdentityId:parameters.identityId,Logins:parameters.logins?await resolveLogins(parameters.logins):undefined}));return {identityId:parameters.identityId,accessKeyId:AccessKeyId,secretAccessKey:SecretKey,sessionToken:SessionToken,expiration:Expiration}}}function throwOnMissingAccessKeyId(logger){throw new CredentialsProviderError("Response from Amazon Cognito contained no access key ID",{logger})}function throwOnMissingCredentials(logger){throw new CredentialsProviderError("Response from Amazon Cognito contained no credentials",{logger})}function throwOnMissingSecretKey(logger){throw new CredentialsProviderError("Response from Amazon Cognito contained no secret key",{logger})}const STORE_NAME="IdentityIds";class IndexedDbStorage{constructor(){let dbName=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"aws:cognito-identity-ids";this.dbName=dbName;}getItem(key){return this.withObjectStore("readonly",store=>{const req=store.get(key);return new Promise(resolve=>{req.onerror=()=>resolve(null);req.onsuccess=()=>resolve(req.result?req.result.value:null);})}).catch(()=>null)}removeItem(key){return this.withObjectStore("readwrite",store=>{const req=store.delete(key);return new Promise((resolve,reject)=>{req.onerror=()=>reject(req.error);req.onsuccess=()=>resolve();})})}setItem(id,value){return this.withObjectStore("readwrite",store=>{const req=store.put({id,value});return new Promise((resolve,reject)=>{req.onerror=()=>reject(req.error);req.onsuccess=()=>resolve();})})}getDb(){const openDbRequest=self.indexedDB.open(this.dbName,1);return new Promise((resolve,reject)=>{openDbRequest.onsuccess=()=>{resolve(openDbRequest.result);};openDbRequest.onerror=()=>{reject(openDbRequest.error);};openDbRequest.onblocked=()=>{reject(new Error("Unable to access DB"));};openDbRequest.onupgradeneeded=()=>{const db=openDbRequest.result;db.onerror=()=>{reject(new Error("Failed to create object store"));};db.createObjectStore(STORE_NAME,{keyPath:"id"});};})}withObjectStore(mode,action){return this.getDb().then(db=>{const tx=db.transaction(STORE_NAME,mode);tx.oncomplete=()=>db.close();return new Promise((resolve,reject)=>{tx.onerror=()=>reject(tx.error);resolve(action(tx.objectStore(STORE_NAME)));}).catch(err=>{db.close();throw err})})}}class InMemoryStorage{constructor(){let store=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};this.store=store;}getItem(key){if(key in this.store){return this.store[key]}return null}removeItem(key){delete this.store[key];}setItem(key,value){this.store[key]=value;}}const inMemoryStorage=new InMemoryStorage;function localStorage(){if(typeof self==="object"&&self.indexedDB){return new IndexedDbStorage}if(typeof window==="object"&&window.localStorage){return window.localStorage}return inMemoryStorage}function fromCognitoIdentityPool$1(_ref2){let{accountId,cache=localStorage(),client,clientConfig,customRoleArn,identityPoolId,logins,userIdentifier=!logins||Object.keys(logins).length===0?"ANONYMOUS":undefined,logger,parentClientConfig}=_ref2;logger===null||logger===void 0||logger.debug("@aws-sdk/credential-provider-cognito-identity - fromCognitoIdentity");const cacheKey=userIdentifier?"aws:cognito-identity-credentials:".concat(identityPoolId,":").concat(userIdentifier):undefined;let provider=async()=>{var _clientConfig$region;const{GetIdCommand,CognitoIdentityClient}=await Promise.resolve().then(function(){return loadCognitoIdentity});const _client=client!==null&&client!==void 0?client:new CognitoIdentityClient(Object.assign({},clientConfig!==null&&clientConfig!==void 0?clientConfig:{},{region:(_clientConfig$region=clientConfig===null||clientConfig===void 0?void 0:clientConfig.region)!==null&&_clientConfig$region!==void 0?_clientConfig$region:parentClientConfig===null||parentClientConfig===void 0?void 0:parentClientConfig.region}));let identityId=cacheKey&&(await cache.getItem(cacheKey));if(!identityId){const{IdentityId=throwOnMissingId(logger)}=await _client.send(new GetIdCommand({AccountId:accountId,IdentityPoolId:identityPoolId,Logins:logins?await resolveLogins(logins):undefined}));identityId=IdentityId;if(cacheKey){Promise.resolve(cache.setItem(cacheKey,identityId)).catch(()=>{});}}provider=fromCognitoIdentity({client:_client,customRoleArn,logins,identityId});return provider()};return ()=>provider().catch(async err=>{if(cacheKey){Promise.resolve(cache.removeItem(cacheKey)).catch(()=>{});}throw err})}function throwOnMissingId(logger){throw new CredentialsProviderError("Response from Amazon Cognito contained no identity ID",{logger})}const fromCognitoIdentityPool=options=>fromCognitoIdentityPool$1({...options});const getHttpHandlerExtensionConfiguration=runtimeConfig=>{let httpHandler=runtimeConfig.httpHandler;return {setHttpHandler(handler){httpHandler=handler;},httpHandler(){return httpHandler},updateHttpClientConfig(key,value){httpHandler.updateHttpClientConfig(key,value);},httpHandlerConfigs(){return httpHandler.httpHandlerConfigs()}}};const resolveHttpHandlerRuntimeConfig=httpHandlerExtensionConfiguration=>{return {httpHandler:httpHandlerExtensionConfiguration.httpHandler()}};var HttpAuthLocation;(function(HttpAuthLocation){HttpAuthLocation["HEADER"]="header";HttpAuthLocation["QUERY"]="query";})(HttpAuthLocation||(HttpAuthLocation={}));var HttpApiKeyAuthLocation;(function(HttpApiKeyAuthLocation){HttpApiKeyAuthLocation["HEADER"]="header";HttpApiKeyAuthLocation["QUERY"]="query";})(HttpApiKeyAuthLocation||(HttpApiKeyAuthLocation={}));var EndpointURLScheme;(function(EndpointURLScheme){EndpointURLScheme["HTTP"]="http";EndpointURLScheme["HTTPS"]="https";})(EndpointURLScheme||(EndpointURLScheme={}));var AlgorithmId;(function(AlgorithmId){AlgorithmId["MD5"]="md5";AlgorithmId["CRC32"]="crc32";AlgorithmId["CRC32C"]="crc32c";AlgorithmId["SHA1"]="sha1";AlgorithmId["SHA256"]="sha256";})(AlgorithmId||(AlgorithmId={}));var FieldPosition;(function(FieldPosition){FieldPosition[FieldPosition["HEADER"]=0]="HEADER";FieldPosition[FieldPosition["TRAILER"]=1]="TRAILER";})(FieldPosition||(FieldPosition={}));const SMITHY_CONTEXT_KEY="__smithy_context";var IniSectionType;(function(IniSectionType){IniSectionType["PROFILE"]="profile";IniSectionType["SSO_SESSION"]="sso-session";IniSectionType["SERVICES"]="services";})(IniSectionType||(IniSectionType={}));var RequestHandlerProtocol;(function(RequestHandlerProtocol){RequestHandlerProtocol["HTTP_0_9"]="http/0.9";RequestHandlerProtocol["HTTP_1_0"]="http/1.0";RequestHandlerProtocol["TDS_8_0"]="tds/8.0";})(RequestHandlerProtocol||(RequestHandlerProtocol={}));class HttpRequest{constructor(options){this.method=options.method||"GET";this.hostname=options.hostname||"localhost";this.port=options.port;this.query=options.query||{};this.headers=options.headers||{};this.body=options.body;this.protocol=options.protocol?options.protocol.slice(-1)!==":"?"".concat(options.protocol,":"):options.protocol:"https:";this.path=options.path?options.path.charAt(0)!=="/"?"/".concat(options.path):options.path:"/";this.username=options.username;this.password=options.password;this.fragment=options.fragment;}static clone(request){const cloned=new HttpRequest({...request,headers:{...request.headers}});if(cloned.query){cloned.query=cloneQuery(cloned.query);}return cloned}static isInstance(request){if(!request){return false}const req=request;return "method"in req&&"protocol"in req&&"hostname"in req&&"path"in req&&typeof req["query"]==="object"&&typeof req["headers"]==="object"}clone(){return HttpRequest.clone(this)}}function cloneQuery(query){return Object.keys(query).reduce((carry,paramName)=>{const param=query[paramName];return {...carry,[paramName]:Array.isArray(param)?[...param]:param}},{})}class HttpResponse{constructor(options){this.statusCode=options.statusCode;this.reason=options.reason;this.headers=options.headers||{};this.body=options.body;}static isInstance(response){if(!response)return false;const resp=response;return typeof resp.statusCode==="number"&&typeof resp.headers==="object"}}const escapeUri$1=uri=>encodeURIComponent(uri).replace(/[!'()*]/g,hexEncode$1);const hexEncode$1=c=>"%".concat(c.charCodeAt(0).toString(16).toUpperCase());function buildQueryString(query){const parts=[];for(let key of Object.keys(query).sort()){const value=query[key];key=escapeUri$1(key);if(Array.isArray(value)){for(let i=0,iLen=value.length;i<iLen;i++){parts.push("".concat(key,"=").concat(escapeUri$1(value[i])));}}else {let qsEntry=key;if(value||typeof value==="string"){qsEntry+="=".concat(escapeUri$1(value));}parts.push(qsEntry);}}return parts.join("&")}function requestTimeout(){let timeoutInMs=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;return new Promise((resolve,reject)=>{if(timeoutInMs){setTimeout(()=>{const timeoutError=new Error("Request did not complete within ".concat(timeoutInMs," ms"));timeoutError.name="TimeoutError";reject(timeoutError);},timeoutInMs);}})}const keepAliveSupport={supported:undefined};class FetchHttpHandler{static create(instanceOrOptions){if(typeof(instanceOrOptions===null||instanceOrOptions===void 0?void 0:instanceOrOptions.handle)==="function"){return instanceOrOptions}return new FetchHttpHandler(instanceOrOptions)}constructor(options){if(typeof options==="function"){this.configProvider=options().then(opts=>opts||{});}else {this.config=options!==null&&options!==void 0?options:{};this.configProvider=Promise.resolve(this.config);}if(keepAliveSupport.supported===undefined){keepAliveSupport.supported=Boolean(typeof Request!=="undefined"&&"keepalive"in new Request("https://[::1]"));}}destroy(){}async handle(request){let{abortSignal}=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};if(!this.config){this.config=await this.configProvider;}const requestTimeoutInMs=this.config.requestTimeout;const keepAlive=this.config.keepAlive===true;const credentials=this.config.credentials;if(abortSignal!==null&&abortSignal!==void 0&&abortSignal.aborted){const abortError=new Error("Request aborted");abortError.name="AbortError";return Promise.reject(abortError)}let path=request.path;const queryString=buildQueryString(request.query||{});if(queryString){path+="?".concat(queryString);}if(request.fragment){path+="#".concat(request.fragment);}let auth="";if(request.username!=null||request.password!=null){var _request$username,_request$password;const username=(_request$username=request.username)!==null&&_request$username!==void 0?_request$username:"";const password=(_request$password=request.password)!==null&&_request$password!==void 0?_request$password:"";auth="".concat(username,":").concat(password,"@");}const{port,method}=request;const url="".concat(request.protocol,"//").concat(auth).concat(request.hostname).concat(port?":".concat(port):"").concat(path);const body=method==="GET"||method==="HEAD"?undefined:request.body;const requestOptions={body,headers:new Headers(request.headers),method:method,credentials};if(body){requestOptions.duplex="half";}if(typeof AbortController!=="undefined"){requestOptions.signal=abortSignal;}if(keepAliveSupport.supported){requestOptions.keepalive=keepAlive;}let removeSignalEventListener=()=>{};const fetchRequest=new Request(url,requestOptions);const raceOfPromises=[fetch(fetchRequest).then(response=>{const fetchHeaders=response.headers;const transformedHeaders={};for(const pair of fetchHeaders.entries()){transformedHeaders[pair[0]]=pair[1];}const hasReadableStream=response.body!=undefined;if(!hasReadableStream){return response.blob().then(body=>({response:new HttpResponse({headers:transformedHeaders,reason:response.statusText,statusCode:response.status,body})}))}return {response:new HttpResponse({headers:transformedHeaders,reason:response.statusText,statusCode:response.status,body:response.body})}}),requestTimeout(requestTimeoutInMs)];if(abortSignal){raceOfPromises.push(new Promise((resolve,reject)=>{const onAbort=()=>{const abortError=new Error("Request aborted");abortError.name="AbortError";reject(abortError);};if(typeof abortSignal.addEventListener==="function"){const signal=abortSignal;signal.addEventListener("abort",onAbort,{once:true});removeSignalEventListener=()=>signal.removeEventListener("abort",onAbort);}else {abortSignal.onabort=onAbort;}}));}return Promise.race(raceOfPromises).finally(removeSignalEventListener)}updateHttpClientConfig(key,value){this.config=undefined;this.configProvider=this.configProvider.then(config=>{config[key]=value;return config});}httpHandlerConfigs(){var _this$config;return (_this$config=this.config)!==null&&_this$config!==void 0?_this$config:{}}}const alphabetByEncoding={};const alphabetByValue=new Array(64);for(let i=0,start="A".charCodeAt(0),limit="Z".charCodeAt(0);i+start<=limit;i++){const char=String.fromCharCode(i+start);alphabetByEncoding[char]=i;alphabetByValue[i]=char;}for(let i=0,start="a".charCodeAt(0),limit="z".charCodeAt(0);i+start<=limit;i++){const char=String.fromCharCode(i+start);const index=i+26;alphabetByEncoding[char]=index;alphabetByValue[index]=char;}for(let i=0;i<10;i++){alphabetByEncoding[i.toString(10)]=i+52;const char=i.toString(10);const index=i+52;alphabetByEncoding[char]=index;alphabetByValue[index]=char;}alphabetByEncoding["+"]=62;alphabetByValue[62]="+";alphabetByEncoding["/"]=63;alphabetByValue[63]="/";const bitsPerLetter=6;const bitsPerByte=8;const maxLetterValue=63;const fromBase64=input=>{let totalByteLength=input.length/4*3;if(input.slice(-2)==="=="){totalByteLength-=2;}else if(input.slice(-1)==="="){totalByteLength--;}const out=new ArrayBuffer(totalByteLength);const dataView=new DataView(out);for(let i=0;i<input.length;i+=4){let bits=0;let bitLength=0;for(let j=i,limit=i+3;j<=limit;j++){if(input[j]!=="="){if(!(input[j]in alphabetByEncoding)){throw new TypeError("Invalid character ".concat(input[j]," in base64 string."))}bits|=alphabetByEncoding[input[j]]<<(limit-j)*bitsPerLetter;bitLength+=bitsPerLetter;}else {bits>>=bitsPerLetter;}}const chunkOffset=i/4*3;bits>>=bitLength%bitsPerByte;const byteLength=Math.floor(bitLength/bitsPerByte);for(let k=0;k<byteLength;k++){const offset=(byteLength-k-1)*bitsPerByte;dataView.setUint8(chunkOffset+k,(bits&255<<offset)>>offset);}}return new Uint8Array(out)};const fromUtf8$5=input=>new TextEncoder().encode(input);function toBase64(_input){let input;if(typeof _input==="string"){input=fromUtf8$5(_input);}else {input=_input;}const isArrayLike=typeof input==="object"&&typeof input.length==="number";const isUint8Array=typeof input==="object"&&typeof input.byteOffset==="number"&&typeof input.byteLength==="number";if(!isArrayLike&&!isUint8Array){throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.")}let str="";for(let i=0;i<input.length;i+=3){let bits=0;let bitLength=0;for(let j=i,limit=Math.min(i+3,input.length);j<limit;j++){bits|=input[j]<<(limit-j-1)*bitsPerByte;bitLength+=bitsPerByte;}const bitClusterCount=Math.ceil(bitLength/bitsPerLetter);bits<<=bitClusterCount*bitsPerLetter-bitLength;for(let k=1;k<=bitClusterCount;k++){const offset=(bitClusterCount-k)*bitsPerLetter;str+=alphabetByValue[(bits&maxLetterValue<<offset)>>offset];}str+="==".slice(0,4-bitClusterCount);}return str}const streamCollector=stream=>{if(typeof Blob==="function"&&stream instanceof Blob){return collectBlob(stream)}return collectStream(stream)};async function collectBlob(blob){const base64=await readToBase64(blob);const arrayBuffer=fromBase64(base64);return new Uint8Array(arrayBuffer)}async function collectStream(stream){const chunks=[];const reader=stream.getReader();let isDone=false;let length=0;while(!isDone){const{done,value}=await reader.read();if(value){chunks.push(value);length+=value.length;}isDone=done;}const collected=new Uint8Array(length);let offset=0;for(const chunk of chunks){collected.set(chunk,offset);offset+=chunk.length;}return collected}function readToBase64(blob){return new Promise((resolve,reject)=>{const reader=new FileReader;reader.onloadend=()=>{var _reader$result;if(reader.readyState!==2){return reject(new Error("Reader aborted too early"))}const result=(_reader$result=reader.result)!==null&&_reader$result!==void 0?_reader$result:"";const commaIndex=result.indexOf(",");const dataOffset=commaIndex>-1?commaIndex+1:result.length;resolve(result.substring(dataOffset));};reader.onabort=()=>reject(new Error("Read aborted"));reader.onerror=()=>reject(reader.error);reader.readAsDataURL(blob);})}class NoOpLogger{trace(){}debug(){}info(){}warn(){}error(){}}const getAllAliases=(name,aliases)=>{const _aliases=[];if(name){_aliases.push(name);}if(aliases){for(const alias of aliases){_aliases.push(alias);}}return _aliases};const getMiddlewareNameWithAliases=(name,aliases)=>{return "".concat(name||"anonymous").concat(aliases&&aliases.length>0?" (a.k.a. ".concat(aliases.join(","),")"):"")};const constructStack=()=>{let absoluteEntries=[];let relativeEntries=[];let identifyOnResolve=false;const entriesNameSet=new Set;const sort=entries=>entries.sort((a,b)=>stepWeights[b.step]-stepWeights[a.step]||priorityWeights[b.priority||"normal"]-priorityWeights[a.priority||"normal"]);const removeByName=toRemove=>{let isRemoved=false;const filterCb=entry=>{const aliases=getAllAliases(entry.name,entry.aliases);if(aliases.includes(toRemove)){isRemoved=true;for(const alias of aliases){entriesNameSet.delete(alias);}return false}return true};absoluteEntries=absoluteEntries.filter(filterCb);relativeEntries=relativeEntries.filter(filterCb);return isRemoved};const removeByReference=toRemove=>{let isRemoved=false;const filterCb=entry=>{if(entry.middleware===toRemove){isRemoved=true;for(const alias of getAllAliases(entry.name,entry.aliases)){entriesNameSet.delete(alias);}return false}return true};absoluteEntries=absoluteEntries.filter(filterCb);relativeEntries=relativeEntries.filter(filterCb);return isRemoved};const cloneTo=toStack=>{var _toStack$identifyOnRe;absoluteEntries.forEach(entry=>{toStack.add(entry.middleware,{...entry});});relativeEntries.forEach(entry=>{toStack.addRelativeTo(entry.middleware,{...entry});});(_toStack$identifyOnRe=toStack.identifyOnResolve)===null||_toStack$identifyOnRe===void 0||_toStack$identifyOnRe.call(toStack,stack.identifyOnResolve());return toStack};const expandRelativeMiddlewareList=from=>{const expandedMiddlewareList=[];from.before.forEach(entry=>{if(entry.before.length===0&&entry.after.length===0){expandedMiddlewareList.push(entry);}else {expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));}});expandedMiddlewareList.push(from);from.after.reverse().forEach(entry=>{if(entry.before.length===0&&entry.after.length===0){expandedMiddlewareList.push(entry);}else {expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));}});return expandedMiddlewareList};const getMiddlewareList=function(){let debug=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;const normalizedAbsoluteEntries=[];const normalizedRelativeEntries=[];const normalizedEntriesNameMap={};absoluteEntries.forEach(entry=>{const normalizedEntry={...entry,before:[],after:[]};for(const alias of getAllAliases(normalizedEntry.name,normalizedEntry.aliases)){normalizedEntriesNameMap[alias]=normalizedEntry;}normalizedAbsoluteEntries.push(normalizedEntry);});relativeEntries.forEach(entry=>{const normalizedEntry={...entry,before:[],after:[]};for(const alias of getAllAliases(normalizedEntry.name,normalizedEntry.aliases)){normalizedEntriesNameMap[alias]=normalizedEntry;}normalizedRelativeEntries.push(normalizedEntry);});normalizedRelativeEntries.forEach(entry=>{if(entry.toMiddleware){const toMiddleware=normalizedEntriesNameMap[entry.toMiddleware];if(toMiddleware===undefined){if(debug){return}throw new Error("".concat(entry.toMiddleware," is not found when adding ")+"".concat(getMiddlewareNameWithAliases(entry.name,entry.aliases)," ")+"middleware ".concat(entry.relation," ").concat(entry.toMiddleware))}if(entry.relation==="after"){toMiddleware.after.push(entry);}if(entry.relation==="before"){toMiddleware.before.push(entry);}}});const mainChain=sort(normalizedAbsoluteEntries).map(expandRelativeMiddlewareList).reduce((wholeList,expandedMiddlewareList)=>{wholeList.push(...expandedMiddlewareList);return wholeList},[]);return mainChain};const stack={add:function(middleware){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const{name,override,aliases:_aliases}=options;const entry={step:"initialize",priority:"normal",middleware,...options};const aliases=getAllAliases(name,_aliases);if(aliases.length>0){if(aliases.some(alias=>entriesNameSet.has(alias))){if(!override)throw new Error("Duplicate middleware name '".concat(getMiddlewareNameWithAliases(name,_aliases),"'"));for(const alias of aliases){const toOverrideIndex=absoluteEntries.findIndex(entry=>{var _entry$aliases;return entry.name===alias||((_entry$aliases=entry.aliases)===null||_entry$aliases===void 0?void 0:_entry$aliases.some(a=>a===alias))});if(toOverrideIndex===-1){continue}const toOverride=absoluteEntries[toOverrideIndex];if(toOverride.step!==entry.step||entry.priority!==toOverride.priority){throw new Error("\"".concat(getMiddlewareNameWithAliases(toOverride.name,toOverride.aliases),"\" middleware with ")+"".concat(toOverride.priority," priority in ").concat(toOverride.step," step cannot ")+"be overridden by \"".concat(getMiddlewareNameWithAliases(name,_aliases),"\" middleware with ")+"".concat(entry.priority," priority in ").concat(entry.step," step."))}absoluteEntries.splice(toOverrideIndex,1);}}for(const alias of aliases){entriesNameSet.add(alias);}}absoluteEntries.push(entry);},addRelativeTo:(middleware,options)=>{const{name,override,aliases:_aliases}=options;const entry={middleware,...options};const aliases=getAllAliases(name,_aliases);if(aliases.length>0){if(aliases.some(alias=>entriesNameSet.has(alias))){if(!override)throw new Error("Duplicate middleware name '".concat(getMiddlewareNameWithAliases(name,_aliases),"'"));for(const alias of aliases){const toOverrideIndex=relativeEntries.findIndex(entry=>{var _entry$aliases2;return entry.name===alias||((_entry$aliases2=entry.aliases)===null||_entry$aliases2===void 0?void 0:_entry$aliases2.some(a=>a===alias))});if(toOverrideIndex===-1){continue}const toOverride=relativeEntries[toOverrideIndex];if(toOverride.toMiddleware!==entry.toMiddleware||toOverride.relation!==entry.relation){throw new Error("\"".concat(getMiddlewareNameWithAliases(toOverride.name,toOverride.aliases),"\" middleware ")+"".concat(toOverride.relation," \"").concat(toOverride.toMiddleware,"\" middleware cannot be overridden ")+"by \"".concat(getMiddlewareNameWithAliases(name,_aliases),"\" middleware ").concat(entry.relation," ")+"\"".concat(entry.toMiddleware,"\" middleware."))}relativeEntries.splice(toOverrideIndex,1);}}for(const alias of aliases){entriesNameSet.add(alias);}}relativeEntries.push(entry);},clone:()=>cloneTo(constructStack()),use:plugin=>{plugin.applyToStack(stack);},remove:toRemove=>{if(typeof toRemove==="string")return removeByName(toRemove);else return removeByReference(toRemove)},removeByTag:toRemove=>{let isRemoved=false;const filterCb=entry=>{const{tags,name,aliases:_aliases}=entry;if(tags&&tags.includes(toRemove)){const aliases=getAllAliases(name,_aliases);for(const alias of aliases){entriesNameSet.delete(alias);}isRemoved=true;return false}return true};absoluteEntries=absoluteEntries.filter(filterCb);relativeEntries=relativeEntries.filter(filterCb);return isRemoved},concat:from=>{var _from$identifyOnResol,_from$identifyOnResol2;const cloned=cloneTo(constructStack());cloned.use(from);cloned.identifyOnResolve(identifyOnResolve||cloned.identifyOnResolve()||((_from$identifyOnResol=(_from$identifyOnResol2=from.identifyOnResolve)===null||_from$identifyOnResol2===void 0?void 0:_from$identifyOnResol2.call(from))!==null&&_from$identifyOnResol!==void 0?_from$identifyOnResol:false));return cloned},applyToStack:cloneTo,identify:()=>{return getMiddlewareList(true).map(mw=>{var _mw$step;const step=(_mw$step=mw.step)!==null&&_mw$step!==void 0?_mw$step:mw.relation+" "+mw.toMiddleware;return getMiddlewareNameWithAliases(mw.name,mw.aliases)+" - "+step})},identifyOnResolve(toggle){if(typeof toggle==="boolean")identifyOnResolve=toggle;return identifyOnResolve},resolve:(handler,context)=>{for(const middleware of getMiddlewareList().map(entry=>entry.middleware).reverse()){handler=middleware(handler,context);}if(identifyOnResolve){console.log(stack.identify());}return handler}};return stack};const stepWeights={initialize:5,serialize:4,build:3,finalizeRequest:2,deserialize:1};const priorityWeights={high:3,normal:2,low:1};class Client{constructor(config){this.middlewareStack=constructStack();this.config=config;}send(command,optionsOrCb,cb){const options=typeof optionsOrCb!=="function"?optionsOrCb:undefined;const callback=typeof optionsOrCb==="function"?optionsOrCb:cb;const handler=command.resolveMiddleware(this.middlewareStack,this.config,options);if(callback){handler(command).then(result=>callback(null,result.output),err=>callback(err)).catch(()=>{});}else {return handler(command).then(result=>result.output)}}destroy(){if(this.config.requestHandler.destroy)this.config.requestHandler.destroy();}}const fromUtf8$4=input=>new TextEncoder().encode(input);const toUtf8$1=input=>{if(typeof input==="string"){return input}if(typeof input!=="object"||typeof input.byteOffset!=="number"||typeof input.byteLength!=="number"){throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.")}return new TextDecoder("utf-8").decode(input)};function transformToString(payload){let encoding=arguments.length>1&&arguments[1]!==undefined?arguments[1]:"utf-8";if(encoding==="base64"){return toBase64(payload)}return toUtf8$1(payload)}function transformFromString(str,encoding){if(encoding==="base64"){return Uint8ArrayBlobAdapter.mutate(fromBase64(str))}return Uint8ArrayBlobAdapter.mutate(fromUtf8$4(str))}class Uint8ArrayBlobAdapter extends Uint8Array{static fromString(source){let encoding=arguments.length>1&&arguments[1]!==undefined?arguments[1]:"utf-8";switch(typeof source){case"string":return transformFromString(source,encoding);default:throw new Error("Unsupported conversion from ".concat(typeof source," to Uint8ArrayBlobAdapter."))}}static mutate(source){Object.setPrototypeOf(source,Uint8ArrayBlobAdapter.prototype);return source}transformToString(){let encoding=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"utf-8";return transformToString(this,encoding)}}for(let i=0;i<256;i++){let encodedByte=i.toString(16).toLowerCase();if(encodedByte.length===1){encodedByte="0".concat(encodedByte);}}const collectBody=async function(){let streamBody=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Uint8Array;let context=arguments.length>1?arguments[1]:undefined;if(streamBody instanceof Uint8Array){return Uint8ArrayBlobAdapter.mutate(streamBody)}if(!streamBody){return Uint8ArrayBlobAdapter.mutate(new Uint8Array)}const fromContext=context.streamCollector(streamBody);return Uint8ArrayBlobAdapter.mutate(await fromContext)};class Command{constructor(){this.middlewareStack=constructStack();}static classBuilder(){return new ClassBuilder}resolveMiddlewareWithContext(clientStack,configuration,options,_ref3){let{middlewareFn,clientName,commandName,inputFilterSensitiveLog,outputFilterSensitiveLog,smithyContext,additionalContext,CommandCtor}=_ref3;for(const mw of middlewareFn.bind(this)(CommandCtor,clientStack,configuration,options)){this.middlewareStack.use(mw);}const stack=clientStack.concat(this.middlewareStack);const{logger}=configuration;const handlerExecutionContext={logger,clientName,commandName,inputFilterSensitiveLog,outputFilterSensitiveLog,[SMITHY_CONTEXT_KEY]:{...smithyContext},...additionalContext};const{requestHandler}=configuration;return stack.resolve(request=>requestHandler.handle(request.request,options||{}),handlerExecutionContext)}}class ClassBuilder{constructor(){this._init=()=>{};this._ep={};this._middlewareFn=()=>[];this._commandName="";this._clientName="";this._additionalContext={};this._smithyContext={};this._inputFilterSensitiveLog=_=>_;this._outputFilterSensitiveLog=_=>_;this._serializer=null;this._deserializer=null;}init(cb){this._init=cb;}ep(endpointParameterInstructions){this._ep=endpointParameterInstructions;return this}m(middlewareSupplier){this._middlewareFn=middlewareSupplier;return this}s(service,operation){let smithyContext=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};this._smithyContext={service,operation,...smithyContext};return this}c(){let additionalContext=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};this._additionalContext=additionalContext;return this}n(clientName,commandName){this._clientName=clientName;this._commandName=commandName;return this}f(){let inputFilter=arguments.length>0&&arguments[0]!==undefined?arguments[0]:_=>_;let outputFilter=arguments.length>1&&arguments[1]!==undefined?arguments[1]:_=>_;this._inputFilterSensitiveLog=inputFilter;this._outputFilterSensitiveLog=outputFilter;return this}ser(serializer){this._serializer=serializer;return this}de(deserializer){this._deserializer=deserializer;return this}build(){const closure=this;let CommandRef;return CommandRef=class extends Command{static getEndpointParameterInstructions(){return closure._ep}constructor(){for(var _len=arguments.length,_ref4=new Array(_len),_key=0;_key<_len;_key++){_ref4[_key]=arguments[_key];}let[input]=_ref4;super();this.serialize=closure._serializer;this.deserialize=closure._deserializer;this.input=input!==null&&input!==void 0?input:{};closure._init(this);}resolveMiddleware(stack,configuration,options){return this.resolveMiddlewareWithContext(stack,configuration,options,{CommandCtor:CommandRef,middlewareFn:closure._middlewareFn,clientName:closure._clientName,commandName:closure._commandName,inputFilterSensitiveLog:closure._inputFilterSensitiveLog,outputFilterSensitiveLog:closure._outputFilterSensitiveLog,smithyContext:closure._smithyContext,additionalContext:closure._additionalContext})}}}}const expectNumber=value=>{if(value===null||value===undefined){return undefined}if(typeof value==="string"){const parsed=parseFloat(value);if(!Number.isNaN(parsed)){if(String(parsed)!==String(value)){logger.warn(stackTraceWarning("Expected number but observed string: ".concat(value)));}return parsed}}if(typeof value==="number"){return value}throw new TypeError("Expected number, got ".concat(typeof value,": ").concat(value))};const expectNonNull=(value,location)=>{if(value===null||value===undefined){throw new TypeError("Expected a non-null value")}return value};const expectString=value=>{if(value===null||value===undefined){return undefined}if(typeof value==="string"){return value}if(["boolean","number","bigint"].includes(typeof value)){logger.warn(stackTraceWarning("Expected string, got ".concat(typeof value,": ").concat(value)));return String(value)}throw new TypeError("Expected string, got ".concat(typeof value,": ").concat(value))};const strictParseDouble=value=>{if(typeof value=="string"){return expectNumber(parseNumber(value))}return expectNumber(value)};const NUMBER_REGEX=/(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;const parseNumber=value=>{const matches=value.match(NUMBER_REGEX);if(matches===null||matches[0].length!==value.length){throw new TypeError("Expected real number, got implicit NaN")}return parseFloat(value)};const stackTraceWarning=message=>{return String(new TypeError(message).stack||message).split("\n").slice(0,5).filter(s=>!s.includes("stackTraceWarning")).join("\n")};const logger={warn:console.warn};const parseEpochTimestamp=value=>{if(value===null||value===undefined){return undefined}let valueAsDouble;if(typeof value==="number"){valueAsDouble=value;}else if(typeof value==="string"){valueAsDouble=strictParseDouble(value);}else {throw new TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation")}if(Number.isNaN(valueAsDouble)||valueAsDouble===Infinity||valueAsDouble===-Infinity){throw new TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics")}return new Date(Math.round(valueAsDouble*1000))};class ServiceException extends Error{constructor(options){super(options.message);Object.setPrototypeOf(this,ServiceException.prototype);this.name=options.name;this.$fault=options.$fault;this.$metadata=options.$metadata;}}const decorateServiceException=function(exception){let additions=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};Object.entries(additions).filter(_ref5=>{let[,v]=_ref5;return v!==undefined}).forEach(_ref6=>{let[k,v]=_ref6;if(exception[k]==undefined||exception[k]===""){exception[k]=v;}});const message=exception.message||exception.Message||"UnknownError";exception.message=message;delete exception.Message;return exception};const throwDefaultError$1=_ref7=>{let{output,parsedBody,exceptionCtor,errorCode}=_ref7;const $metadata=deserializeMetadata$1(output);const statusCode=$metadata.httpStatusCode?$metadata.httpStatusCode+"":undefined;const response=new exceptionCtor({name:(parsedBody===null||parsedBody===void 0?void 0:parsedBody.code)||(parsedBody===null||parsedBody===void 0?void 0:parsedBody.Code)||errorCode||statusCode||"UnknownError",$fault:"client",$metadata});throw decorateServiceException(response,parsedBody)};const withBaseException=ExceptionCtor=>{return _ref8=>{let{output,parsedBody,errorCode}=_ref8;throwDefaultError$1({output,parsedBody,exceptionCtor:ExceptionCtor,errorCode});}};const deserializeMetadata$1=output=>{var _ref9,_output$headers$xAmz;return {httpStatusCode:output.statusCode,requestId:(_ref9=(_output$headers$xAmz=output.headers["x-amzn-requestid"])!==null&&_output$headers$xAmz!==void 0?_output$headers$xAmz:output.headers["x-amzn-request-id"])!==null&&_ref9!==void 0?_ref9:output.headers["x-amz-request-id"],extendedRequestId:output.headers["x-amz-id-2"],cfId:output.headers["x-amz-cf-id"]}};const loadConfigsForDefaultMode=mode=>{switch(mode){case"standard":return {retryMode:"standard",connectionTimeout:3100};case"in-region":return {retryMode:"standard",connectionTimeout:1100};case"cross-region":return {retryMode:"standard",connectionTimeout:3100};case"mobile":return {retryMode:"standard",connectionTimeout:30000};default:return {}}};const getChecksumConfiguration=runtimeConfig=>{const checksumAlgorithms=[];for(const id in AlgorithmId){const algorithmId=AlgorithmId[id];if(runtimeConfig[algorithmId]===undefined){continue}checksumAlgorithms.push({algorithmId:()=>algorithmId,checksumConstructor:()=>runtimeConfig[algorithmId]});}return {_checksumAlgorithms:checksumAlgorithms,addChecksumAlgorithm(algo){this._checksumAlgorithms.push(algo);},checksumAlgorithms(){return this._checksumAlgorithms}}};const resolveChecksumRuntimeConfig=clientConfig=>{const runtimeConfig={};clientConfig.checksumAlgorithms().forEach(checksumAlgorithm=>{runtimeConfig[checksumAlgorithm.algorithmId()]=checksumAlgorithm.checksumConstructor();});return runtimeConfig};const getRetryConfiguration=runtimeConfig=>{let _retryStrategy=runtimeConfig.retryStrategy;return {setRetryStrategy(retryStrategy){_retryStrategy=retryStrategy;},retryStrategy(){return _retryStrategy}}};const resolveRetryRuntimeConfig=retryStrategyConfiguration=>{const runtimeConfig={};runtimeConfig.retryStrategy=retryStrategyConfiguration.retryStrategy();return runtimeConfig};const getDefaultExtensionConfiguration=runtimeConfig=>{return {...getChecksumConfiguration(runtimeConfig),...getRetryConfiguration(runtimeConfig)}};const resolveDefaultRuntimeConfig=config=>{return {...resolveChecksumRuntimeConfig(config),...resolveRetryRuntimeConfig(config)}};const StringWrapper=function(){const Class=Object.getPrototypeOf(this).constructor;const Constructor=Function.bind.apply(String,[null,...arguments]);const instance=new Constructor;Object.setPrototypeOf(instance,Class.prototype);return instance};StringWrapper.prototype=Object.create(String.prototype,{constructor:{value:StringWrapper,enumerable:false,writable:true,configurable:true}});Object.setPrototypeOf(StringWrapper,String);const take=(source,instructions)=>{const out={};for(const key in instructions){applyInstruction(out,source,instructions,key);}return out};const applyInstruction=(target,source,instructions,targetKey)=>{if(source!==null){let instruction=instructions[targetKey];if(typeof instruction==="function"){instruction=[,instruction];}const[filter=nonNullish,valueFn=pass,sourceKey=targetKey]=instruction;if(typeof filter==="function"&&filter(source[sourceKey])||typeof filter!=="function"&&!!filter){target[targetKey]=valueFn(source[sourceKey]);}return}let[filter,value]=instructions[targetKey];if(typeof value==="function"){let _value;const defaultFilterPassed=filter===undefined&&(_value=value())!=null;const customFilterPassed=typeof filter==="function"&&!!filter(void 0)||typeof filter!=="function"&&!!filter;if(defaultFilterPassed){target[targetKey]=_value;}else if(customFilterPassed){target[targetKey]=value();}}else {const defaultFilterPassed=filter===undefined&&value!=null;const customFilterPassed=typeof filter==="function"&&!!filter(value)||typeof filter!=="function"&&!!filter;if(defaultFilterPassed||customFilterPassed){target[targetKey]=value;}}};const nonNullish=_=>_!=null;const pass=_=>_;const _json=obj=>{if(obj==null){return {}}if(Array.isArray(obj)){return obj.filter(_=>_!=null).map(_json)}if(typeof obj==="object"){const target={};for(const key of Object.keys(obj)){if(obj[key]==null){continue}target[key]=_json(obj[key]);}return target}return obj};/******************************************************************************
    		Copyright (c) Microsoft Corporation.

    		Permission to use, copy, modify, and/or distribute this software for any
    		purpose with or without fee is hereby granted.

    		THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    		REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    		AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    		INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    		LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    		OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    		PERFORMANCE OF THIS SOFTWARE.
    		***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol */function __awaiter(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value);})}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value));}catch(e){reject(e);}}function rejected(value){try{step(generator["throw"](value));}catch(e){reject(e);}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected);}step((generator=generator.apply(thisArg,[])).next());})}function __generator(thisArg,body){var _={label:0,sent:function(){if(t[0]&1)throw t[1];return t[1]},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),"throw":verb(1),"return":verb(2)},typeof Symbol==="function"&&(g[Symbol.iterator]=function(){return this}),g;function verb(n){return function(v){return step([n,v])}}function step(op){if(f)throw new TypeError("Generator is already executing.");while(g&&(g=0,op[0]&&(_=0)),_)try{if(f=1,y&&(t=op[0]&2?y["return"]:op[0]?y["throw"]||((t=y["return"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return {value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break}if(t[2])_.ops.pop();_.trys.pop();continue}op=body.call(thisArg,_);}catch(e){op=[6,e];y=0;}finally{f=t=0;}if(op[0]&5)throw op[1];return {value:op[0]?op[1]:void 0,done:true}}}typeof SuppressedError==="function"?SuppressedError:function(error,suppressed,message){var e=new Error(message);return e.name="SuppressedError",e.error=error,e.suppressed=suppressed,e};/**
    		 * @internal
    		 */var BLOCK_SIZE=64;/**
    		 * @internal
    		 */var DIGEST_LENGTH=32;/**
    		 * @internal
    		 */var KEY=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]);/**
    		 * @internal
    		 */var INIT=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225];/**
    		 * @internal
    		 */var MAX_HASHABLE_LENGTH=Math.pow(2,53)-1;/**
    		 * @internal
    		 */var RawSha256=/** @class */function(){function RawSha256(){this.state=Int32Array.from(INIT);this.temp=new Int32Array(64);this.buffer=new Uint8Array(64);this.bufferLength=0;this.bytesHashed=0;/**
    		         * @internal
    		         */this.finished=false;}RawSha256.prototype.update=function(data){if(this.finished){throw new Error("Attempted to update an already finished hash.")}var position=0;var byteLength=data.byteLength;this.bytesHashed+=byteLength;if(this.bytesHashed*8>MAX_HASHABLE_LENGTH){throw new Error("Cannot hash more than 2^53 - 1 bits")}while(byteLength>0){this.buffer[this.bufferLength++]=data[position++];byteLength--;if(this.bufferLength===BLOCK_SIZE){this.hashBuffer();this.bufferLength=0;}}};RawSha256.prototype.digest=function(){if(!this.finished){var bitsHashed=this.bytesHashed*8;var bufferView=new DataView(this.buffer.buffer,this.buffer.byteOffset,this.buffer.byteLength);var undecoratedLength=this.bufferLength;bufferView.setUint8(this.bufferLength++,128);// Ensure the final block has enough room for the hashed length
    		if(undecoratedLength%BLOCK_SIZE>=BLOCK_SIZE-8){for(var i=this.bufferLength;i<BLOCK_SIZE;i++){bufferView.setUint8(i,0);}this.hashBuffer();this.bufferLength=0;}for(var i=this.bufferLength;i<BLOCK_SIZE-8;i++){bufferView.setUint8(i,0);}bufferView.setUint32(BLOCK_SIZE-8,Math.floor(bitsHashed/4294967296),true);bufferView.setUint32(BLOCK_SIZE-4,bitsHashed);this.hashBuffer();this.finished=true;}// The value in state is little-endian rather than big-endian, so flip
    		// each word into a new Uint8Array
    		var out=new Uint8Array(DIGEST_LENGTH);for(var i=0;i<8;i++){out[i*4]=this.state[i]>>>24&255;out[i*4+1]=this.state[i]>>>16&255;out[i*4+2]=this.state[i]>>>8&255;out[i*4+3]=this.state[i]>>>0&255;}return out};RawSha256.prototype.hashBuffer=function(){var _a=this,buffer=_a.buffer,state=_a.state;var state0=state[0],state1=state[1],state2=state[2],state3=state[3],state4=state[4],state5=state[5],state6=state[6],state7=state[7];for(var i=0;i<BLOCK_SIZE;i++){if(i<16){this.temp[i]=(buffer[i*4]&255)<<24|(buffer[i*4+1]&255)<<16|(buffer[i*4+2]&255)<<8|buffer[i*4+3]&255;}else {var u=this.temp[i-2];var t1_1=(u>>>17|u<<15)^(u>>>19|u<<13)^u>>>10;u=this.temp[i-15];var t2_1=(u>>>7|u<<25)^(u>>>18|u<<14)^u>>>3;this.temp[i]=(t1_1+this.temp[i-7]|0)+(t2_1+this.temp[i-16]|0);}var t1=(((state4>>>6|state4<<26)^(state4>>>11|state4<<21)^(state4>>>25|state4<<7))+(state4&state5^~state4&state6)|0)+(state7+(KEY[i]+this.temp[i]|0)|0)|0;var t2=((state0>>>2|state0<<30)^(state0>>>13|state0<<19)^(state0>>>22|state0<<10))+(state0&state1^state0&state2^state1&state2)|0;state7=state6;state6=state5;state5=state4;state4=state3+t1|0;state3=state2;state2=state1;state1=state0;state0=t1+t2|0;}state[0]+=state0;state[1]+=state1;state[2]+=state2;state[3]+=state3;state[4]+=state4;state[5]+=state5;state[6]+=state6;state[7]+=state7;};return RawSha256}();const fromUtf8$3=input=>new TextEncoder().encode(input);// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
    		// SPDX-License-Identifier: Apache-2.0
    		// Quick polyfill
    		var fromUtf8$2=typeof Buffer!=="undefined"&&Buffer.from?function(input){return Buffer.from(input,"utf8")}:fromUtf8$3;function convertToBuffer(data){// Already a Uint8, do nothing
    		if(data instanceof Uint8Array)return data;if(typeof data==="string"){return fromUtf8$2(data)}if(ArrayBuffer.isView(data)){return new Uint8Array(data.buffer,data.byteOffset,data.byteLength/Uint8Array.BYTES_PER_ELEMENT)}return new Uint8Array(data)}// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
    		// SPDX-License-Identifier: Apache-2.0
    		function isEmptyData(data){if(typeof data==="string"){return data.length===0}return data.byteLength===0}var Sha256$2=/** @class */function(){function Sha256(secret){this.secret=secret;this.hash=new RawSha256;this.reset();}Sha256.prototype.update=function(toHash){if(isEmptyData(toHash)||this.error){return}try{this.hash.update(convertToBuffer(toHash));}catch(e){this.error=e;}};/* This synchronous method keeps compatibility
    		     * with the v2 aws-sdk.
    		     */Sha256.prototype.digestSync=function(){if(this.error){throw this.error}if(this.outer){if(!this.outer.finished){this.outer.update(this.hash.digest());}return this.outer.digest()}return this.hash.digest()};/* The underlying digest method here is synchronous.
    		     * To keep the same interface with the other hash functions
    		     * the default is to expose this as an async method.
    		     * However, it can sometimes be useful to have a sync method.
    		     */Sha256.prototype.digest=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(_a){return [2/*return*/,this.digestSync()]})})};Sha256.prototype.reset=function(){this.hash=new RawSha256;if(this.secret){this.outer=new RawSha256;var inner=bufferFromSecret(this.secret);var outer=new Uint8Array(BLOCK_SIZE);outer.set(inner);for(var i=0;i<BLOCK_SIZE;i++){inner[i]^=54;outer[i]^=92;}this.hash.update(inner);this.outer.update(outer);// overwrite the copied key in memory
    		for(var i=0;i<inner.byteLength;i++){inner[i]=0;}}};return Sha256}();function bufferFromSecret(secret){var input=convertToBuffer(secret);if(input.byteLength>BLOCK_SIZE){var bufferHash=new RawSha256;bufferHash.update(input);input=bufferHash.digest();}var buffer=new Uint8Array(BLOCK_SIZE);buffer.set(input);return buffer}const SHORT_TO_HEX$1={};for(let i=0;i<256;i++){let encodedByte=i.toString(16).toLowerCase();if(encodedByte.length===1){encodedByte="0".concat(encodedByte);}SHORT_TO_HEX$1[i]=encodedByte;}function toHex$1(bytes){let out="";for(let i=0;i<bytes.byteLength;i++){out+=SHORT_TO_HEX$1[bytes[i]];}return out}/*
    		 * This is a copied and modified file from https://github.com/aws-amplify/amplify-js/blob/b96a0eddb53e6cb14eac22a2f5d7e0d1039b22d6/packages/core/src/Signer/Signer.ts
    		 * which was last modified on 02/13/2024
    		 * as well as several classes from https://github.com/aws-amplify/amplify-js/blob/main/packages/core/src/clients/middleware/signing/signer/signatureV4
    		 *
    		 * The Signer class has been deprecated and is no longer exported in aws-amplify/core. The aws-amplify/core package
    		 * intends to use the middleware/signing client going forward, but it also won't be exported so we can't use it
    		 * from our module.
    		 *
    		 * It has been modified to consolidate the necessary logic into a single file, and remove any un-needed logic for signing urls.
    		 * Modifications:
    		 * - Modified input parameters for signUrl to remove the other variants not needed for our use-case, only pass in a url not request, and include the region
    		 * - Hardcoded `geo` as the value of `service` to simplify logic
    		 * - Removed logic paths where a request was passed in instead of just a url
    		 */var __rest=function(s,e){var t={};for(var p in s)if(Object.prototype.hasOwnProperty.call(s,p)&&e.indexOf(p)<0)t[p]=s[p];if(s!=null&&typeof Object.getOwnPropertySymbols==="function")for(var i=0,p=Object.getOwnPropertySymbols(s);i<p.length;i++){if(e.indexOf(p[i])<0&&Object.prototype.propertyIsEnumerable.call(s,p[i]))t[p[i]]=s[p[i]];}return t};// Query params
    		const ALGORITHM_QUERY_PARAM$1="X-Amz-Algorithm";const AMZ_DATE_QUERY_PARAM$1="X-Amz-Date";const CREDENTIAL_QUERY_PARAM$1="X-Amz-Credential";const SIGNATURE_QUERY_PARAM$1="X-Amz-Signature";const SIGNED_HEADERS_QUERY_PARAM$1="X-Amz-SignedHeaders";const TOKEN_QUERY_PARAM$1="X-Amz-Security-Token";// Headers
    		const HOST_HEADER="host";// Identifiers
    		const KEY_TYPE_IDENTIFIER$1="aws4_request";const SHA256_ALGORITHM_IDENTIFIER="AWS4-HMAC-SHA256";const SIGNATURE_IDENTIFIER="AWS4";// Preset values
    		const EMPTY_HASH="e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";class Signer{static signUrl(urlToSign,region,accessInfo){const method="GET";let body;const presignable={body,method,url:new URL(urlToSign)};const options=getOptions(urlToSign,region,accessInfo);const signedUrl=presignUrl(presignable,options);return signedUrl.toString()}}const getOptions=(url,region,accessInfo)=>{const{access_key,secret_key,session_token}=accessInfo!==null&&accessInfo!==void 0?accessInfo:{};const credentials={accessKeyId:access_key,secretAccessKey:secret_key,sessionToken:session_token};// Service hard-coded to "geo" for our purposes
    		const service="geo";return {credentials,signingDate:new Date,signingRegion:region,signingService:service}};/**
    		 * Given a `Presignable` object, returns a Signature Version 4 presigned `URL` object.
    		 *
    		 * @param presignable `Presignable` object containing at least a url to be presigned with authentication query params.
    		 * @param presignUrlOptions `PresignUrlOptions` object containing values used to construct the signature.
    		 * @returns A `URL` with authentication query params which can grant temporary access to AWS resources.
    		 */const presignUrl=(_ref10,_a)=>{let{body,method="GET",url}=_ref10;var options=__rest(_a,[]);const signingValues=getSigningValues(options);const{accessKeyId,credentialScope,longDate,sessionToken}=signingValues;// create the request to sign
    		const presignedUrl=new URL(url);Object.entries(Object.assign({[ALGORITHM_QUERY_PARAM$1]:SHA256_ALGORITHM_IDENTIFIER,[CREDENTIAL_QUERY_PARAM$1]:"".concat(accessKeyId,"/").concat(credentialScope),[AMZ_DATE_QUERY_PARAM$1]:longDate,[SIGNED_HEADERS_QUERY_PARAM$1]:HOST_HEADER},sessionToken&&{[TOKEN_QUERY_PARAM$1]:sessionToken})).forEach(_ref11=>{let[key,value]=_ref11;presignedUrl.searchParams.append(key,value);});const requestToSign={body,headers:{[HOST_HEADER]:url.host},method,url:presignedUrl};// calculate and add the signature to the url
    		const signature=getSignature(requestToSign,signingValues);presignedUrl.searchParams.append(SIGNATURE_QUERY_PARAM$1,signature);return presignedUrl};/**
    		 * Extracts common values used for signing both requests and urls.
    		 *
    		 * @param options `SignRequestOptions` object containing values used to construct the signature.
    		 * @returns Common `SigningValues` used for signing.
    		 * @internal
    		 */const getSigningValues=_ref12=>{let{credentials,signingDate=new Date,signingRegion,signingService,uriEscapePath=true}=_ref12;// get properties from credentials
    		const{accessKeyId,secretAccessKey,sessionToken}=credentials;// get formatted dates for signing
    		const{longDate,shortDate}=getFormattedDates(signingDate);// copy header and set signing properties
    		const credentialScope=getCredentialScope(shortDate,signingRegion,signingService);return {accessKeyId,credentialScope,longDate,secretAccessKey,sessionToken,shortDate,signingRegion,signingService,uriEscapePath}};/**
    		 * Returns expected date strings to be used in signing.
    		 *
    		 * @param date JavaScript `Date` object.
    		 * @returns `FormattedDates` object containing the following:
    		 *
    		 *   - LongDate: A date string in 'YYYYMMDDThhmmssZ' format
    		 *   - ShortDate: A date string in 'YYYYMMDD' format
    		 *
    		 * @internal
    		 */const getFormattedDates=date=>{const longDate=date.toISOString().replace(/[:-]|\.\d{3}/g,"");return {longDate,shortDate:longDate.slice(0,8)}};/**
    		 * Returns the credential scope which restricts the resulting signature to the specified region and service.
    		 *
    		 * @param date Current date in the format 'YYYYMMDD'.
    		 * @param region AWS region in which the service resides.
    		 * @param service Service to which the signed request is being sent.
    		 * @returns A string representing the credential scope with format 'YYYYMMDD/region/service/aws4_request'.
    		 * @internal
    		 */const getCredentialScope=(date,region,service)=>"".concat(date,"/").concat(region,"/").concat(service,"/").concat(KEY_TYPE_IDENTIFIER$1);/**
    		 * Calculates and returns an AWS API Signature.
    		 * https://docs.aws.amazon.com/IAM/latest/UserGuide/create-signed-request.html
    		 *
    		 * @param request `HttpRequest` to be signed.
    		 * @param signRequestOptions `SignRequestOptions` object containing values used to construct the signature.
    		 * @returns AWS API Signature to sign a request or url with.
    		 * @internal
    		 */const getSignature=(request/*: HttpRequest*/,_ref13)=>{let{credentialScope,longDate,secretAccessKey,shortDate,signingRegion,signingService,uriEscapePath}=_ref13;// step 1: create a canonical request
    		const canonicalRequest=getCanonicalRequest(request,uriEscapePath);// step 2: create a hash of the canonical request
    		const hashedRequest=getHashedDataAsHex(null,canonicalRequest);// step 3: create a string to sign
    		const stringToSign=getStringToSign(longDate,credentialScope,hashedRequest);// step 4: calculate the signature
    		const signature=getHashedDataAsHex(getSigningKey$1(secretAccessKey,shortDate,signingRegion,signingService),stringToSign);return signature};/**
    		 * Returns a canonical request.
    		 *
    		 * @param request `HttpRequest` from which to create the canonical request from.
    		 * @param uriEscapePath Whether to uri encode the path as part of canonical uri. It's used for S3 only where the
    		 *   pathname is already uri encoded, and the signing process is not expected to uri encode it again. Defaults to true.
    		 * @returns String created by by concatenating the following strings, separated by newline characters:
    		 *
    		 *   - HTTPMethod
    		 *   - CanonicalUri
    		 *   - CanonicalQueryString
    		 *   - CanonicalHeaders
    		 *   - SignedHeaders
    		 *   - HashedPayload
    		 *
    		 * @internal
    		 */const getCanonicalRequest=function(_ref14){let{body,headers,method,url}=_ref14;let uriEscapePath=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;return [method,getCanonicalUri(url.pathname,uriEscapePath),getCanonicalQueryString(url.searchParams),getCanonicalHeaders$1(headers),getSignedHeaders(headers),getHashedPayload()].join("\n")};/**
    		 * Returns a canonical uri.
    		 *
    		 * @param pathname `pathname` from request url.
    		 * @param uriEscapePath Whether to uri encode the path as part of canonical uri. It's used for S3 only where the
    		 *   pathname is already uri encoded, and the signing process is not expected to uri encode it again. Defaults to true.
    		 * @returns URI-encoded version of the absolute path component URL (everything between the host and the question mark
    		 *   character (?) that starts the query string parameters). If the absolute path is empty, a forward slash character
    		 *   (/).
    		 * @internal
    		 */const getCanonicalUri=function(pathname){let uriEscapePath=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;return pathname?uriEscapePath?encodeURIComponent(pathname).replace(/%2F/g,"/"):pathname:"/"};/**
    		 * Returns a canonical query string.
    		 *
    		 * @param searchParams `searchParams` from the request url.
    		 * @returns URL-encoded query string parameters, separated by ampersands (&). Percent-encode reserved characters,
    		 *   including the space character. Encode names and values separately. If there are empty parameters, append the equals
    		 *   sign to the parameter name before encoding. After encoding, sort the parameters alphabetically by key name. If
    		 *   there is no query string, use an empty string ("").
    		 * @internal
    		 */const getCanonicalQueryString=searchParams=>Array.from(searchParams).sort((_ref15,_ref16)=>{let[keyA,valA]=_ref15;let[keyB,valB]=_ref16;if(keyA===keyB){return valA<valB?-1:1}return keyA<keyB?-1:1}).map(_ref17=>{let[key,val]=_ref17;return "".concat(escapeUri(key),"=").concat(escapeUri(val))}).join("&");const escapeUri=uri=>encodeURIComponent(uri).replace(/[!'()*]/g,hexEncode);const hexEncode=c=>"%".concat(c.charCodeAt(0).toString(16).toUpperCase());/**
    		 * Returns canonical headers.
    		 *
    		 * @param headers Headers from the request.
    		 * @returns Request headers that will be signed, and their values, separated by newline characters. Header names must
    		 *   use lowercase characters, must appear in alphabetical order, and must be followed by a colon (:). For the values,
    		 *   trim any leading or trailing spaces, convert sequential spaces to a single space, and separate the values for a
    		 *   multi-value header using commas.
    		 * @internal
    		 */const getCanonicalHeaders$1=headers=>Object.entries(headers).map(_ref18=>{let[key,value]=_ref18;var _a;return {key:key.toLowerCase(),value:(_a=value===null||value===void 0?void 0:value.trim().replace(/\s+/g," "))!==null&&_a!==void 0?_a:""}}).sort((a,b)=>a.key<b.key?-1:1).map(entry=>"".concat(entry.key,":").concat(entry.value,"\n")).join("");/**
    		 * Returns signed headers.
    		 *
    		 * @param headers `headers` from the request.
    		 * @returns List of headers included in canonical headers, separated by semicolons (;). This indicates which headers are
    		 *   part of the signing process. Header names must use lowercase characters and must appear in alphabetical order.
    		 * @internal
    		 */const getSignedHeaders=headers=>Object.keys(headers).map(key=>key.toLowerCase()).sort().join(";");const getHashedPayload=body=>{// Modification - For our use-case, the body is always null,
    		// so we just return the EMPTY_HASH
    		// return precalculated empty hash if body is undefined or null
    		return EMPTY_HASH};/**
    		 * Returns the hashed data a `Uint8Array`.
    		 *
    		 * @param key `SourceData` to be used as hashing key.
    		 * @param data Hashable `SourceData`.
    		 * @returns `Uint8Array` created from the data as input to a hash function.
    		 */const getHashedData=(key,data)=>{const sha256=new Sha256$2(key!==null&&key!==void 0?key:undefined);sha256.update(data);const hashedData=sha256.digestSync();return hashedData};/**
    		 * Returns the hashed data as a hex string.
    		 *
    		 * @param key `SourceData` to be used as hashing key.
    		 * @param data Hashable `SourceData`.
    		 * @returns String using lowercase hexadecimal characters created from the data as input to a hash function.
    		 * @internal
    		 */const getHashedDataAsHex=(key,data)=>{const hashedData=getHashedData(key,data);return toHex$1(hashedData)};/**
    		 * Returns a string to be signed.
    		 *
    		 * @param date Current date in the format 'YYYYMMDDThhmmssZ'.
    		 * @param credentialScope String representing the credential scope with format 'YYYYMMDD/region/service/aws4_request'.
    		 * @param hashedRequest Hashed canonical request.
    		 * @returns A string created by by concatenating the following strings, separated by newline characters:
    		 *
    		 *   - Algorithm
    		 *   - RequestDateTime
    		 *   - CredentialScope
    		 *   - HashedCanonicalRequest
    		 *
    		 * @internal
    		 */const getStringToSign=(date,credentialScope,hashedRequest)=>[SHA256_ALGORITHM_IDENTIFIER,date,credentialScope,hashedRequest].join("\n");/**
    		 * Returns a signing key to be used for signing requests.
    		 *
    		 * @param secretAccessKey AWS secret access key from credentials.
    		 * @param date Current date in the format 'YYYYMMDD'.
    		 * @param region AWS region in which the service resides.
    		 * @param service Service to which the signed request is being sent.
    		 * @returns `Uint8Array` calculated from its composite parts.
    		 * @internal
    		 */const getSigningKey$1=(secretAccessKey,date,region,service)=>{const key="".concat(SIGNATURE_IDENTIFIER).concat(secretAccessKey);const dateKey=getHashedData(key,date);const regionKey=getHashedData(dateKey,region);const serviceKey=getHashedData(regionKey,service);const signingKey=getHashedData(serviceKey,KEY_TYPE_IDENTIFIER$1);return signingKey};// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
    		// SPDX-License-Identifier: Apache-2.0
    		/**
    		 * Creates an auth helper instance using credentials from Cognito.
    		 *
    		 * @param identityPoolId Cognito Identity Pool Id
    		 */async function withIdentityPoolId(identityPoolId,options){const region=identityPoolId.split(":")[0];const credentialsProvider=fromCognitoIdentityPool(Object.assign(Object.assign({},options||{}),{identityPoolId,clientConfig:Object.assign(Object.assign({},options&&options.clientConfig?options.clientConfig:{}),{region})}));let credentials;async function refreshCredentials(){credentials=await credentialsProvider();let timeToRefresh=3600000;// default to 1 hour if credentials does not have expiration field
    		if(credentials.expiration){timeToRefresh=credentials.expiration.getTime()-new Date().getTime();}// timeToRefresh minus 1 minute to give some time for the actual refresh to happen.
    		setTimeout(refreshCredentials,timeToRefresh-60000);}await refreshCredentials();return {getMapAuthenticationOptions:()=>({transformRequest:url=>{// Only sign Amazon Location Service URLs
    		if(url.match("https://maps.(geo|geo-fips).(.*).amazonaws.com")){return {url:Signer.signUrl(url,region,{access_key:credentials.accessKeyId,secret_key:credentials.secretAccessKey,session_token:credentials.sessionToken})}}return {url}}}),getLocationClientConfig:()=>({credentials:credentialsProvider}),getCredentials:()=>credentials}}// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
    		// SPDX-License-Identifier: Apache-2.0
    		/**
    		 * Creates an auth helper instance using APIKey. Its `getLocationClientConfig` function creates a signer to set the
    		 * APIKey in all the commands of a client.
    		 *
    		 * @param apiKey APIKey
    		 */async function withAPIKey(apiKey){return {getLocationClientConfig:()=>({signer:{sign:async requestToSign=>{var _a;// APIKey in the command can override the APIKey set by auth helper.
    		requestToSign.query=Object.assign({key:apiKey},(_a=requestToSign.query)!==null&&_a!==void 0?_a:{});return requestToSign}},// Empty value to avoid calling the default credential providers chain
    		credentials:async()=>({})})}}function resolveHostHeaderConfig(input){return input}const hostHeaderMiddleware=options=>next=>async args=>{if(!HttpRequest.isInstance(args.request))return next(args);const{request}=args;const{handlerProtocol=""}=options.requestHandler.metadata||{};if(handlerProtocol.indexOf("h2")>=0&&!request.headers[":authority"]){delete request.headers["host"];request.headers[":authority"]=request.hostname+(request.port?":"+request.port:"");}else if(!request.headers["host"]){let host=request.hostname;if(request.port!=null)host+=":".concat(request.port);request.headers["host"]=host;}return next(args)};const hostHeaderMiddlewareOptions={name:"hostHeaderMiddleware",step:"build",priority:"low",tags:["HOST"],override:true};const getHostHeaderPlugin=options=>({applyToStack:clientStack=>{clientStack.add(hostHeaderMiddleware(options),hostHeaderMiddlewareOptions);}});const loggerMiddleware=()=>(next,context)=>async args=>{try{var _logger$info;const response=await next(args);const{clientName,commandName,logger,dynamoDbDocumentClientOptions={}}=context;const{overrideInputFilterSensitiveLog,overrideOutputFilterSensitiveLog}=dynamoDbDocumentClientOptions;const inputFilterSensitiveLog=overrideInputFilterSensitiveLog!==null&&overrideInputFilterSensitiveLog!==void 0?overrideInputFilterSensitiveLog:context.inputFilterSensitiveLog;const outputFilterSensitiveLog=overrideOutputFilterSensitiveLog!==null&&overrideOutputFilterSensitiveLog!==void 0?overrideOutputFilterSensitiveLog:context.outputFilterSensitiveLog;const{$metadata,...outputWithoutMetadata}=response.output;logger===null||logger===void 0||(_logger$info=logger.info)===null||_logger$info===void 0||_logger$info.call(logger,{clientName,commandName,input:inputFilterSensitiveLog(args.input),output:outputFilterSensitiveLog(outputWithoutMetadata),metadata:$metadata});return response}catch(error){var _logger$error;const{clientName,commandName,logger,dynamoDbDocumentClientOptions={}}=context;const{overrideInputFilterSensitiveLog}=dynamoDbDocumentClientOptions;const inputFilterSensitiveLog=overrideInputFilterSensitiveLog!==null&&overrideInputFilterSensitiveLog!==void 0?overrideInputFilterSensitiveLog:context.inputFilterSensitiveLog;logger===null||logger===void 0||(_logger$error=logger.error)===null||_logger$error===void 0||_logger$error.call(logger,{clientName,commandName,input:inputFilterSensitiveLog(args.input),error,metadata:error.$metadata});throw error}};const loggerMiddlewareOptions={name:"loggerMiddleware",tags:["LOGGER"],step:"initialize",override:true};const getLoggerPlugin=options=>({applyToStack:clientStack=>{clientStack.add(loggerMiddleware(),loggerMiddlewareOptions);}});const TRACE_ID_HEADER_NAME="X-Amzn-Trace-Id";const ENV_LAMBDA_FUNCTION_NAME="AWS_LAMBDA_FUNCTION_NAME";const ENV_TRACE_ID="_X_AMZN_TRACE_ID";const recursionDetectionMiddleware=options=>next=>async args=>{const{request}=args;if(!HttpRequest.isInstance(request)||options.runtime!=="node"||request.headers.hasOwnProperty(TRACE_ID_HEADER_NAME)){return next(args)}const functionName=process.env[ENV_LAMBDA_FUNCTION_NAME];const traceId=process.env[ENV_TRACE_ID];const nonEmptyString=str=>typeof str==="string"&&str.length>0;if(nonEmptyString(functionName)&&nonEmptyString(traceId)){request.headers[TRACE_ID_HEADER_NAME]=traceId;}return next({...args,request})};const addRecursionDetectionMiddlewareOptions={step:"build",tags:["RECURSION_DETECTION"],name:"recursionDetectionMiddleware",override:true,priority:"low"};const getRecursionDetectionPlugin=options=>({applyToStack:clientStack=>{clientStack.add(recursionDetectionMiddleware(options),addRecursionDetectionMiddlewareOptions);}});function resolveUserAgentConfig(input){return {...input,customUserAgent:typeof input.customUserAgent==="string"?[[input.customUserAgent]]:input.customUserAgent}}const IP_V4_REGEX=new RegExp("^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$");const isIpAddress=value=>IP_V4_REGEX.test(value)||value.startsWith("[")&&value.endsWith("]");const VALID_HOST_LABEL_REGEX=new RegExp("^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$");const isValidHostLabel=function(value){let allowSubDomains=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;if(!allowSubDomains){return VALID_HOST_LABEL_REGEX.test(value)}const labels=value.split(".");for(const label of labels){if(!isValidHostLabel(label)){return false}}return true};const customEndpointFunctions={};const debugId="endpoints";function toDebugString(input){if(typeof input!=="object"||input==null){return input}if("ref"in input){return "$".concat(toDebugString(input.ref))}if("fn"in input){return "".concat(input.fn,"(").concat((input.argv||[]).map(toDebugString).join(", "),")")}return JSON.stringify(input,null,2)}class EndpointError extends Error{constructor(message){super(message);this.name="EndpointError";}}const booleanEquals=(value1,value2)=>value1===value2;const getAttrPathList=path=>{const parts=path.split(".");const pathList=[];for(const part of parts){const squareBracketIndex=part.indexOf("[");if(squareBracketIndex!==-1){if(part.indexOf("]")!==part.length-1){throw new EndpointError("Path: '".concat(path,"' does not end with ']'"))}const arrayIndex=part.slice(squareBracketIndex+1,-1);if(Number.isNaN(parseInt(arrayIndex))){throw new EndpointError("Invalid array index: '".concat(arrayIndex,"' in path: '").concat(path,"'"))}if(squareBracketIndex!==0){pathList.push(part.slice(0,squareBracketIndex));}pathList.push(arrayIndex);}else {pathList.push(part);}}return pathList};const getAttr=(value,path)=>getAttrPathList(path).reduce((acc,index)=>{if(typeof acc!=="object"){throw new EndpointError("Index '".concat(index,"' in '").concat(path,"' not found in '").concat(JSON.stringify(value),"'"))}else if(Array.isArray(acc)){return acc[parseInt(index)]}return acc[index]},value);const isSet=value=>value!=null;const not=value=>!value;const DEFAULT_PORTS={[EndpointURLScheme.HTTP]:80,[EndpointURLScheme.HTTPS]:443};const parseURL=value=>{const whatwgURL=(()=>{try{if(value instanceof URL){return value}if(typeof value==="object"&&"hostname"in value){const{hostname,port,protocol="",path="",query={}}=value;const url=new URL("".concat(protocol,"//").concat(hostname).concat(port?":".concat(port):"").concat(path));url.search=Object.entries(query).map(_ref19=>{let[k,v]=_ref19;return "".concat(k,"=").concat(v)}).join("&");return url}return new URL(value)}catch(error){return null}})();if(!whatwgURL){console.error("Unable to parse ".concat(JSON.stringify(value)," as a whatwg URL."));return null}const urlString=whatwgURL.href;const{host,hostname,pathname,protocol,search}=whatwgURL;if(search){return null}const scheme=protocol.slice(0,-1);if(!Object.values(EndpointURLScheme).includes(scheme)){return null}const isIp=isIpAddress(hostname);const inputContainsDefaultPort=urlString.includes("".concat(host,":").concat(DEFAULT_PORTS[scheme]))||typeof value==="string"&&value.includes("".concat(host,":").concat(DEFAULT_PORTS[scheme]));const authority="".concat(host).concat(inputContainsDefaultPort?":".concat(DEFAULT_PORTS[scheme]):"");return {scheme,authority,path:pathname,normalizedPath:pathname.endsWith("/")?pathname:"".concat(pathname,"/"),isIp}};const stringEquals=(value1,value2)=>value1===value2;const substring=(input,start,stop,reverse)=>{if(start>=stop||input.length<stop){return null}if(!reverse){return input.substring(start,stop)}return input.substring(input.length-stop,input.length-start)};const uriEncode=value=>encodeURIComponent(value).replace(/[!*'()]/g,c=>"%".concat(c.charCodeAt(0).toString(16).toUpperCase()));const endpointFunctions={booleanEquals,getAttr,isSet,isValidHostLabel,not,parseURL,stringEquals,substring,uriEncode};const evaluateTemplate=(template,options)=>{const evaluatedTemplateArr=[];const templateContext={...options.endpointParams,...options.referenceRecord};let currentIndex=0;while(currentIndex<template.length){const openingBraceIndex=template.indexOf("{",currentIndex);if(openingBraceIndex===-1){evaluatedTemplateArr.push(template.slice(currentIndex));break}evaluatedTemplateArr.push(template.slice(currentIndex,openingBraceIndex));const closingBraceIndex=template.indexOf("}",openingBraceIndex);if(closingBraceIndex===-1){evaluatedTemplateArr.push(template.slice(openingBraceIndex));break}if(template[openingBraceIndex+1]==="{"&&template[closingBraceIndex+1]==="}"){evaluatedTemplateArr.push(template.slice(openingBraceIndex+1,closingBraceIndex));currentIndex=closingBraceIndex+2;}const parameterName=template.substring(openingBraceIndex+1,closingBraceIndex);if(parameterName.includes("#")){const[refName,attrName]=parameterName.split("#");evaluatedTemplateArr.push(getAttr(templateContext[refName],attrName));}else {evaluatedTemplateArr.push(templateContext[parameterName]);}currentIndex=closingBraceIndex+1;}return evaluatedTemplateArr.join("")};const getReferenceValue=(_ref20,options)=>{let{ref}=_ref20;const referenceRecord={...options.endpointParams,...options.referenceRecord};return referenceRecord[ref]};const evaluateExpression=(obj,keyName,options)=>{if(typeof obj==="string"){return evaluateTemplate(obj,options)}else if(obj["fn"]){return callFunction(obj,options)}else if(obj["ref"]){return getReferenceValue(obj,options)}throw new EndpointError("'".concat(keyName,"': ").concat(String(obj)," is not a string, function or reference."))};const callFunction=(_ref21,options)=>{let{fn,argv}=_ref21;const evaluatedArgs=argv.map(arg=>["boolean","number"].includes(typeof arg)?arg:evaluateExpression(arg,"arg",options));const fnSegments=fn.split(".");if(fnSegments[0]in customEndpointFunctions&&fnSegments[1]!=null){return customEndpointFunctions[fnSegments[0]][fnSegments[1]](...evaluatedArgs)}return endpointFunctions[fn](...evaluatedArgs)};const evaluateCondition=(_ref22,options)=>{var _options$logger,_options$logger$debug;let{assign,...fnArgs}=_ref22;if(assign&&assign in options.referenceRecord){throw new EndpointError("'".concat(assign,"' is already defined in Reference Record."))}const value=callFunction(fnArgs,options);(_options$logger=options.logger)===null||_options$logger===void 0||(_options$logger$debug=_options$logger.debug)===null||_options$logger$debug===void 0||_options$logger$debug.call(_options$logger,"".concat(debugId," evaluateCondition: ").concat(toDebugString(fnArgs)," = ").concat(toDebugString(value)));return {result:value===""?true:!!value,...(assign!=null&&{toAssign:{name:assign,value}})}};const evaluateConditions=function(){let conditions=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];let options=arguments.length>1?arguments[1]:undefined;const conditionsReferenceRecord={};for(const condition of conditions){const{result,toAssign}=evaluateCondition(condition,{...options,referenceRecord:{...options.referenceRecord,...conditionsReferenceRecord}});if(!result){return {result}}if(toAssign){var _options$logger2,_options$logger2$debu,_options$logger3;conditionsReferenceRecord[toAssign.name]=toAssign.value;(_options$logger2=options.logger)===null||_options$logger2===void 0||(_options$logger2$debu=(_options$logger3=_options$logger2).debug)===null||_options$logger2$debu===void 0||_options$logger2$debu.call(_options$logger3,"".concat(debugId," assign: ").concat(toAssign.name," := ").concat(toDebugString(toAssign.value)));}}return {result:true,referenceRecord:conditionsReferenceRecord}};const getEndpointHeaders=(headers,options)=>Object.entries(headers).reduce((acc,_ref23)=>{let[headerKey,headerVal]=_ref23;return {...acc,[headerKey]:headerVal.map(headerValEntry=>{const processedExpr=evaluateExpression(headerValEntry,"Header value entry",options);if(typeof processedExpr!=="string"){throw new EndpointError("Header '".concat(headerKey,"' value '").concat(processedExpr,"' is not a string"))}return processedExpr})}},{});const getEndpointProperty=(property,options)=>{if(Array.isArray(property)){return property.map(propertyEntry=>getEndpointProperty(propertyEntry,options))}switch(typeof property){case"string":return evaluateTemplate(property,options);case"object":if(property===null){throw new EndpointError("Unexpected endpoint property: ".concat(property))}return getEndpointProperties(property,options);case"boolean":return property;default:throw new EndpointError("Unexpected endpoint property type: ".concat(typeof property))}};const getEndpointProperties=(properties,options)=>Object.entries(properties).reduce((acc,_ref24)=>{let[propertyKey,propertyVal]=_ref24;return {...acc,[propertyKey]:getEndpointProperty(propertyVal,options)}},{});const getEndpointUrl=(endpointUrl,options)=>{const expression=evaluateExpression(endpointUrl,"Endpoint URL",options);if(typeof expression==="string"){try{return new URL(expression)}catch(error){console.error("Failed to construct URL with ".concat(expression),error);throw error}}throw new EndpointError("Endpoint URL must be a string, got ".concat(typeof expression))};const evaluateEndpointRule=(endpointRule,options)=>{var _options$logger4,_options$logger4$debu;const{conditions,endpoint}=endpointRule;const{result,referenceRecord}=evaluateConditions(conditions,options);if(!result){return}const endpointRuleOptions={...options,referenceRecord:{...options.referenceRecord,...referenceRecord}};const{url,properties,headers}=endpoint;(_options$logger4=options.logger)===null||_options$logger4===void 0||(_options$logger4$debu=_options$logger4.debug)===null||_options$logger4$debu===void 0||_options$logger4$debu.call(_options$logger4,"".concat(debugId," Resolving endpoint from template: ").concat(toDebugString(endpoint)));return {...(headers!=undefined&&{headers:getEndpointHeaders(headers,endpointRuleOptions)}),...(properties!=undefined&&{properties:getEndpointProperties(properties,endpointRuleOptions)}),url:getEndpointUrl(url,endpointRuleOptions)}};const evaluateErrorRule=(errorRule,options)=>{const{conditions,error}=errorRule;const{result,referenceRecord}=evaluateConditions(conditions,options);if(!result){return}throw new EndpointError(evaluateExpression(error,"Error",{...options,referenceRecord:{...options.referenceRecord,...referenceRecord}}))};const evaluateTreeRule=(treeRule,options)=>{const{conditions,rules}=treeRule;const{result,referenceRecord}=evaluateConditions(conditions,options);if(!result){return}return evaluateRules(rules,{...options,referenceRecord:{...options.referenceRecord,...referenceRecord}})};const evaluateRules=(rules,options)=>{for(const rule of rules){if(rule.type==="endpoint"){const endpointOrUndefined=evaluateEndpointRule(rule,options);if(endpointOrUndefined){return endpointOrUndefined}}else if(rule.type==="error"){evaluateErrorRule(rule,options);}else if(rule.type==="tree"){const endpointOrUndefined=evaluateTreeRule(rule,options);if(endpointOrUndefined){return endpointOrUndefined}}else {throw new EndpointError("Unknown endpoint rule: ".concat(rule))}}throw new EndpointError("Rules evaluation failed")};const resolveEndpoint=(ruleSetObject,options)=>{var _options$logger5,_options$logger5$debu,_options$endpointPara,_options$logger6,_options$logger6$debu;const{endpointParams,logger}=options;const{parameters,rules}=ruleSetObject;(_options$logger5=options.logger)===null||_options$logger5===void 0||(_options$logger5$debu=_options$logger5.debug)===null||_options$logger5$debu===void 0||_options$logger5$debu.call(_options$logger5,"".concat(debugId," Initial EndpointParams: ").concat(toDebugString(endpointParams)));const paramsWithDefault=Object.entries(parameters).filter(_ref25=>{let[,v]=_ref25;return v.default!=null}).map(_ref26=>{let[k,v]=_ref26;return [k,v.default]});if(paramsWithDefault.length>0){for(const[paramKey,paramDefaultValue]of paramsWithDefault){var _endpointParams$param;endpointParams[paramKey]=(_endpointParams$param=endpointParams[paramKey])!==null&&_endpointParams$param!==void 0?_endpointParams$param:paramDefaultValue;}}const requiredParams=Object.entries(parameters).filter(_ref27=>{let[,v]=_ref27;return v.required}).map(_ref28=>{let[k]=_ref28;return k});for(const requiredParam of requiredParams){if(endpointParams[requiredParam]==null){throw new EndpointError("Missing required parameter: '".concat(requiredParam,"'"))}}const endpoint=evaluateRules(rules,{endpointParams,logger,referenceRecord:{}});if((_options$endpointPara=options.endpointParams)!==null&&_options$endpointPara!==void 0&&_options$endpointPara.Endpoint){try{const givenEndpoint=new URL(options.endpointParams.Endpoint);const{protocol,port}=givenEndpoint;endpoint.url.protocol=protocol;endpoint.url.port=port;}catch(e){}}(_options$logger6=options.logger)===null||_options$logger6===void 0||(_options$logger6$debu=_options$logger6.debug)===null||_options$logger6$debu===void 0||_options$logger6$debu.call(_options$logger6,"".concat(debugId," Resolved endpoint: ").concat(toDebugString(endpoint)));return endpoint};const isVirtualHostableS3Bucket=function(value){let allowSubDomains=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;if(allowSubDomains){for(const label of value.split(".")){if(!isVirtualHostableS3Bucket(label)){return false}}return true}if(!isValidHostLabel(value)){return false}if(value.length<3||value.length>63){return false}if(value!==value.toLowerCase()){return false}if(isIpAddress(value)){return false}return true};const parseArn=value=>{const segments=value.split(":");if(segments.length<6)return null;const[arn,partition,service,region,accountId,...resourceId]=segments;if(arn!=="arn"||partition===""||service===""||resourceId[0]==="")return null;return {partition,service,region,accountId,resourceId:resourceId[0].includes("/")?resourceId[0].split("/"):resourceId}};var partitions=[{id:"aws",outputs:{dnsSuffix:"amazonaws.com",dualStackDnsSuffix:"api.aws",implicitGlobalRegion:"us-east-1",name:"aws",supportsDualStack:true,supportsFIPS:true},regionRegex:"^(us|eu|ap|sa|ca|me|af|il)\\-\\w+\\-\\d+$",regions:{"af-south-1":{description:"Africa (Cape Town)"},"ap-east-1":{description:"Asia Pacific (Hong Kong)"},"ap-northeast-1":{description:"Asia Pacific (Tokyo)"},"ap-northeast-2":{description:"Asia Pacific (Seoul)"},"ap-northeast-3":{description:"Asia Pacific (Osaka)"},"ap-south-1":{description:"Asia Pacific (Mumbai)"},"ap-south-2":{description:"Asia Pacific (Hyderabad)"},"ap-southeast-1":{description:"Asia Pacific (Singapore)"},"ap-southeast-2":{description:"Asia Pacific (Sydney)"},"ap-southeast-3":{description:"Asia Pacific (Jakarta)"},"ap-southeast-4":{description:"Asia Pacific (Melbourne)"},"aws-global":{description:"AWS Standard global region"},"ca-central-1":{description:"Canada (Central)"},"ca-west-1":{description:"Canada West (Calgary)"},"eu-central-1":{description:"Europe (Frankfurt)"},"eu-central-2":{description:"Europe (Zurich)"},"eu-north-1":{description:"Europe (Stockholm)"},"eu-south-1":{description:"Europe (Milan)"},"eu-south-2":{description:"Europe (Spain)"},"eu-west-1":{description:"Europe (Ireland)"},"eu-west-2":{description:"Europe (London)"},"eu-west-3":{description:"Europe (Paris)"},"il-central-1":{description:"Israel (Tel Aviv)"},"me-central-1":{description:"Middle East (UAE)"},"me-south-1":{description:"Middle East (Bahrain)"},"sa-east-1":{description:"South America (Sao Paulo)"},"us-east-1":{description:"US East (N. Virginia)"},"us-east-2":{description:"US East (Ohio)"},"us-west-1":{description:"US West (N. California)"},"us-west-2":{description:"US West (Oregon)"}}},{id:"aws-cn",outputs:{dnsSuffix:"amazonaws.com.cn",dualStackDnsSuffix:"api.amazonwebservices.com.cn",implicitGlobalRegion:"cn-northwest-1",name:"aws-cn",supportsDualStack:true,supportsFIPS:true},regionRegex:"^cn\\-\\w+\\-\\d+$",regions:{"aws-cn-global":{description:"AWS China global region"},"cn-north-1":{description:"China (Beijing)"},"cn-northwest-1":{description:"China (Ningxia)"}}},{id:"aws-us-gov",outputs:{dnsSuffix:"amazonaws.com",dualStackDnsSuffix:"api.aws",implicitGlobalRegion:"us-gov-west-1",name:"aws-us-gov",supportsDualStack:true,supportsFIPS:true},regionRegex:"^us\\-gov\\-\\w+\\-\\d+$",regions:{"aws-us-gov-global":{description:"AWS GovCloud (US) global region"},"us-gov-east-1":{description:"AWS GovCloud (US-East)"},"us-gov-west-1":{description:"AWS GovCloud (US-West)"}}},{id:"aws-iso",outputs:{dnsSuffix:"c2s.ic.gov",dualStackDnsSuffix:"c2s.ic.gov",implicitGlobalRegion:"us-iso-east-1",name:"aws-iso",supportsDualStack:false,supportsFIPS:true},regionRegex:"^us\\-iso\\-\\w+\\-\\d+$",regions:{"aws-iso-global":{description:"AWS ISO (US) global region"},"us-iso-east-1":{description:"US ISO East"},"us-iso-west-1":{description:"US ISO WEST"}}},{id:"aws-iso-b",outputs:{dnsSuffix:"sc2s.sgov.gov",dualStackDnsSuffix:"sc2s.sgov.gov",implicitGlobalRegion:"us-isob-east-1",name:"aws-iso-b",supportsDualStack:false,supportsFIPS:true},regionRegex:"^us\\-isob\\-\\w+\\-\\d+$",regions:{"aws-iso-b-global":{description:"AWS ISOB (US) global region"},"us-isob-east-1":{description:"US ISOB East (Ohio)"}}},{id:"aws-iso-e",outputs:{dnsSuffix:"cloud.adc-e.uk",dualStackDnsSuffix:"cloud.adc-e.uk",implicitGlobalRegion:"eu-isoe-west-1",name:"aws-iso-e",supportsDualStack:false,supportsFIPS:true},regionRegex:"^eu\\-isoe\\-\\w+\\-\\d+$",regions:{"eu-isoe-west-1":{description:"EU ISOE West"}}},{id:"aws-iso-f",outputs:{dnsSuffix:"csp.hci.ic.gov",dualStackDnsSuffix:"csp.hci.ic.gov",implicitGlobalRegion:"us-isof-south-1",name:"aws-iso-f",supportsDualStack:false,supportsFIPS:true},regionRegex:"^us\\-isof\\-\\w+\\-\\d+$",regions:{}}];var version$1="1.1";var partitionsInfo={partitions:partitions,version:version$1};let selectedPartitionsInfo=partitionsInfo;const partition=value=>{const{partitions}=selectedPartitionsInfo;for(const partition of partitions){const{regions,outputs}=partition;for(const[region,regionData]of Object.entries(regions)){if(region===value){return {...outputs,...regionData}}}}for(const partition of partitions){const{regionRegex,outputs}=partition;if(new RegExp(regionRegex).test(value)){return {...outputs}}}const DEFAULT_PARTITION=partitions.find(partition=>partition.id==="aws");if(!DEFAULT_PARTITION){throw new Error("Provided region was not found in the partition array or regex,"+" and default partition with id 'aws' doesn't exist.")}return {...DEFAULT_PARTITION.outputs}};const awsEndpointFunctions={isVirtualHostableS3Bucket:isVirtualHostableS3Bucket,parseArn:parseArn,partition:partition};customEndpointFunctions.aws=awsEndpointFunctions;const USER_AGENT="user-agent";const X_AMZ_USER_AGENT="x-amz-user-agent";const SPACE=" ";const UA_NAME_SEPARATOR="/";const UA_NAME_ESCAPE_REGEX=/[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g;const UA_VALUE_ESCAPE_REGEX=/[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g;const UA_ESCAPE_CHAR="-";const userAgentMiddleware=options=>(next,context)=>async args=>{var _context$userAgent,_options$customUserAg;const{request}=args;if(!HttpRequest.isInstance(request))return next(args);const{headers}=request;const userAgent=(context===null||context===void 0||(_context$userAgent=context.userAgent)===null||_context$userAgent===void 0?void 0:_context$userAgent.map(escapeUserAgent))||[];const defaultUserAgent=(await options.defaultUserAgentProvider()).map(escapeUserAgent);const customUserAgent=(options===null||options===void 0||(_options$customUserAg=options.customUserAgent)===null||_options$customUserAg===void 0?void 0:_options$customUserAg.map(escapeUserAgent))||[];const sdkUserAgentValue=[].concat([...defaultUserAgent,...userAgent,...customUserAgent]).join(SPACE);const normalUAValue=[...defaultUserAgent.filter(section=>section.startsWith("aws-sdk-")),...customUserAgent].join(SPACE);if(options.runtime!=="browser"){if(normalUAValue){headers[X_AMZ_USER_AGENT]=headers[X_AMZ_USER_AGENT]?"".concat(headers[USER_AGENT]," ").concat(normalUAValue):normalUAValue;}headers[USER_AGENT]=sdkUserAgentValue;}else {headers[X_AMZ_USER_AGENT]=sdkUserAgentValue;}return next({...args,request})};const escapeUserAgent=userAgentPair=>{var _userAgentPair$;const name=userAgentPair[0].split(UA_NAME_SEPARATOR).map(part=>part.replace(UA_NAME_ESCAPE_REGEX,UA_ESCAPE_CHAR)).join(UA_NAME_SEPARATOR);const version=(_userAgentPair$=userAgentPair[1])===null||_userAgentPair$===void 0?void 0:_userAgentPair$.replace(UA_VALUE_ESCAPE_REGEX,UA_ESCAPE_CHAR);const prefixSeparatorIndex=name.indexOf(UA_NAME_SEPARATOR);const prefix=name.substring(0,prefixSeparatorIndex);let uaName=name.substring(prefixSeparatorIndex+1);if(prefix==="api"){uaName=uaName.toLowerCase();}return [prefix,uaName,version].filter(item=>item&&item.length>0).reduce((acc,item,index)=>{switch(index){case 0:return item;case 1:return "".concat(acc,"/").concat(item);default:return "".concat(acc,"#").concat(item)}},"")};const getUserAgentMiddlewareOptions={name:"getUserAgentMiddleware",step:"build",priority:"low",tags:["SET_USER_AGENT","USER_AGENT"],override:true};const getUserAgentPlugin=config=>({applyToStack:clientStack=>{clientStack.add(userAgentMiddleware(config),getUserAgentMiddlewareOptions);}});var SelectorType;(function(SelectorType){SelectorType["ENV"]="env";SelectorType["CONFIG"]="shared config entry";})(SelectorType||(SelectorType={}));const DEFAULT_USE_DUALSTACK_ENDPOINT=false;const DEFAULT_USE_FIPS_ENDPOINT=false;const getSmithyContext=context=>context[SMITHY_CONTEXT_KEY]||(context[SMITHY_CONTEXT_KEY]={});const normalizeProvider$1=input=>{if(typeof input==="function")return input;const promisified=Promise.resolve(input);return ()=>promisified};const isFipsRegion=region=>typeof region==="string"&&(region.startsWith("fips-")||region.endsWith("-fips"));const getRealRegion=region=>isFipsRegion(region)?["fips-aws-global","aws-fips"].includes(region)?"us-east-1":region.replace(/fips-(dkr-|prod-)?|-fips/,""):region;const resolveRegionConfig=input=>{const{region,useFipsEndpoint}=input;if(!region){throw new Error("Region is missing")}return {...input,region:async()=>{if(typeof region==="string"){return getRealRegion(region)}const providedRegion=await region();return getRealRegion(providedRegion)},useFipsEndpoint:async()=>{const providedRegion=typeof region==="string"?region:await region();if(isFipsRegion(providedRegion)){return true}return typeof useFipsEndpoint!=="function"?Promise.resolve(!!useFipsEndpoint):useFipsEndpoint()}}};function convertHttpAuthSchemesToMap(httpAuthSchemes){const map=new Map;for(const scheme of httpAuthSchemes){map.set(scheme.schemeId,scheme);}return map}const httpAuthSchemeMiddleware=(config,mwOptions)=>(next,context)=>async args=>{const options=config.httpAuthSchemeProvider(await mwOptions.httpAuthSchemeParametersProvider(config,context,args.input));const authSchemes=convertHttpAuthSchemesToMap(config.httpAuthSchemes);const smithyContext=getSmithyContext(context);const failureReasons=[];for(const option of options){var _option$propertiesExt;const scheme=authSchemes.get(option.schemeId);if(!scheme){failureReasons.push("HttpAuthScheme `".concat(option.schemeId,"` was not enabled for this service."));continue}const identityProvider=scheme.identityProvider(await mwOptions.identityProviderConfigProvider(config));if(!identityProvider){failureReasons.push("HttpAuthScheme `".concat(option.schemeId,"` did not have an IdentityProvider configured."));continue}const{identityProperties={},signingProperties={}}=((_option$propertiesExt=option.propertiesExtractor)===null||_option$propertiesExt===void 0?void 0:_option$propertiesExt.call(option,config,context))||{};option.identityProperties=Object.assign(option.identityProperties||{},identityProperties);option.signingProperties=Object.assign(option.signingProperties||{},signingProperties);smithyContext.selectedHttpAuthScheme={httpAuthOption:option,identity:await identityProvider(option.identityProperties),signer:scheme.signer};break}if(!smithyContext.selectedHttpAuthScheme){throw new Error(failureReasons.join("\n"))}return next(args)};const resolveParamsForS3=async endpointParams=>{const bucket=(endpointParams===null||endpointParams===void 0?void 0:endpointParams.Bucket)||"";if(typeof endpointParams.Bucket==="string"){endpointParams.Bucket=bucket.replace(/#/g,encodeURIComponent("#")).replace(/\?/g,encodeURIComponent("?"));}if(isArnBucketName(bucket)){if(endpointParams.ForcePathStyle===true){throw new Error("Path-style addressing cannot be used with ARN buckets")}}else if(!isDnsCompatibleBucketName(bucket)||bucket.indexOf(".")!==-1&&!String(endpointParams.Endpoint).startsWith("http:")||bucket.toLowerCase()!==bucket||bucket.length<3){endpointParams.ForcePathStyle=true;}if(endpointParams.DisableMultiRegionAccessPoints){endpointParams.disableMultiRegionAccessPoints=true;endpointParams.DisableMRAP=true;}return endpointParams};const DOMAIN_PATTERN=/^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;const IP_ADDRESS_PATTERN=/(\d+\.){3}\d+/;const DOTS_PATTERN=/\.\./;const isDnsCompatibleBucketName=bucketName=>DOMAIN_PATTERN.test(bucketName)&&!IP_ADDRESS_PATTERN.test(bucketName)&&!DOTS_PATTERN.test(bucketName);const isArnBucketName=bucketName=>{const[arn,partition,service,,,bucket]=bucketName.split(":");const isArn=arn==="arn"&&bucketName.split(":").length>=6;const isValidArn=Boolean(isArn&&partition&&service&&bucket);if(isArn&&!isValidArn){throw new Error("Invalid ARN: ".concat(bucketName," was an invalid ARN."))}return isValidArn};const createConfigValueProvider=(configKey,canonicalEndpointParamKey,config)=>{const configProvider=async()=>{var _config$configKey;const configValue=(_config$configKey=config[configKey])!==null&&_config$configKey!==void 0?_config$configKey:config[canonicalEndpointParamKey];if(typeof configValue==="function"){return configValue()}return configValue};if(configKey==="credentialScope"||canonicalEndpointParamKey==="CredentialScope"){return async()=>{var _credentials$credenti;const credentials=typeof config.credentials==="function"?await config.credentials():config.credentials;const configValue=(_credentials$credenti=credentials===null||credentials===void 0?void 0:credentials.credentialScope)!==null&&_credentials$credenti!==void 0?_credentials$credenti:credentials===null||credentials===void 0?void 0:credentials.CredentialScope;return configValue}}if(configKey==="accountId"||canonicalEndpointParamKey==="AccountId"){return async()=>{var _credentials$accountI;const credentials=typeof config.credentials==="function"?await config.credentials():config.credentials;const configValue=(_credentials$accountI=credentials===null||credentials===void 0?void 0:credentials.accountId)!==null&&_credentials$accountI!==void 0?_credentials$accountI:credentials===null||credentials===void 0?void 0:credentials.AccountId;return configValue}}if(configKey==="endpoint"||canonicalEndpointParamKey==="endpoint"){return async()=>{const endpoint=await configProvider();if(endpoint&&typeof endpoint==="object"){if("url"in endpoint){return endpoint.url.href}if("hostname"in endpoint){const{protocol,hostname,port,path}=endpoint;return "".concat(protocol,"//").concat(hostname).concat(port?":"+port:"").concat(path)}}return endpoint}}return configProvider};const getEndpointFromConfig=async serviceId=>undefined;function parseQueryString(querystring){const query={};querystring=querystring.replace(/^\?/,"");if(querystring){for(const pair of querystring.split("&")){let[key,value=null]=pair.split("=");key=decodeURIComponent(key);if(value){value=decodeURIComponent(value);}if(!(key in query)){query[key]=value;}else if(Array.isArray(query[key])){query[key].push(value);}else {query[key]=[query[key],value];}}}return query}const parseUrl=url=>{if(typeof url==="string"){return parseUrl(new URL(url))}const{hostname,pathname,port,protocol,search}=url;let query;if(search){query=parseQueryString(search);}return {hostname,port:port?parseInt(port):undefined,protocol,path:pathname,query}};const toEndpointV1=endpoint=>{if(typeof endpoint==="object"){if("url"in endpoint){return parseUrl(endpoint.url)}return endpoint}return parseUrl(endpoint)};const getEndpointFromInstructions=async(commandInput,instructionsSupplier,clientConfig,context)=>{if(!clientConfig.endpoint){const endpointFromConfig=await getEndpointFromConfig(clientConfig.serviceId||"");if(endpointFromConfig){clientConfig.endpoint=()=>Promise.resolve(toEndpointV1(endpointFromConfig));}}const endpointParams=await resolveParams(commandInput,instructionsSupplier,clientConfig);if(typeof clientConfig.endpointProvider!=="function"){throw new Error("config.endpointProvider is not set.")}const endpoint=clientConfig.endpointProvider(endpointParams,context);return endpoint};const resolveParams=async(commandInput,instructionsSupplier,clientConfig)=>{var _instructionsSupplier;const endpointParams={};const instructions=(instructionsSupplier===null||instructionsSupplier===void 0||(_instructionsSupplier=instructionsSupplier.getEndpointParameterInstructions)===null||_instructionsSupplier===void 0?void 0:_instructionsSupplier.call(instructionsSupplier))||{};for(const[name,instruction]of Object.entries(instructions)){switch(instruction.type){case"staticContextParams":endpointParams[name]=instruction.value;break;case"contextParams":endpointParams[name]=commandInput[instruction.name];break;case"clientContextParams":case"builtInParams":endpointParams[name]=await createConfigValueProvider(instruction.name,name,clientConfig)();break;default:throw new Error("Unrecognized endpoint parameter instruction: "+JSON.stringify(instruction))}}if(Object.keys(instructions).length===0){Object.assign(endpointParams,clientConfig);}if(String(clientConfig.serviceId).toLowerCase()==="s3"){await resolveParamsForS3(endpointParams);}return endpointParams};const endpointMiddleware=_ref29=>{let{config,instructions}=_ref29;return (next,context)=>async args=>{var _endpoint$properties,_context$authSchemes;const endpoint=await getEndpointFromInstructions(args.input,{getEndpointParameterInstructions(){return instructions}},{...config},context);context.endpointV2=endpoint;context.authSchemes=(_endpoint$properties=endpoint.properties)===null||_endpoint$properties===void 0?void 0:_endpoint$properties.authSchemes;const authScheme=(_context$authSchemes=context.authSchemes)===null||_context$authSchemes===void 0?void 0:_context$authSchemes[0];if(authScheme){var _smithyContext$select;context["signing_region"]=authScheme.signingRegion;context["signing_service"]=authScheme.signingName;const smithyContext=getSmithyContext(context);const httpAuthOption=smithyContext===null||smithyContext===void 0||(_smithyContext$select=smithyContext.selectedHttpAuthScheme)===null||_smithyContext$select===void 0?void 0:_smithyContext$select.httpAuthOption;if(httpAuthOption){httpAuthOption.signingProperties=Object.assign(httpAuthOption.signingProperties||{},{signing_region:authScheme.signingRegion,signingRegion:authScheme.signingRegion,signing_service:authScheme.signingName,signingName:authScheme.signingName,signingRegionSet:authScheme.signingRegionSet},authScheme.properties);}}return next({...args})}};const deserializerMiddleware=(options,deserializer)=>next=>async args=>{const{response}=await next(args);try{const parsed=await deserializer(response,options);return {response,output:parsed}}catch(error){Object.defineProperty(error,"$response",{value:response});if(!("$metadata"in error)){const hint="Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.";error.message+="\n  "+hint;if(typeof error.$responseBodyText!=="undefined"){if(error.$response){error.$response.body=error.$responseBodyText;}}}throw error}};const serializerMiddleware=(options,serializer)=>(next,context)=>async args=>{var _context$endpointV;const endpoint=(_context$endpointV=context.endpointV2)!==null&&_context$endpointV!==void 0&&_context$endpointV.url&&options.urlParser?async()=>options.urlParser(context.endpointV2.url):options.endpoint;if(!endpoint){throw new Error("No valid endpoint provider available.")}const request=await serializer(args.input,{...options,endpoint});return next({...args,request})};const deserializerMiddlewareOption={name:"deserializerMiddleware",step:"deserialize",tags:["DESERIALIZER"],override:true};const serializerMiddlewareOption={name:"serializerMiddleware",step:"serialize",tags:["SERIALIZER"],override:true};function getSerdePlugin(config,serializer,deserializer){return {applyToStack:commandStack=>{commandStack.add(deserializerMiddleware(config,deserializer),deserializerMiddlewareOption);commandStack.add(serializerMiddleware(config,serializer),serializerMiddlewareOption);}}}const endpointMiddlewareOptions={step:"serialize",tags:["ENDPOINT_PARAMETERS","ENDPOINT_V2","ENDPOINT"],name:"endpointV2Middleware",override:true,relation:"before",toMiddleware:serializerMiddlewareOption.name};const getEndpointPlugin=(config,instructions)=>({applyToStack:clientStack=>{clientStack.addRelativeTo(endpointMiddleware({config,instructions}),endpointMiddlewareOptions);}});const resolveEndpointConfig=input=>{var _input$tls,_input$useDualstackEn,_input$useFipsEndpoin;const tls=(_input$tls=input.tls)!==null&&_input$tls!==void 0?_input$tls:true;const{endpoint}=input;const customEndpointProvider=endpoint!=null?async()=>toEndpointV1(await normalizeProvider$1(endpoint)()):undefined;const isCustomEndpoint=!!endpoint;return {...input,endpoint:customEndpointProvider,tls,isCustomEndpoint,useDualstackEndpoint:normalizeProvider$1((_input$useDualstackEn=input.useDualstackEndpoint)!==null&&_input$useDualstackEn!==void 0?_input$useDualstackEn:false),useFipsEndpoint:normalizeProvider$1((_input$useFipsEndpoin=input.useFipsEndpoint)!==null&&_input$useFipsEndpoin!==void 0?_input$useFipsEndpoin:false)}};const httpAuthSchemeEndpointRuleSetMiddlewareOptions={step:"serialize",tags:["HTTP_AUTH_SCHEME"],name:"httpAuthSchemeMiddleware",override:true,relation:"before",toMiddleware:endpointMiddlewareOptions.name};const getHttpAuthSchemeEndpointRuleSetPlugin=(config,_ref30)=>{let{httpAuthSchemeParametersProvider,identityProviderConfigProvider}=_ref30;return {applyToStack:clientStack=>{clientStack.addRelativeTo(httpAuthSchemeMiddleware(config,{httpAuthSchemeParametersProvider,identityProviderConfigProvider}),httpAuthSchemeEndpointRuleSetMiddlewareOptions);}}};({step:"serialize",tags:["HTTP_AUTH_SCHEME"],name:"httpAuthSchemeMiddleware",override:true,relation:"before",toMiddleware:serializerMiddlewareOption.name});const defaultErrorHandler=signingProperties=>error=>{throw error};const defaultSuccessHandler=(httpResponse,signingProperties)=>{};const httpSigningMiddleware=config=>(next,context)=>async args=>{if(!HttpRequest.isInstance(args.request)){return next(args)}const smithyContext=getSmithyContext(context);const scheme=smithyContext.selectedHttpAuthScheme;if(!scheme){throw new Error("No HttpAuthScheme was selected: unable to sign request")}const{httpAuthOption:{signingProperties={}},identity,signer}=scheme;const output=await next({...args,request:await signer.sign(args.request,identity,signingProperties)}).catch((signer.errorHandler||defaultErrorHandler)(signingProperties));(signer.successHandler||defaultSuccessHandler)(output.response,signingProperties);return output};var RETRY_MODES;(function(RETRY_MODES){RETRY_MODES["STANDARD"]="standard";RETRY_MODES["ADAPTIVE"]="adaptive";})(RETRY_MODES||(RETRY_MODES={}));const DEFAULT_MAX_ATTEMPTS=3;const DEFAULT_RETRY_MODE=RETRY_MODES.STANDARD;const THROTTLING_ERROR_CODES=["BandwidthLimitExceeded","EC2ThrottledException","LimitExceededException","PriorRequestNotComplete","ProvisionedThroughputExceededException","RequestLimitExceeded","RequestThrottled","RequestThrottledException","SlowDown","ThrottledException","Throttling","ThrottlingException","TooManyRequestsException","TransactionInProgressException"];const TRANSIENT_ERROR_CODES=["TimeoutError","RequestTimeout","RequestTimeoutException"];const TRANSIENT_ERROR_STATUS_CODES=[500,502,503,504];const NODEJS_TIMEOUT_ERROR_CODES=["ECONNRESET","ECONNREFUSED","EPIPE","ETIMEDOUT"];const isClockSkewCorrectedError=error=>{var _error$$metadata;return (_error$$metadata=error.$metadata)===null||_error$$metadata===void 0?void 0:_error$$metadata.clockSkewCorrected};const isThrottlingError=error=>{var _error$$metadata2,_error$$retryable;return ((_error$$metadata2=error.$metadata)===null||_error$$metadata2===void 0?void 0:_error$$metadata2.httpStatusCode)===429||THROTTLING_ERROR_CODES.includes(error.name)||((_error$$retryable=error.$retryable)===null||_error$$retryable===void 0?void 0:_error$$retryable.throttling)==true};const isTransientError=error=>{var _error$$metadata3;return isClockSkewCorrectedError(error)||TRANSIENT_ERROR_CODES.includes(error.name)||NODEJS_TIMEOUT_ERROR_CODES.includes((error===null||error===void 0?void 0:error.code)||"")||TRANSIENT_ERROR_STATUS_CODES.includes(((_error$$metadata3=error.$metadata)===null||_error$$metadata3===void 0?void 0:_error$$metadata3.httpStatusCode)||0)};const isServerError=error=>{var _error$$metadata4;if(((_error$$metadata4=error.$metadata)===null||_error$$metadata4===void 0?void 0:_error$$metadata4.httpStatusCode)!==undefined){const statusCode=error.$metadata.httpStatusCode;if(500<=statusCode&&statusCode<=599&&!isTransientError(error)){return true}return false}return false};class DefaultRateLimiter{constructor(options){var _options$beta,_options$minCapacity,_options$minFillRate,_options$scaleConstan,_options$smooth;this.currentCapacity=0;this.enabled=false;this.lastMaxRate=0;this.measuredTxRate=0;this.requestCount=0;this.lastTimestamp=0;this.timeWindow=0;this.beta=(_options$beta=options===null||options===void 0?void 0:options.beta)!==null&&_options$beta!==void 0?_options$beta:0.7;this.minCapacity=(_options$minCapacity=options===null||options===void 0?void 0:options.minCapacity)!==null&&_options$minCapacity!==void 0?_options$minCapacity:1;this.minFillRate=(_options$minFillRate=options===null||options===void 0?void 0:options.minFillRate)!==null&&_options$minFillRate!==void 0?_options$minFillRate:0.5;this.scaleConstant=(_options$scaleConstan=options===null||options===void 0?void 0:options.scaleConstant)!==null&&_options$scaleConstan!==void 0?_options$scaleConstan:0.4;this.smooth=(_options$smooth=options===null||options===void 0?void 0:options.smooth)!==null&&_options$smooth!==void 0?_options$smooth:0.8;const currentTimeInSeconds=this.getCurrentTimeInSeconds();this.lastThrottleTime=currentTimeInSeconds;this.lastTxRateBucket=Math.floor(this.getCurrentTimeInSeconds());this.fillRate=this.minFillRate;this.maxCapacity=this.minCapacity;}getCurrentTimeInSeconds(){return Date.now()/1000}async getSendToken(){return this.acquireTokenBucket(1)}async acquireTokenBucket(amount){if(!this.enabled){return}this.refillTokenBucket();if(amount>this.currentCapacity){const delay=(amount-this.currentCapacity)/this.fillRate*1000;await new Promise(resolve=>setTimeout(resolve,delay));}this.currentCapacity=this.currentCapacity-amount;}refillTokenBucket(){const timestamp=this.getCurrentTimeInSeconds();if(!this.lastTimestamp){this.lastTimestamp=timestamp;return}const fillAmount=(timestamp-this.lastTimestamp)*this.fillRate;this.currentCapacity=Math.min(this.maxCapacity,this.currentCapacity+fillAmount);this.lastTimestamp=timestamp;}updateClientSendingRate(response){let calculatedRate;this.updateMeasuredRate();if(isThrottlingError(response)){const rateToUse=!this.enabled?this.measuredTxRate:Math.min(this.measuredTxRate,this.fillRate);this.lastMaxRate=rateToUse;this.calculateTimeWindow();this.lastThrottleTime=this.getCurrentTimeInSeconds();calculatedRate=this.cubicThrottle(rateToUse);this.enableTokenBucket();}else {this.calculateTimeWindow();calculatedRate=this.cubicSuccess(this.getCurrentTimeInSeconds());}const newRate=Math.min(calculatedRate,2*this.measuredTxRate);this.updateTokenBucketRate(newRate);}calculateTimeWindow(){this.timeWindow=this.getPrecise(Math.pow(this.lastMaxRate*(1-this.beta)/this.scaleConstant,1/3));}cubicThrottle(rateToUse){return this.getPrecise(rateToUse*this.beta)}cubicSuccess(timestamp){return this.getPrecise(this.scaleConstant*Math.pow(timestamp-this.lastThrottleTime-this.timeWindow,3)+this.lastMaxRate)}enableTokenBucket(){this.enabled=true;}updateTokenBucketRate(newRate){this.refillTokenBucket();this.fillRate=Math.max(newRate,this.minFillRate);this.maxCapacity=Math.max(newRate,this.minCapacity);this.currentCapacity=Math.min(this.currentCapacity,this.maxCapacity);}updateMeasuredRate(){const t=this.getCurrentTimeInSeconds();const timeBucket=Math.floor(t*2)/2;this.requestCount++;if(timeBucket>this.lastTxRateBucket){const currentRate=this.requestCount/(timeBucket-this.lastTxRateBucket);this.measuredTxRate=this.getPrecise(currentRate*this.smooth+this.measuredTxRate*(1-this.smooth));this.requestCount=0;this.lastTxRateBucket=timeBucket;}}getPrecise(num){return parseFloat(num.toFixed(8))}}const DEFAULT_RETRY_DELAY_BASE=100;const MAXIMUM_RETRY_DELAY=20*1000;const THROTTLING_RETRY_DELAY_BASE=500;const INITIAL_RETRY_TOKENS=500;const RETRY_COST=5;const TIMEOUT_RETRY_COST=10;const NO_RETRY_INCREMENT=1;const INVOCATION_ID_HEADER="amz-sdk-invocation-id";const REQUEST_HEADER="amz-sdk-request";const getDefaultRetryBackoffStrategy=()=>{let delayBase=DEFAULT_RETRY_DELAY_BASE;const computeNextBackoffDelay=attempts=>{return Math.floor(Math.min(MAXIMUM_RETRY_DELAY,Math.random()*2**attempts*delayBase))};const setDelayBase=delay=>{delayBase=delay;};return {computeNextBackoffDelay,setDelayBase}};const createDefaultRetryToken=_ref31=>{let{retryDelay,retryCount,retryCost}=_ref31;const getRetryCount=()=>retryCount;const getRetryDelay=()=>Math.min(MAXIMUM_RETRY_DELAY,retryDelay);const getRetryCost=()=>retryCost;return {getRetryCount,getRetryDelay,getRetryCost}};class StandardRetryStrategy{constructor(maxAttempts){this.maxAttempts=maxAttempts;this.mode=RETRY_MODES.STANDARD;this.capacity=INITIAL_RETRY_TOKENS;this.retryBackoffStrategy=getDefaultRetryBackoffStrategy();this.maxAttemptsProvider=typeof maxAttempts==="function"?maxAttempts:async()=>maxAttempts;}async acquireInitialRetryToken(retryTokenScope){return createDefaultRetryToken({retryDelay:DEFAULT_RETRY_DELAY_BASE,retryCount:0})}async refreshRetryTokenForRetry(token,errorInfo){const maxAttempts=await this.getMaxAttempts();if(this.shouldRetry(token,errorInfo,maxAttempts)){const errorType=errorInfo.errorType;this.retryBackoffStrategy.setDelayBase(errorType==="THROTTLING"?THROTTLING_RETRY_DELAY_BASE:DEFAULT_RETRY_DELAY_BASE);const delayFromErrorType=this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());const retryDelay=errorInfo.retryAfterHint?Math.max(errorInfo.retryAfterHint.getTime()-Date.now()||0,delayFromErrorType):delayFromErrorType;const capacityCost=this.getCapacityCost(errorType);this.capacity-=capacityCost;return createDefaultRetryToken({retryDelay,retryCount:token.getRetryCount()+1,retryCost:capacityCost})}throw new Error("No retry token available")}recordSuccess(token){var _token$getRetryCost;this.capacity=Math.max(INITIAL_RETRY_TOKENS,this.capacity+((_token$getRetryCost=token.getRetryCost())!==null&&_token$getRetryCost!==void 0?_token$getRetryCost:NO_RETRY_INCREMENT));}getCapacity(){return this.capacity}async getMaxAttempts(){try{return await this.maxAttemptsProvider()}catch(error){console.warn("Max attempts provider could not resolve. Using default of ".concat(DEFAULT_MAX_ATTEMPTS));return DEFAULT_MAX_ATTEMPTS}}shouldRetry(tokenToRenew,errorInfo,maxAttempts){const attempts=tokenToRenew.getRetryCount()+1;return attempts<maxAttempts&&this.capacity>=this.getCapacityCost(errorInfo.errorType)&&this.isRetryableError(errorInfo.errorType)}getCapacityCost(errorType){return errorType==="TRANSIENT"?TIMEOUT_RETRY_COST:RETRY_COST}isRetryableError(errorType){return errorType==="THROTTLING"||errorType==="TRANSIENT"}}class AdaptiveRetryStrategy{constructor(maxAttemptsProvider,options){this.maxAttemptsProvider=maxAttemptsProvider;this.mode=RETRY_MODES.ADAPTIVE;const{rateLimiter}=options!==null&&options!==void 0?options:{};this.rateLimiter=rateLimiter!==null&&rateLimiter!==void 0?rateLimiter:new DefaultRateLimiter;this.standardRetryStrategy=new StandardRetryStrategy(maxAttemptsProvider);}async acquireInitialRetryToken(retryTokenScope){await this.rateLimiter.getSendToken();return this.standardRetryStrategy.acquireInitialRetryToken(retryTokenScope)}async refreshRetryTokenForRetry(tokenToRenew,errorInfo){this.rateLimiter.updateClientSendingRate(errorInfo);return this.standardRetryStrategy.refreshRetryTokenForRetry(tokenToRenew,errorInfo)}recordSuccess(token){this.rateLimiter.updateClientSendingRate({});this.standardRetryStrategy.recordSuccess(token);}}// Unique ID creation requires a high quality random # generator. In the browser we therefore
    		// require the crypto API and do not support built-in fallback to lower quality random number
    		// generators (like Math.random()).
    		let getRandomValues;const rnds8=new Uint8Array(16);function rng(){// lazy load so that environments that need to polyfill have a chance to do so
    		if(!getRandomValues){// getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
    		getRandomValues=typeof crypto!=="undefined"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto);if(!getRandomValues){throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported")}}return getRandomValues(rnds8)}/**
    		 * Convert array of 16 byte values to UUID string format of the form:
    		 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
    		 */const byteToHex=[];for(let i=0;i<256;++i){byteToHex.push((i+256).toString(16).slice(1));}function unsafeStringify(arr){let offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;// Note: Be careful editing this code!  It's been tuned for performance
    		// and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
    		return byteToHex[arr[offset+0]]+byteToHex[arr[offset+1]]+byteToHex[arr[offset+2]]+byteToHex[arr[offset+3]]+"-"+byteToHex[arr[offset+4]]+byteToHex[arr[offset+5]]+"-"+byteToHex[arr[offset+6]]+byteToHex[arr[offset+7]]+"-"+byteToHex[arr[offset+8]]+byteToHex[arr[offset+9]]+"-"+byteToHex[arr[offset+10]]+byteToHex[arr[offset+11]]+byteToHex[arr[offset+12]]+byteToHex[arr[offset+13]]+byteToHex[arr[offset+14]]+byteToHex[arr[offset+15]]}const randomUUID=typeof crypto!=="undefined"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto);var native={randomUUID};function v4(options,buf,offset){if(native.randomUUID&&!buf&&!options){return native.randomUUID()}options=options||{};const rnds=options.random||(options.rng||rng)();// Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    		rnds[6]=rnds[6]&15|64;rnds[8]=rnds[8]&63|128;// Copy bytes to buffer, if provided
    return unsafeStringify(rnds)}const asSdkError=error=>{if(error instanceof Error)return error;if(error instanceof Object)return Object.assign(new Error,error);if(typeof error==="string")return new Error(error);return new Error("AWS SDK error wrapper for ".concat(error))};const resolveRetryConfig=input=>{var _input$maxAttempts;const{retryStrategy}=input;const maxAttempts=normalizeProvider$1((_input$maxAttempts=input.maxAttempts)!==null&&_input$maxAttempts!==void 0?_input$maxAttempts:DEFAULT_MAX_ATTEMPTS);return {...input,maxAttempts,retryStrategy:async()=>{if(retryStrategy){return retryStrategy}const retryMode=await normalizeProvider$1(input.retryMode)();if(retryMode===RETRY_MODES.ADAPTIVE){return new AdaptiveRetryStrategy(maxAttempts)}return new StandardRetryStrategy(maxAttempts)}}};const isStreamingPayload=request=>(request===null||request===void 0?void 0:request.body)instanceof ReadableStream;const retryMiddleware=options=>(next,context)=>async args=>{let retryStrategy=await options.retryStrategy();const maxAttempts=await options.maxAttempts();if(isRetryStrategyV2(retryStrategy)){retryStrategy=retryStrategy;let retryToken=await retryStrategy.acquireInitialRetryToken(context["partition_id"]);let lastError=new Error;let attempts=0;let totalRetryDelay=0;const{request}=args;const isRequest=HttpRequest.isInstance(request);if(isRequest){request.headers[INVOCATION_ID_HEADER]=v4();}while(true){try{if(isRequest){request.headers[REQUEST_HEADER]="attempt=".concat(attempts+1,"; max=").concat(maxAttempts);}const{response,output}=await next(args);retryStrategy.recordSuccess(retryToken);output.$metadata.attempts=attempts+1;output.$metadata.totalRetryDelay=totalRetryDelay;return {response,output}}catch(e){const retryErrorInfo=getRetryErrorInfo(e);lastError=asSdkError(e);if(isRequest&&isStreamingPayload(request)){var _ref32;(_ref32=context.logger instanceof NoOpLogger?console:context.logger)===null||_ref32===void 0||_ref32.warn("An error was encountered in a non-retryable streaming request.");throw lastError}try{retryToken=await retryStrategy.refreshRetryTokenForRetry(retryToken,retryErrorInfo);}catch(refreshError){if(!lastError.$metadata){lastError.$metadata={};}lastError.$metadata.attempts=attempts+1;lastError.$metadata.totalRetryDelay=totalRetryDelay;throw lastError}attempts=retryToken.getRetryCount();const delay=retryToken.getRetryDelay();totalRetryDelay+=delay;await new Promise(resolve=>setTimeout(resolve,delay));}}}else {var _retryStrategy2;retryStrategy=retryStrategy;if((_retryStrategy2=retryStrategy)!==null&&_retryStrategy2!==void 0&&_retryStrategy2.mode)context.userAgent=[...(context.userAgent||[]),["cfg/retry-mode",retryStrategy.mode]];return retryStrategy.retry(next,args)}};const isRetryStrategyV2=retryStrategy=>typeof retryStrategy.acquireInitialRetryToken!=="undefined"&&typeof retryStrategy.refreshRetryTokenForRetry!=="undefined"&&typeof retryStrategy.recordSuccess!=="undefined";const getRetryErrorInfo=error=>{const errorInfo={error,errorType:getRetryErrorType(error)};const retryAfterHint=getRetryAfterHint(error.$response);if(retryAfterHint){errorInfo.retryAfterHint=retryAfterHint;}return errorInfo};const getRetryErrorType=error=>{if(isThrottlingError(error))return "THROTTLING";if(isTransientError(error))return "TRANSIENT";if(isServerError(error))return "SERVER_ERROR";return "CLIENT_ERROR"};const retryMiddlewareOptions={name:"retryMiddleware",tags:["RETRY"],step:"finalizeRequest",priority:"high",override:true};const getRetryPlugin=options=>({applyToStack:clientStack=>{clientStack.add(retryMiddleware(options),retryMiddlewareOptions);}});const getRetryAfterHint=response=>{if(!HttpResponse.isInstance(response))return;const retryAfterHeaderName=Object.keys(response.headers).find(key=>key.toLowerCase()==="retry-after");if(!retryAfterHeaderName)return;const retryAfter=response.headers[retryAfterHeaderName];const retryAfterSeconds=Number(retryAfter);if(!Number.isNaN(retryAfterSeconds))return new Date(retryAfterSeconds*1000);const retryAfterDate=new Date(retryAfter);return retryAfterDate};const httpSigningMiddlewareOptions={step:"finalizeRequest",tags:["HTTP_SIGNING"],name:"httpSigningMiddleware",aliases:["apiKeyMiddleware","tokenMiddleware","awsAuthMiddleware"],override:true,relation:"after",toMiddleware:retryMiddlewareOptions.name};const getHttpSigningPlugin=config=>({applyToStack:clientStack=>{clientStack.addRelativeTo(httpSigningMiddleware(),httpSigningMiddlewareOptions);}});class DefaultIdentityProviderConfig{constructor(config){this.authSchemes=new Map;for(const[key,value]of Object.entries(config)){if(value!==undefined){this.authSchemes.set(key,value);}}}getIdentityProvider(schemeId){return this.authSchemes.get(schemeId)}}class NoAuthSigner{async sign(httpRequest,identity,signingProperties){return httpRequest}}const createIsIdentityExpiredFunction=expirationMs=>identity=>doesIdentityRequireRefresh(identity)&&identity.expiration.getTime()-Date.now()<expirationMs;const EXPIRATION_MS=300000;const isIdentityExpired=createIsIdentityExpiredFunction(EXPIRATION_MS);const doesIdentityRequireRefresh=identity=>identity.expiration!==undefined;const memoizeIdentityProvider=(provider,isExpired,requiresRefresh)=>{if(provider===undefined){return undefined}const normalizedProvider=typeof provider!=="function"?async()=>Promise.resolve(provider):provider;let resolved;let pending;let hasResult;let isConstant=false;const coalesceProvider=async options=>{if(!pending){pending=normalizedProvider(options);}try{resolved=await pending;hasResult=true;isConstant=false;}finally{pending=undefined;}return resolved};if(isExpired===undefined){return async options=>{if(!hasResult||options!==null&&options!==void 0&&options.forceRefresh){resolved=await coalesceProvider(options);}return resolved}}return async options=>{if(!hasResult||options!==null&&options!==void 0&&options.forceRefresh){resolved=await coalesceProvider(options);}if(isConstant){return resolved}if(!requiresRefresh(resolved)){isConstant=true;return resolved}if(isExpired(resolved)){await coalesceProvider(options);return resolved}return resolved}};const normalizeProvider=input=>{if(typeof input==="function")return input;const promisified=Promise.resolve(input);return ()=>promisified};const CONTENT_LENGTH_HEADER="content-length";function contentLengthMiddleware(bodyLengthChecker){return next=>async args=>{const request=args.request;if(HttpRequest.isInstance(request)){const{body,headers}=request;if(body&&Object.keys(headers).map(str=>str.toLowerCase()).indexOf(CONTENT_LENGTH_HEADER)===-1){try{const length=bodyLengthChecker(body);request.headers={...request.headers,[CONTENT_LENGTH_HEADER]:String(length)};}catch(error){}}}return next({...args,request})}}const contentLengthMiddlewareOptions={step:"build",tags:["SET_CONTENT_LENGTH","CONTENT_LENGTH"],name:"contentLengthMiddleware",override:true};const getContentLengthPlugin=options=>({applyToStack:clientStack=>{clientStack.add(contentLengthMiddleware(options.bodyLengthChecker),contentLengthMiddlewareOptions);}});const getDateHeader=response=>{var _response$headers$dat,_response$headers,_response$headers2;return HttpResponse.isInstance(response)?(_response$headers$dat=(_response$headers=response.headers)===null||_response$headers===void 0?void 0:_response$headers.date)!==null&&_response$headers$dat!==void 0?_response$headers$dat:(_response$headers2=response.headers)===null||_response$headers2===void 0?void 0:_response$headers2.Date:undefined};const getSkewCorrectedDate=systemClockOffset=>new Date(Date.now()+systemClockOffset);const isClockSkewed=(clockTime,systemClockOffset)=>Math.abs(getSkewCorrectedDate(systemClockOffset).getTime()-clockTime)>=300000;const getUpdatedSystemClockOffset=(clockTime,currentSystemClockOffset)=>{const clockTimeInMs=Date.parse(clockTime);if(isClockSkewed(clockTimeInMs,currentSystemClockOffset)){return clockTimeInMs-Date.now()}return currentSystemClockOffset};const throwSigningPropertyError=(name,property)=>{if(!property){throw new Error("Property `".concat(name,"` is not resolved for AWS SDK SigV4Auth"))}return property};const validateSigningProperties=async signingProperties=>{var _context$endpointV2;const context=throwSigningPropertyError("context",signingProperties.context);const config=throwSigningPropertyError("config",signingProperties.config);const authScheme=(_context$endpointV2=context.endpointV2)===null||_context$endpointV2===void 0||(_context$endpointV2=_context$endpointV2.properties)===null||_context$endpointV2===void 0||(_context$endpointV2=_context$endpointV2.authSchemes)===null||_context$endpointV2===void 0?void 0:_context$endpointV2[0];const signerFunction=throwSigningPropertyError("signer",config.signer);const signer=await signerFunction(authScheme);const signingRegion=signingProperties===null||signingProperties===void 0?void 0:signingProperties.signingRegion;const signingName=signingProperties===null||signingProperties===void 0?void 0:signingProperties.signingName;return {config,signer,signingRegion,signingName}};class AwsSdkSigV4Signer{async sign(httpRequest,identity,signingProperties){if(!HttpRequest.isInstance(httpRequest)){throw new Error("The request is not an instance of `HttpRequest` and cannot be signed")}const{config,signer,signingRegion,signingName}=await validateSigningProperties(signingProperties);const signedRequest=await signer.sign(httpRequest,{signingDate:getSkewCorrectedDate(config.systemClockOffset),signingRegion:signingRegion,signingService:signingName});return signedRequest}errorHandler(signingProperties){return error=>{var _error$ServerTime;const serverTime=(_error$ServerTime=error.ServerTime)!==null&&_error$ServerTime!==void 0?_error$ServerTime:getDateHeader(error.$response);if(serverTime){const config=throwSigningPropertyError("config",signingProperties.config);const initialSystemClockOffset=config.systemClockOffset;config.systemClockOffset=getUpdatedSystemClockOffset(serverTime,config.systemClockOffset);const clockSkewCorrected=config.systemClockOffset!==initialSystemClockOffset;if(clockSkewCorrected&&error.$metadata){error.$metadata.clockSkewCorrected=true;}}throw error}}successHandler(httpResponse,signingProperties){const dateHeader=getDateHeader(httpResponse);if(dateHeader){const config=throwSigningPropertyError("config",signingProperties.config);config.systemClockOffset=getUpdatedSystemClockOffset(dateHeader,config.systemClockOffset);}}}const SHORT_TO_HEX={};const HEX_TO_SHORT={};for(let i=0;i<256;i++){let encodedByte=i.toString(16).toLowerCase();if(encodedByte.length===1){encodedByte="0".concat(encodedByte);}SHORT_TO_HEX[i]=encodedByte;HEX_TO_SHORT[encodedByte]=i;}function fromHex(encoded){if(encoded.length%2!==0){throw new Error("Hex encoded strings must have an even number length")}const out=new Uint8Array(encoded.length/2);for(let i=0;i<encoded.length;i+=2){const encodedByte=encoded.slice(i,i+2).toLowerCase();if(encodedByte in HEX_TO_SHORT){out[i/2]=HEX_TO_SHORT[encodedByte];}else {throw new Error("Cannot decode unrecognized sequence ".concat(encodedByte," as hexadecimal"))}}return out}function toHex(bytes){let out="";for(let i=0;i<bytes.byteLength;i++){out+=SHORT_TO_HEX[bytes[i]];}return out}const fromUtf8$1=input=>new TextEncoder().encode(input);const toUint8Array=data=>{if(typeof data==="string"){return fromUtf8$1(data)}if(ArrayBuffer.isView(data)){return new Uint8Array(data.buffer,data.byteOffset,data.byteLength/Uint8Array.BYTES_PER_ELEMENT)}return new Uint8Array(data)};const ALGORITHM_QUERY_PARAM="X-Amz-Algorithm";const CREDENTIAL_QUERY_PARAM="X-Amz-Credential";const AMZ_DATE_QUERY_PARAM="X-Amz-Date";const SIGNED_HEADERS_QUERY_PARAM="X-Amz-SignedHeaders";const EXPIRES_QUERY_PARAM="X-Amz-Expires";const SIGNATURE_QUERY_PARAM="X-Amz-Signature";const TOKEN_QUERY_PARAM="X-Amz-Security-Token";const AUTH_HEADER="authorization";const AMZ_DATE_HEADER=AMZ_DATE_QUERY_PARAM.toLowerCase();const DATE_HEADER="date";const GENERATED_HEADERS=[AUTH_HEADER,AMZ_DATE_HEADER,DATE_HEADER];const SIGNATURE_HEADER=SIGNATURE_QUERY_PARAM.toLowerCase();const SHA256_HEADER="x-amz-content-sha256";const TOKEN_HEADER=TOKEN_QUERY_PARAM.toLowerCase();const ALWAYS_UNSIGNABLE_HEADERS={authorization:true,"cache-control":true,connection:true,expect:true,from:true,"keep-alive":true,"max-forwards":true,pragma:true,referer:true,te:true,trailer:true,"transfer-encoding":true,upgrade:true,"user-agent":true,"x-amzn-trace-id":true};const PROXY_HEADER_PATTERN=/^proxy-/;const SEC_HEADER_PATTERN=/^sec-/;const ALGORITHM_IDENTIFIER="AWS4-HMAC-SHA256";const EVENT_ALGORITHM_IDENTIFIER="AWS4-HMAC-SHA256-PAYLOAD";const UNSIGNED_PAYLOAD="UNSIGNED-PAYLOAD";const MAX_CACHE_SIZE=50;const KEY_TYPE_IDENTIFIER="aws4_request";const MAX_PRESIGNED_TTL=60*60*24*7;const signingKeyCache={};const cacheQueue=[];const createScope=(shortDate,region,service)=>"".concat(shortDate,"/").concat(region,"/").concat(service,"/").concat(KEY_TYPE_IDENTIFIER);const getSigningKey=async(sha256Constructor,credentials,shortDate,region,service)=>{const credsHash=await hmac(sha256Constructor,credentials.secretAccessKey,credentials.accessKeyId);const cacheKey="".concat(shortDate,":").concat(region,":").concat(service,":").concat(toHex(credsHash),":").concat(credentials.sessionToken);if(cacheKey in signingKeyCache){return signingKeyCache[cacheKey]}cacheQueue.push(cacheKey);while(cacheQueue.length>MAX_CACHE_SIZE){delete signingKeyCache[cacheQueue.shift()];}let key="AWS4".concat(credentials.secretAccessKey);for(const signable of [shortDate,region,service,KEY_TYPE_IDENTIFIER]){key=await hmac(sha256Constructor,key,signable);}return signingKeyCache[cacheKey]=key};const hmac=(ctor,secret,data)=>{const hash=new ctor(secret);hash.update(toUint8Array(data));return hash.digest()};const getCanonicalHeaders=(_ref33,unsignableHeaders,signableHeaders)=>{let{headers}=_ref33;const canonical={};for(const headerName of Object.keys(headers).sort()){if(headers[headerName]==undefined){continue}const canonicalHeaderName=headerName.toLowerCase();if(canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS||unsignableHeaders!==null&&unsignableHeaders!==void 0&&unsignableHeaders.has(canonicalHeaderName)||PROXY_HEADER_PATTERN.test(canonicalHeaderName)||SEC_HEADER_PATTERN.test(canonicalHeaderName)){if(!signableHeaders||signableHeaders&&!signableHeaders.has(canonicalHeaderName)){continue}}canonical[canonicalHeaderName]=headers[headerName].trim().replace(/\s+/g," ");}return canonical};const getCanonicalQuery=_ref34=>{let{query={}}=_ref34;const keys=[];const serialized={};for(const key of Object.keys(query).sort()){if(key.toLowerCase()===SIGNATURE_HEADER){continue}keys.push(key);const value=query[key];if(typeof value==="string"){serialized[key]="".concat(escapeUri$1(key),"=").concat(escapeUri$1(value));}else if(Array.isArray(value)){serialized[key]=value.slice(0).reduce((encoded,value)=>encoded.concat(["".concat(escapeUri$1(key),"=").concat(escapeUri$1(value))]),[]).sort().join("&");}}return keys.map(key=>serialized[key]).filter(serialized=>serialized).join("&")};const isArrayBuffer=arg=>typeof ArrayBuffer==="function"&&arg instanceof ArrayBuffer||Object.prototype.toString.call(arg)==="[object ArrayBuffer]";const getPayloadHash=async(_ref35,hashConstructor)=>{let{headers,body}=_ref35;for(const headerName of Object.keys(headers)){if(headerName.toLowerCase()===SHA256_HEADER){return headers[headerName]}}if(body==undefined){return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"}else if(typeof body==="string"||ArrayBuffer.isView(body)||isArrayBuffer(body)){const hashCtor=new hashConstructor;hashCtor.update(toUint8Array(body));return toHex(await hashCtor.digest())}return UNSIGNED_PAYLOAD};class HeaderFormatter{format(headers){const chunks=[];for(const headerName of Object.keys(headers)){const bytes=fromUtf8$1(headerName);chunks.push(Uint8Array.from([bytes.byteLength]),bytes,this.formatHeaderValue(headers[headerName]));}const out=new Uint8Array(chunks.reduce((carry,bytes)=>carry+bytes.byteLength,0));let position=0;for(const chunk of chunks){out.set(chunk,position);position+=chunk.byteLength;}return out}formatHeaderValue(header){switch(header.type){case"boolean":return Uint8Array.from([header.value?0:1]);case"byte":return Uint8Array.from([2,header.value]);case"short":const shortView=new DataView(new ArrayBuffer(3));shortView.setUint8(0,3);shortView.setInt16(1,header.value,false);return new Uint8Array(shortView.buffer);case"integer":const intView=new DataView(new ArrayBuffer(5));intView.setUint8(0,4);intView.setInt32(1,header.value,false);return new Uint8Array(intView.buffer);case"long":const longBytes=new Uint8Array(9);longBytes[0]=5;longBytes.set(header.value.bytes,1);return longBytes;case"binary":const binView=new DataView(new ArrayBuffer(3+header.value.byteLength));binView.setUint8(0,6);binView.setUint16(1,header.value.byteLength,false);const binBytes=new Uint8Array(binView.buffer);binBytes.set(header.value,3);return binBytes;case"string":const utf8Bytes=fromUtf8$1(header.value);const strView=new DataView(new ArrayBuffer(3+utf8Bytes.byteLength));strView.setUint8(0,7);strView.setUint16(1,utf8Bytes.byteLength,false);const strBytes=new Uint8Array(strView.buffer);strBytes.set(utf8Bytes,3);return strBytes;case"timestamp":const tsBytes=new Uint8Array(9);tsBytes[0]=8;tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes,1);return tsBytes;case"uuid":if(!UUID_PATTERN.test(header.value)){throw new Error("Invalid UUID received: ".concat(header.value))}const uuidBytes=new Uint8Array(17);uuidBytes[0]=9;uuidBytes.set(fromHex(header.value.replace(/\-/g,"")),1);return uuidBytes}}}var HEADER_VALUE_TYPE;(function(HEADER_VALUE_TYPE){HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["boolTrue"]=0]="boolTrue";HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["boolFalse"]=1]="boolFalse";HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["byte"]=2]="byte";HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["short"]=3]="short";HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["integer"]=4]="integer";HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["long"]=5]="long";HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["byteArray"]=6]="byteArray";HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["string"]=7]="string";HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["timestamp"]=8]="timestamp";HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["uuid"]=9]="uuid";})(HEADER_VALUE_TYPE||(HEADER_VALUE_TYPE={}));const UUID_PATTERN=/^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;class Int64{constructor(bytes){this.bytes=bytes;if(bytes.byteLength!==8){throw new Error("Int64 buffers must be exactly 8 bytes")}}static fromNumber(number){if(number>9223372036854776000||number<-9223372036854776000){throw new Error("".concat(number," is too large (or, if negative, too small) to represent as an Int64"))}const bytes=new Uint8Array(8);for(let i=7,remaining=Math.abs(Math.round(number));i>-1&&remaining>0;i--,remaining/=256){bytes[i]=remaining;}if(number<0){negate(bytes);}return new Int64(bytes)}valueOf(){const bytes=this.bytes.slice(0);const negative=bytes[0]&128;if(negative){negate(bytes);}return parseInt(toHex(bytes),16)*(negative?-1:1)}toString(){return String(this.valueOf())}}function negate(bytes){for(let i=0;i<8;i++){bytes[i]^=255;}for(let i=7;i>-1;i--){bytes[i]++;if(bytes[i]!==0)break}}const hasHeader=(soughtHeader,headers)=>{soughtHeader=soughtHeader.toLowerCase();for(const headerName of Object.keys(headers)){if(soughtHeader===headerName.toLowerCase()){return true}}return false};const moveHeadersToQuery=function(request){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const{headers,query={}}=HttpRequest.clone(request);for(const name of Object.keys(headers)){var _options$unhoistableH;const lname=name.toLowerCase();if(lname.slice(0,6)==="x-amz-"&&!((_options$unhoistableH=options.unhoistableHeaders)!==null&&_options$unhoistableH!==void 0&&_options$unhoistableH.has(lname))){query[name]=headers[name];delete headers[name];}}return {...request,headers,query}};const prepareRequest=request=>{request=HttpRequest.clone(request);for(const headerName of Object.keys(request.headers)){if(GENERATED_HEADERS.indexOf(headerName.toLowerCase())>-1){delete request.headers[headerName];}}return request};const iso8601=time=>toDate(time).toISOString().replace(/\.\d{3}Z$/,"Z");const toDate=time=>{if(typeof time==="number"){return new Date(time*1000)}if(typeof time==="string"){if(Number(time)){return new Date(Number(time)*1000)}return new Date(time)}return time};class SignatureV4{constructor(_ref36){let{applyChecksum,credentials,region,service,sha256,uriEscapePath=true}=_ref36;this.headerFormatter=new HeaderFormatter;this.service=service;this.sha256=sha256;this.uriEscapePath=uriEscapePath;this.applyChecksum=typeof applyChecksum==="boolean"?applyChecksum:true;this.regionProvider=normalizeProvider$1(region);this.credentialProvider=normalizeProvider$1(credentials);}async presign(originalRequest){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const{signingDate=new Date,expiresIn=3600,unsignableHeaders,unhoistableHeaders,signableHeaders,signingRegion,signingService}=options;const credentials=await this.credentialProvider();this.validateResolvedCredentials(credentials);const region=signingRegion!==null&&signingRegion!==void 0?signingRegion:await this.regionProvider();const{longDate,shortDate}=formatDate(signingDate);if(expiresIn>MAX_PRESIGNED_TTL){return Promise.reject("Signature version 4 presigned URLs"+" must have an expiration date less than one week in"+" the future")}const scope=createScope(shortDate,region,signingService!==null&&signingService!==void 0?signingService:this.service);const request=moveHeadersToQuery(prepareRequest(originalRequest),{unhoistableHeaders});if(credentials.sessionToken){request.query[TOKEN_QUERY_PARAM]=credentials.sessionToken;}request.query[ALGORITHM_QUERY_PARAM]=ALGORITHM_IDENTIFIER;request.query[CREDENTIAL_QUERY_PARAM]="".concat(credentials.accessKeyId,"/").concat(scope);request.query[AMZ_DATE_QUERY_PARAM]=longDate;request.query[EXPIRES_QUERY_PARAM]=expiresIn.toString(10);const canonicalHeaders=getCanonicalHeaders(request,unsignableHeaders,signableHeaders);request.query[SIGNED_HEADERS_QUERY_PARAM]=getCanonicalHeaderList(canonicalHeaders);request.query[SIGNATURE_QUERY_PARAM]=await this.getSignature(longDate,scope,this.getSigningKey(credentials,region,shortDate,signingService),this.createCanonicalRequest(request,canonicalHeaders,await getPayloadHash(originalRequest,this.sha256)));return request}async sign(toSign,options){if(typeof toSign==="string"){return this.signString(toSign,options)}else if(toSign.headers&&toSign.payload){return this.signEvent(toSign,options)}else if(toSign.message){return this.signMessage(toSign,options)}else {return this.signRequest(toSign,options)}}async signEvent(_ref37,_ref38){let{headers,payload}=_ref37;let{signingDate=new Date,priorSignature,signingRegion,signingService}=_ref38;const region=signingRegion!==null&&signingRegion!==void 0?signingRegion:await this.regionProvider();const{shortDate,longDate}=formatDate(signingDate);const scope=createScope(shortDate,region,signingService!==null&&signingService!==void 0?signingService:this.service);const hashedPayload=await getPayloadHash({headers:{},body:payload},this.sha256);const hash=new this.sha256;hash.update(headers);const hashedHeaders=toHex(await hash.digest());const stringToSign=[EVENT_ALGORITHM_IDENTIFIER,longDate,scope,priorSignature,hashedHeaders,hashedPayload].join("\n");return this.signString(stringToSign,{signingDate,signingRegion:region,signingService})}async signMessage(signableMessage,_ref39){let{signingDate=new Date,signingRegion,signingService}=_ref39;const promise=this.signEvent({headers:this.headerFormatter.format(signableMessage.message.headers),payload:signableMessage.message.body},{signingDate,signingRegion,signingService,priorSignature:signableMessage.priorSignature});return promise.then(signature=>{return {message:signableMessage.message,signature}})}async signString(stringToSign){let{signingDate=new Date,signingRegion,signingService}=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const credentials=await this.credentialProvider();this.validateResolvedCredentials(credentials);const region=signingRegion!==null&&signingRegion!==void 0?signingRegion:await this.regionProvider();const{shortDate}=formatDate(signingDate);const hash=new this.sha256(await this.getSigningKey(credentials,region,shortDate,signingService));hash.update(toUint8Array(stringToSign));return toHex(await hash.digest())}async signRequest(requestToSign){let{signingDate=new Date,signableHeaders,unsignableHeaders,signingRegion,signingService}=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const credentials=await this.credentialProvider();this.validateResolvedCredentials(credentials);const region=signingRegion!==null&&signingRegion!==void 0?signingRegion:await this.regionProvider();const request=prepareRequest(requestToSign);const{longDate,shortDate}=formatDate(signingDate);const scope=createScope(shortDate,region,signingService!==null&&signingService!==void 0?signingService:this.service);request.headers[AMZ_DATE_HEADER]=longDate;if(credentials.sessionToken){request.headers[TOKEN_HEADER]=credentials.sessionToken;}const payloadHash=await getPayloadHash(request,this.sha256);if(!hasHeader(SHA256_HEADER,request.headers)&&this.applyChecksum){request.headers[SHA256_HEADER]=payloadHash;}const canonicalHeaders=getCanonicalHeaders(request,unsignableHeaders,signableHeaders);const signature=await this.getSignature(longDate,scope,this.getSigningKey(credentials,region,shortDate,signingService),this.createCanonicalRequest(request,canonicalHeaders,payloadHash));request.headers[AUTH_HEADER]="".concat(ALGORITHM_IDENTIFIER," ")+"Credential=".concat(credentials.accessKeyId,"/").concat(scope,", ")+"SignedHeaders=".concat(getCanonicalHeaderList(canonicalHeaders),", ")+"Signature=".concat(signature);return request}createCanonicalRequest(request,canonicalHeaders,payloadHash){const sortedHeaders=Object.keys(canonicalHeaders).sort();return "".concat(request.method,"\n").concat(this.getCanonicalPath(request),"\n").concat(getCanonicalQuery(request),"\n").concat(sortedHeaders.map(name=>"".concat(name,":").concat(canonicalHeaders[name])).join("\n"),"\n\n").concat(sortedHeaders.join(";"),"\n").concat(payloadHash)}async createStringToSign(longDate,credentialScope,canonicalRequest){const hash=new this.sha256;hash.update(toUint8Array(canonicalRequest));const hashedRequest=await hash.digest();return "".concat(ALGORITHM_IDENTIFIER,"\n").concat(longDate,"\n").concat(credentialScope,"\n").concat(toHex(hashedRequest))}getCanonicalPath(_ref40){let{path}=_ref40;if(this.uriEscapePath){const normalizedPathSegments=[];for(const pathSegment of path.split("/")){if((pathSegment===null||pathSegment===void 0?void 0:pathSegment.length)===0)continue;if(pathSegment===".")continue;if(pathSegment===".."){normalizedPathSegments.pop();}else {normalizedPathSegments.push(pathSegment);}}const normalizedPath="".concat(path!==null&&path!==void 0&&path.startsWith("/")?"/":"").concat(normalizedPathSegments.join("/")).concat(normalizedPathSegments.length>0&&path!==null&&path!==void 0&&path.endsWith("/")?"/":"");const doubleEncoded=escapeUri$1(normalizedPath);return doubleEncoded.replace(/%2F/g,"/")}return path}async getSignature(longDate,credentialScope,keyPromise,canonicalRequest){const stringToSign=await this.createStringToSign(longDate,credentialScope,canonicalRequest);const hash=new this.sha256(await keyPromise);hash.update(toUint8Array(stringToSign));return toHex(await hash.digest())}getSigningKey(credentials,region,shortDate,service){return getSigningKey(this.sha256,credentials,shortDate,region,service||this.service)}validateResolvedCredentials(credentials){if(typeof credentials!=="object"||typeof credentials.accessKeyId!=="string"||typeof credentials.secretAccessKey!=="string"){throw new Error("Resolved credential object is not valid")}}}const formatDate=now=>{const longDate=iso8601(now).replace(/[\-:]/g,"");return {longDate,shortDate:longDate.slice(0,8)}};const getCanonicalHeaderList=headers=>Object.keys(headers).sort().join(";");const resolveAwsSdkSigV4Config=config=>{let normalizedCreds;if(config.credentials){normalizedCreds=memoizeIdentityProvider(config.credentials,isIdentityExpired,doesIdentityRequireRefresh);}if(!normalizedCreds){if(config.credentialDefaultProvider){normalizedCreds=normalizeProvider(config.credentialDefaultProvider(Object.assign({},config,{parentClientConfig:config})));}else {normalizedCreds=async()=>{throw new Error("`credentials` is missing")};}}const{signingEscapePath=true,systemClockOffset=config.systemClockOffset||0,sha256}=config;let signer;if(config.signer){signer=normalizeProvider(config.signer);}else if(config.regionInfoProvider){signer=()=>normalizeProvider(config.region)().then(async region=>[(await config.regionInfoProvider(region,{useFipsEndpoint:await config.useFipsEndpoint(),useDualstackEndpoint:await config.useDualstackEndpoint()}))||{},region]).then(_ref41=>{let[regionInfo,region]=_ref41;const{signingRegion,signingService}=regionInfo;config.signingRegion=config.signingRegion||signingRegion||region;config.signingName=config.signingName||signingService||config.serviceId;const params={...config,credentials:normalizedCreds,region:config.signingRegion,service:config.signingName,sha256,uriEscapePath:signingEscapePath};const SignerCtor=config.signerConstructor||SignatureV4;return new SignerCtor(params)});}else {signer=async authScheme=>{authScheme=Object.assign({},{name:"sigv4",signingName:config.signingName||config.defaultSigningName,signingRegion:await normalizeProvider(config.region)(),properties:{}},authScheme);const signingRegion=authScheme.signingRegion;const signingService=authScheme.signingName;config.signingRegion=config.signingRegion||signingRegion;config.signingName=config.signingName||signingService||config.serviceId;const params={...config,credentials:normalizedCreds,region:config.signingRegion,service:config.signingName,sha256,uriEscapePath:signingEscapePath};const SignerCtor=config.signerConstructor||SignatureV4;return new SignerCtor(params)};}return {...config,systemClockOffset,signingEscapePath,credentials:normalizedCreds,signer}};const collectBodyString=(streamBody,context)=>collectBody(streamBody,context).then(body=>context.utf8Encoder(body));const parseJsonBody=(streamBody,context)=>collectBodyString(streamBody,context).then(encoded=>{if(encoded.length){try{return JSON.parse(encoded)}catch(e){if((e===null||e===void 0?void 0:e.name)==="SyntaxError"){Object.defineProperty(e,"$responseBodyText",{value:encoded});}throw e}}return {}});const parseJsonErrorBody=async(errorBody,context)=>{var _value$message;const value=await parseJsonBody(errorBody,context);value.message=(_value$message=value.message)!==null&&_value$message!==void 0?_value$message:value.Message;return value};const loadRestJsonErrorCode=(output,data)=>{const findKey=(object,key)=>Object.keys(object).find(k=>k.toLowerCase()===key.toLowerCase());const sanitizeErrorCode=rawValue=>{let cleanValue=rawValue;if(typeof cleanValue==="number"){cleanValue=cleanValue.toString();}if(cleanValue.indexOf(",")>=0){cleanValue=cleanValue.split(",")[0];}if(cleanValue.indexOf(":")>=0){cleanValue=cleanValue.split(":")[0];}if(cleanValue.indexOf("#")>=0){cleanValue=cleanValue.split("#")[1];}return cleanValue};const headerKey=findKey(output.headers,"x-amzn-errortype");if(headerKey!==undefined){return sanitizeErrorCode(output.headers[headerKey])}if(data.code!==undefined){return sanitizeErrorCode(data.code)}if(data["__type"]!==undefined){return sanitizeErrorCode(data["__type"])}};var commonjsGlobal$1=typeof globalThis!=="undefined"?globalThis:typeof window!=="undefined"?window:typeof commonjsGlobal!=="undefined"?commonjsGlobal:typeof self!=="undefined"?self:{};function getDefaultExportFromCjs(x){return x&&x.__esModule&&Object.prototype.hasOwnProperty.call(x,"default")?x["default"]:x}const defaultCognitoIdentityHttpAuthSchemeParametersProvider=async(config,context,input)=>{return {operation:getSmithyContext(context).operation,region:(await normalizeProvider$1(config.region)())||(()=>{throw new Error("expected `region` to be configured for `aws.auth#sigv4`")})()}};function createAwsAuthSigv4HttpAuthOption(authParameters){return {schemeId:"aws.auth#sigv4",signingProperties:{name:"cognito-identity",region:authParameters.region},propertiesExtractor:(config,context)=>({signingProperties:{config,context}})}}function createSmithyApiNoAuthHttpAuthOption(authParameters){return {schemeId:"smithy.api#noAuth"}}const defaultCognitoIdentityHttpAuthSchemeProvider=authParameters=>{const options=[];switch(authParameters.operation){case"GetCredentialsForIdentity":{options.push(createSmithyApiNoAuthHttpAuthOption());break}case"GetId":{options.push(createSmithyApiNoAuthHttpAuthOption());break}case"GetOpenIdToken":{options.push(createSmithyApiNoAuthHttpAuthOption());break}case"UnlinkIdentity":{options.push(createSmithyApiNoAuthHttpAuthOption());break}default:{options.push(createAwsAuthSigv4HttpAuthOption(authParameters));}}return options};const resolveHttpAuthSchemeConfig=config=>{const config_0=resolveAwsSdkSigV4Config(config);return {...config_0}};const resolveClientEndpointParameters=options=>{var _options$useDualstack,_options$useFipsEndpo;return {...options,useDualstackEndpoint:(_options$useDualstack=options.useDualstackEndpoint)!==null&&_options$useDualstack!==void 0?_options$useDualstack:false,useFipsEndpoint:(_options$useFipsEndpo=options.useFipsEndpoint)!==null&&_options$useFipsEndpo!==void 0?_options$useFipsEndpo:false,defaultSigningName:"cognito-identity"}};const commonParams={UseFIPS:{type:"builtInParams",name:"useFipsEndpoint"},Endpoint:{type:"builtInParams",name:"endpoint"},Region:{type:"builtInParams",name:"region"},UseDualStack:{type:"builtInParams",name:"useDualstackEndpoint"}};var name="@aws-sdk/client-cognito-identity";var description="AWS SDK for JavaScript Cognito Identity Client for Node.js, Browser and React Native";var version="3.621.0";var scripts={build:"concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'","build:cjs":"node ../../scripts/compilation/inline client-cognito-identity","build:es":"tsc -p tsconfig.es.json","build:include:deps":"lerna run --scope $npm_package_name --include-dependencies build","build:types":"tsc -p tsconfig.types.json","build:types:downlevel":"downlevel-dts dist-types dist-types/ts3.4",clean:"rimraf ./dist-* && rimraf *.tsbuildinfo","extract:docs":"api-extractor run --local","generate:client":"node ../../scripts/generate-clients/single-service --solo cognito-identity","test:e2e":"ts-mocha test/**/*.ispec.ts && karma start karma.conf.js"};var main="./dist-cjs/index.js";var types="./dist-types/index.d.ts";var module="./dist-es/index.js";var sideEffects=false;var dependencies={"@aws-crypto/sha256-browser":"5.2.0","@aws-crypto/sha256-js":"5.2.0","@aws-sdk/client-sso-oidc":"3.621.0","@aws-sdk/client-sts":"3.621.0","@aws-sdk/core":"3.621.0","@aws-sdk/credential-provider-node":"3.621.0","@aws-sdk/middleware-host-header":"3.620.0","@aws-sdk/middleware-logger":"3.609.0","@aws-sdk/middleware-recursion-detection":"3.620.0","@aws-sdk/middleware-user-agent":"3.620.0","@aws-sdk/region-config-resolver":"3.614.0","@aws-sdk/types":"3.609.0","@aws-sdk/util-endpoints":"3.614.0","@aws-sdk/util-user-agent-browser":"3.609.0","@aws-sdk/util-user-agent-node":"3.614.0","@smithy/config-resolver":"^3.0.5","@smithy/core":"^2.3.1","@smithy/fetch-http-handler":"^3.2.4","@smithy/hash-node":"^3.0.3","@smithy/invalid-dependency":"^3.0.3","@smithy/middleware-content-length":"^3.0.5","@smithy/middleware-endpoint":"^3.1.0","@smithy/middleware-retry":"^3.0.13","@smithy/middleware-serde":"^3.0.3","@smithy/middleware-stack":"^3.0.3","@smithy/node-config-provider":"^3.1.4","@smithy/node-http-handler":"^3.1.4","@smithy/protocol-http":"^4.1.0","@smithy/smithy-client":"^3.1.11","@smithy/types":"^3.3.0","@smithy/url-parser":"^3.0.3","@smithy/util-base64":"^3.0.0","@smithy/util-body-length-browser":"^3.0.0","@smithy/util-body-length-node":"^3.0.0","@smithy/util-defaults-mode-browser":"^3.0.13","@smithy/util-defaults-mode-node":"^3.0.13","@smithy/util-endpoints":"^2.0.5","@smithy/util-middleware":"^3.0.3","@smithy/util-retry":"^3.0.3","@smithy/util-utf8":"^3.0.0",tslib:"^2.6.2"};var devDependencies={"@aws-sdk/client-iam":"3.621.0","@tsconfig/node16":"16.1.3","@types/chai":"^4.2.11","@types/mocha":"^8.0.4","@types/node":"^16.18.96",concurrently:"7.0.0","downlevel-dts":"0.10.1",rimraf:"3.0.2",typescript:"~4.9.5"};var engines={node:">=16.0.0"};var typesVersions={"<4.0":{"dist-types/*":["dist-types/ts3.4/*"]}};var files=["dist-*/**"];var author={name:"AWS SDK for JavaScript Team",url:"https://aws.amazon.com/javascript/"};var license="Apache-2.0";var browser={"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.browser"};var homepage="https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-cognito-identity";var repository={type:"git",url:"https://github.com/aws/aws-sdk-js-v3.git",directory:"clients/client-cognito-identity"};var packageInfo={name:name,description:description,version:version,scripts:scripts,main:main,types:types,module:module,sideEffects:sideEffects,dependencies:dependencies,devDependencies:devDependencies,engines:engines,typesVersions:typesVersions,files:files,author:author,license:license,browser:browser,"react-native":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.native"},homepage:homepage,repository:repository};var SHA_256_HASH={name:"SHA-256"};var SHA_256_HMAC_ALGO={name:"HMAC",hash:SHA_256_HASH};var EMPTY_DATA_SHA_256=new Uint8Array([227,176,196,66,152,252,28,20,154,251,244,200,153,111,185,36,39,174,65,228,100,155,147,76,164,149,153,27,120,82,184,85]);const fallbackWindow={};function locateWindow(){if(typeof window!=="undefined"){return window}else if(typeof self!=="undefined"){return self}return fallbackWindow}var Sha256$1=/** @class */function(){function Sha256(secret){this.toHash=new Uint8Array(0);this.secret=secret;this.reset();}Sha256.prototype.update=function(data){if(isEmptyData(data)){return}var update=convertToBuffer(data);var typedArray=new Uint8Array(this.toHash.byteLength+update.byteLength);typedArray.set(this.toHash,0);typedArray.set(update,this.toHash.byteLength);this.toHash=typedArray;};Sha256.prototype.digest=function(){var _this=this;if(this.key){return this.key.then(function(key){return locateWindow().crypto.subtle.sign(SHA_256_HMAC_ALGO,key,_this.toHash).then(function(data){return new Uint8Array(data)})})}if(isEmptyData(this.toHash)){return Promise.resolve(EMPTY_DATA_SHA_256)}return Promise.resolve().then(function(){return locateWindow().crypto.subtle.digest(SHA_256_HASH,_this.toHash)}).then(function(data){return Promise.resolve(new Uint8Array(data))})};Sha256.prototype.reset=function(){var _this=this;this.toHash=new Uint8Array(0);if(this.secret&&this.secret!==void 0){this.key=new Promise(function(resolve,reject){locateWindow().crypto.subtle.importKey("raw",convertToBuffer(_this.secret),SHA_256_HMAC_ALGO,false,["sign"]).then(resolve,reject);});this.key.catch(function(){});}};return Sha256}();var subtleCryptoMethods=["decrypt","digest","encrypt","exportKey","generateKey","importKey","sign","verify"];function supportsWebCrypto(window){if(supportsSecureRandom(window)&&typeof window.crypto.subtle==="object"){var subtle=window.crypto.subtle;return supportsSubtleCrypto(subtle)}return false}function supportsSecureRandom(window){if(typeof window==="object"&&typeof window.crypto==="object"){var getRandomValues=window.crypto.getRandomValues;return typeof getRandomValues==="function"}return false}function supportsSubtleCrypto(subtle){return subtle&&subtleCryptoMethods.every(function(methodName){return typeof subtle[methodName]==="function"})}var Sha256=/** @class */function(){function Sha256(secret){if(supportsWebCrypto(locateWindow())){this.hash=new Sha256$1(secret);}else {this.hash=new Sha256$2(secret);}}Sha256.prototype.update=function(data,encoding){this.hash.update(convertToBuffer(data));};Sha256.prototype.digest=function(){return this.hash.digest()};Sha256.prototype.reset=function(){this.hash.reset();};return Sha256}();var es5={exports:{}};(function(module,exports){!function(e,t){module.exports=t();}(commonjsGlobal$1,function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n});},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0});},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=90)}({17:function(e,t,r){t.__esModule=!0,t.default=void 0;var n=r(18),i=function(){function e(){}return e.getFirstMatch=function(e,t){var r=t.match(e);return r&&r.length>0&&r[1]||""},e.getSecondMatch=function(e,t){var r=t.match(e);return r&&r.length>1&&r[2]||""},e.matchAndReturnConst=function(e,t,r){if(e.test(t))return r},e.getWindowsVersionName=function(e){switch(e){case"NT":return "NT";case"XP":return "XP";case"NT 5.0":return "2000";case"NT 5.1":return "XP";case"NT 5.2":return "2003";case"NT 6.0":return "Vista";case"NT 6.1":return "7";case"NT 6.2":return "8";case"NT 6.3":return "8.1";case"NT 10.0":return "10";default:return}},e.getMacOSVersionName=function(e){var t=e.split(".").splice(0,2).map(function(e){return parseInt(e,10)||0});if(t.push(0),10===t[0])switch(t[1]){case 5:return "Leopard";case 6:return "Snow Leopard";case 7:return "Lion";case 8:return "Mountain Lion";case 9:return "Mavericks";case 10:return "Yosemite";case 11:return "El Capitan";case 12:return "Sierra";case 13:return "High Sierra";case 14:return "Mojave";case 15:return "Catalina";default:return}},e.getAndroidVersionName=function(e){var t=e.split(".").splice(0,2).map(function(e){return parseInt(e,10)||0});if(t.push(0),!(1===t[0]&&t[1]<5))return 1===t[0]&&t[1]<6?"Cupcake":1===t[0]&&t[1]>=6?"Donut":2===t[0]&&t[1]<2?"Eclair":2===t[0]&&2===t[1]?"Froyo":2===t[0]&&t[1]>2?"Gingerbread":3===t[0]?"Honeycomb":4===t[0]&&t[1]<1?"Ice Cream Sandwich":4===t[0]&&t[1]<4?"Jelly Bean":4===t[0]&&t[1]>=4?"KitKat":5===t[0]?"Lollipop":6===t[0]?"Marshmallow":7===t[0]?"Nougat":8===t[0]?"Oreo":9===t[0]?"Pie":void 0},e.getVersionPrecision=function(e){return e.split(".").length},e.compareVersions=function(t,r,n){void 0===n&&(n=!1);var i=e.getVersionPrecision(t),s=e.getVersionPrecision(r),a=Math.max(i,s),o=0,u=e.map([t,r],function(t){var r=a-e.getVersionPrecision(t),n=t+new Array(r+1).join(".0");return e.map(n.split("."),function(e){return new Array(20-e.length).join("0")+e}).reverse()});for(n&&(o=a-Math.min(i,s)),a-=1;a>=o;){if(u[0][a]>u[1][a])return 1;if(u[0][a]===u[1][a]){if(a===o)return 0;a-=1;}else if(u[0][a]<u[1][a])return -1}},e.map=function(e,t){var r,n=[];if(Array.prototype.map)return Array.prototype.map.call(e,t);for(r=0;r<e.length;r+=1)n.push(t(e[r]));return n},e.find=function(e,t){var r,n;if(Array.prototype.find)return Array.prototype.find.call(e,t);for(r=0,n=e.length;r<n;r+=1){var i=e[r];if(t(i,r))return i}},e.assign=function(e){for(var t,r,n=e,i=arguments.length,s=new Array(i>1?i-1:0),a=1;a<i;a++)s[a-1]=arguments[a];if(Object.assign)return Object.assign.apply(Object,[e].concat(s));var o=function(){var e=s[t];"object"==typeof e&&null!==e&&Object.keys(e).forEach(function(t){n[t]=e[t];});};for(t=0,r=s.length;t<r;t+=1)o();return e},e.getBrowserAlias=function(e){return n.BROWSER_ALIASES_MAP[e]},e.getBrowserTypeByAlias=function(e){return n.BROWSER_MAP[e]||""},e}();t.default=i,e.exports=t.default;},18:function(e,t,r){t.__esModule=!0,t.ENGINE_MAP=t.OS_MAP=t.PLATFORMS_MAP=t.BROWSER_MAP=t.BROWSER_ALIASES_MAP=void 0;t.BROWSER_ALIASES_MAP={"Amazon Silk":"amazon_silk","Android Browser":"android",Bada:"bada",BlackBerry:"blackberry",Chrome:"chrome",Chromium:"chromium",Electron:"electron",Epiphany:"epiphany",Firefox:"firefox",Focus:"focus",Generic:"generic","Google Search":"google_search",Googlebot:"googlebot","Internet Explorer":"ie","K-Meleon":"k_meleon",Maxthon:"maxthon","Microsoft Edge":"edge","MZ Browser":"mz","NAVER Whale Browser":"naver",Opera:"opera","Opera Coast":"opera_coast",PhantomJS:"phantomjs",Puffin:"puffin",QupZilla:"qupzilla",QQ:"qq",QQLite:"qqlite",Safari:"safari",Sailfish:"sailfish","Samsung Internet for Android":"samsung_internet",SeaMonkey:"seamonkey",Sleipnir:"sleipnir",Swing:"swing",Tizen:"tizen","UC Browser":"uc",Vivaldi:"vivaldi","WebOS Browser":"webos",WeChat:"wechat","Yandex Browser":"yandex",Roku:"roku"};t.BROWSER_MAP={amazon_silk:"Amazon Silk",android:"Android Browser",bada:"Bada",blackberry:"BlackBerry",chrome:"Chrome",chromium:"Chromium",electron:"Electron",epiphany:"Epiphany",firefox:"Firefox",focus:"Focus",generic:"Generic",googlebot:"Googlebot",google_search:"Google Search",ie:"Internet Explorer",k_meleon:"K-Meleon",maxthon:"Maxthon",edge:"Microsoft Edge",mz:"MZ Browser",naver:"NAVER Whale Browser",opera:"Opera",opera_coast:"Opera Coast",phantomjs:"PhantomJS",puffin:"Puffin",qupzilla:"QupZilla",qq:"QQ Browser",qqlite:"QQ Browser Lite",safari:"Safari",sailfish:"Sailfish",samsung_internet:"Samsung Internet for Android",seamonkey:"SeaMonkey",sleipnir:"Sleipnir",swing:"Swing",tizen:"Tizen",uc:"UC Browser",vivaldi:"Vivaldi",webos:"WebOS Browser",wechat:"WeChat",yandex:"Yandex Browser"};t.PLATFORMS_MAP={tablet:"tablet",mobile:"mobile",desktop:"desktop",tv:"tv"};t.OS_MAP={WindowsPhone:"Windows Phone",Windows:"Windows",MacOS:"macOS",iOS:"iOS",Android:"Android",WebOS:"WebOS",BlackBerry:"BlackBerry",Bada:"Bada",Tizen:"Tizen",Linux:"Linux",ChromeOS:"Chrome OS",PlayStation4:"PlayStation 4",Roku:"Roku"};t.ENGINE_MAP={EdgeHTML:"EdgeHTML",Blink:"Blink",Trident:"Trident",Presto:"Presto",Gecko:"Gecko",WebKit:"WebKit"};},90:function(e,t,r){t.__esModule=!0,t.default=void 0;var n,i=(n=r(91))&&n.__esModule?n:{default:n},s=r(18);function a(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n);}}var o=function(){function e(){}var t,r,n;return e.getParser=function(e,t){if(void 0===t&&(t=!1),"string"!=typeof e)throw new Error("UserAgent should be a string");return new i.default(e,t)},e.parse=function(e){return new i.default(e).getResult()},t=e,n=[{key:"BROWSER_MAP",get:function(){return s.BROWSER_MAP}},{key:"ENGINE_MAP",get:function(){return s.ENGINE_MAP}},{key:"OS_MAP",get:function(){return s.OS_MAP}},{key:"PLATFORMS_MAP",get:function(){return s.PLATFORMS_MAP}}],(r=null)&&a(t.prototype,r),n&&a(t,n),e}();t.default=o,e.exports=t.default;},91:function(e,t,r){t.__esModule=!0,t.default=void 0;var n=u(r(92)),i=u(r(93)),s=u(r(94)),a=u(r(95)),o=u(r(17));function u(e){return e&&e.__esModule?e:{default:e}}var d=function(){function e(e,t){if(void 0===t&&(t=!1),null==e||""===e)throw new Error("UserAgent parameter can't be empty");this._ua=e,this.parsedResult={},!0!==t&&this.parse();}var t=e.prototype;return t.getUA=function(){return this._ua},t.test=function(e){return e.test(this._ua)},t.parseBrowser=function(){var e=this;this.parsedResult.browser={};var t=o.default.find(n.default,function(t){if("function"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some(function(t){return e.test(t)});throw new Error("Browser's test function is not valid")});return t&&(this.parsedResult.browser=t.describe(this.getUA())),this.parsedResult.browser},t.getBrowser=function(){return this.parsedResult.browser?this.parsedResult.browser:this.parseBrowser()},t.getBrowserName=function(e){return e?String(this.getBrowser().name).toLowerCase()||"":this.getBrowser().name||""},t.getBrowserVersion=function(){return this.getBrowser().version},t.getOS=function(){return this.parsedResult.os?this.parsedResult.os:this.parseOS()},t.parseOS=function(){var e=this;this.parsedResult.os={};var t=o.default.find(i.default,function(t){if("function"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some(function(t){return e.test(t)});throw new Error("Browser's test function is not valid")});return t&&(this.parsedResult.os=t.describe(this.getUA())),this.parsedResult.os},t.getOSName=function(e){var t=this.getOS().name;return e?String(t).toLowerCase()||"":t||""},t.getOSVersion=function(){return this.getOS().version},t.getPlatform=function(){return this.parsedResult.platform?this.parsedResult.platform:this.parsePlatform()},t.getPlatformType=function(e){void 0===e&&(e=!1);var t=this.getPlatform().type;return e?String(t).toLowerCase()||"":t||""},t.parsePlatform=function(){var e=this;this.parsedResult.platform={};var t=o.default.find(s.default,function(t){if("function"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some(function(t){return e.test(t)});throw new Error("Browser's test function is not valid")});return t&&(this.parsedResult.platform=t.describe(this.getUA())),this.parsedResult.platform},t.getEngine=function(){return this.parsedResult.engine?this.parsedResult.engine:this.parseEngine()},t.getEngineName=function(e){return e?String(this.getEngine().name).toLowerCase()||"":this.getEngine().name||""},t.parseEngine=function(){var e=this;this.parsedResult.engine={};var t=o.default.find(a.default,function(t){if("function"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some(function(t){return e.test(t)});throw new Error("Browser's test function is not valid")});return t&&(this.parsedResult.engine=t.describe(this.getUA())),this.parsedResult.engine},t.parse=function(){return this.parseBrowser(),this.parseOS(),this.parsePlatform(),this.parseEngine(),this},t.getResult=function(){return o.default.assign({},this.parsedResult)},t.satisfies=function(e){var t=this,r={},n=0,i={},s=0;if(Object.keys(e).forEach(function(t){var a=e[t];"string"==typeof a?(i[t]=a,s+=1):"object"==typeof a&&(r[t]=a,n+=1);}),n>0){var a=Object.keys(r),u=o.default.find(a,function(e){return t.isOS(e)});if(u){var d=this.satisfies(r[u]);if(void 0!==d)return d}var c=o.default.find(a,function(e){return t.isPlatform(e)});if(c){var f=this.satisfies(r[c]);if(void 0!==f)return f}}if(s>0){var l=Object.keys(i),h=o.default.find(l,function(e){return t.isBrowser(e,!0)});if(void 0!==h)return this.compareVersion(i[h])}},t.isBrowser=function(e,t){void 0===t&&(t=!1);var r=this.getBrowserName().toLowerCase(),n=e.toLowerCase(),i=o.default.getBrowserTypeByAlias(n);return t&&i&&(n=i.toLowerCase()),n===r},t.compareVersion=function(e){var t=[0],r=e,n=!1,i=this.getBrowserVersion();if("string"==typeof i)return ">"===e[0]||"<"===e[0]?(r=e.substr(1),"="===e[1]?(n=!0,r=e.substr(2)):t=[],">"===e[0]?t.push(1):t.push(-1)):"="===e[0]?r=e.substr(1):"~"===e[0]&&(n=!0,r=e.substr(1)),t.indexOf(o.default.compareVersions(i,r,n))>-1},t.isOS=function(e){return this.getOSName(!0)===String(e).toLowerCase()},t.isPlatform=function(e){return this.getPlatformType(!0)===String(e).toLowerCase()},t.isEngine=function(e){return this.getEngineName(!0)===String(e).toLowerCase()},t.is=function(e,t){return void 0===t&&(t=!1),this.isBrowser(e,t)||this.isOS(e)||this.isPlatform(e)},t.some=function(e){var t=this;return void 0===e&&(e=[]),e.some(function(e){return t.is(e)})},e}();t.default=d,e.exports=t.default;},92:function(e,t,r){t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n};var s=/version\/(\d+(\.?_?\d+)+)/i,a=[{test:[/googlebot/i],describe:function(e){var t={name:"Googlebot"},r=i.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/opera/i],describe:function(e){var t={name:"Opera"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/opr\/|opios/i],describe:function(e){var t={name:"Opera"},r=i.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/SamsungBrowser/i],describe:function(e){var t={name:"Samsung Internet for Android"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Whale/i],describe:function(e){var t={name:"NAVER Whale Browser"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/MZBrowser/i],describe:function(e){var t={name:"MZ Browser"},r=i.default.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/focus/i],describe:function(e){var t={name:"Focus"},r=i.default.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/swing/i],describe:function(e){var t={name:"Swing"},r=i.default.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/coast/i],describe:function(e){var t={name:"Opera Coast"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/opt\/\d+(?:.?_?\d+)+/i],describe:function(e){var t={name:"Opera Touch"},r=i.default.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/yabrowser/i],describe:function(e){var t={name:"Yandex Browser"},r=i.default.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/ucbrowser/i],describe:function(e){var t={name:"UC Browser"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Maxthon|mxios/i],describe:function(e){var t={name:"Maxthon"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/epiphany/i],describe:function(e){var t={name:"Epiphany"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/puffin/i],describe:function(e){var t={name:"Puffin"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sleipnir/i],describe:function(e){var t={name:"Sleipnir"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/k-meleon/i],describe:function(e){var t={name:"K-Meleon"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/micromessenger/i],describe:function(e){var t={name:"WeChat"},r=i.default.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/qqbrowser/i],describe:function(e){var t={name:/qqbrowserlite/i.test(e)?"QQ Browser Lite":"QQ Browser"},r=i.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/msie|trident/i],describe:function(e){var t={name:"Internet Explorer"},r=i.default.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/\sedg\//i],describe:function(e){var t={name:"Microsoft Edge"},r=i.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/edg([ea]|ios)/i],describe:function(e){var t={name:"Microsoft Edge"},r=i.default.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/vivaldi/i],describe:function(e){var t={name:"Vivaldi"},r=i.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/seamonkey/i],describe:function(e){var t={name:"SeaMonkey"},r=i.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sailfish/i],describe:function(e){var t={name:"Sailfish"},r=i.default.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i,e);return r&&(t.version=r),t}},{test:[/silk/i],describe:function(e){var t={name:"Amazon Silk"},r=i.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/phantom/i],describe:function(e){var t={name:"PhantomJS"},r=i.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/slimerjs/i],describe:function(e){var t={name:"SlimerJS"},r=i.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/blackberry|\bbb\d+/i,/rim\stablet/i],describe:function(e){var t={name:"BlackBerry"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(web|hpw)[o0]s/i],describe:function(e){var t={name:"WebOS Browser"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/bada/i],describe:function(e){var t={name:"Bada"},r=i.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/tizen/i],describe:function(e){var t={name:"Tizen"},r=i.default.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/qupzilla/i],describe:function(e){var t={name:"QupZilla"},r=i.default.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/firefox|iceweasel|fxios/i],describe:function(e){var t={name:"Firefox"},r=i.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/electron/i],describe:function(e){var t={name:"Electron"},r=i.default.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/MiuiBrowser/i],describe:function(e){var t={name:"Miui"},r=i.default.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/chromium/i],describe:function(e){var t={name:"Chromium"},r=i.default.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/chrome|crios|crmo/i],describe:function(e){var t={name:"Chrome"},r=i.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/GSA/i],describe:function(e){var t={name:"Google Search"},r=i.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){var t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe:function(e){var t={name:"Android Browser"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/playstation 4/i],describe:function(e){var t={name:"PlayStation 4"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/safari|applewebkit/i],describe:function(e){var t={name:"Safari"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/.*/i],describe:function(e){var t=-1!==e.search("\\(")?/^(.*)\/(.*)[ \t]\((.*)/:/^(.*)\/(.*) /;return {name:i.default.getFirstMatch(t,e),version:i.default.getSecondMatch(t,e)}}}];t.default=a,e.exports=t.default;},93:function(e,t,r){t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:[/Roku\/DVP/],describe:function(e){var t=i.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i,e);return {name:s.OS_MAP.Roku,version:t}}},{test:[/windows phone/i],describe:function(e){var t=i.default.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i,e);return {name:s.OS_MAP.WindowsPhone,version:t}}},{test:[/windows /i],describe:function(e){var t=i.default.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i,e),r=i.default.getWindowsVersionName(t);return {name:s.OS_MAP.Windows,version:t,versionName:r}}},{test:[/Macintosh(.*?) FxiOS(.*?)\//],describe:function(e){var t={name:s.OS_MAP.iOS},r=i.default.getSecondMatch(/(Version\/)(\d[\d.]+)/,e);return r&&(t.version=r),t}},{test:[/macintosh/i],describe:function(e){var t=i.default.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i,e).replace(/[_\s]/g,"."),r=i.default.getMacOSVersionName(t),n={name:s.OS_MAP.MacOS,version:t};return r&&(n.versionName=r),n}},{test:[/(ipod|iphone|ipad)/i],describe:function(e){var t=i.default.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i,e).replace(/[_\s]/g,".");return {name:s.OS_MAP.iOS,version:t}}},{test:function(e){var t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe:function(e){var t=i.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i,e),r=i.default.getAndroidVersionName(t),n={name:s.OS_MAP.Android,version:t};return r&&(n.versionName=r),n}},{test:[/(web|hpw)[o0]s/i],describe:function(e){var t=i.default.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i,e),r={name:s.OS_MAP.WebOS};return t&&t.length&&(r.version=t),r}},{test:[/blackberry|\bbb\d+/i,/rim\stablet/i],describe:function(e){var t=i.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i,e)||i.default.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i,e)||i.default.getFirstMatch(/\bbb(\d+)/i,e);return {name:s.OS_MAP.BlackBerry,version:t}}},{test:[/bada/i],describe:function(e){var t=i.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i,e);return {name:s.OS_MAP.Bada,version:t}}},{test:[/tizen/i],describe:function(e){var t=i.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i,e);return {name:s.OS_MAP.Tizen,version:t}}},{test:[/linux/i],describe:function(){return {name:s.OS_MAP.Linux}}},{test:[/CrOS/],describe:function(){return {name:s.OS_MAP.ChromeOS}}},{test:[/PlayStation 4/],describe:function(e){var t=i.default.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i,e);return {name:s.OS_MAP.PlayStation4,version:t}}}];t.default=a,e.exports=t.default;},94:function(e,t,r){t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:[/googlebot/i],describe:function(){return {type:"bot",vendor:"Google"}}},{test:[/huawei/i],describe:function(e){var t=i.default.getFirstMatch(/(can-l01)/i,e)&&"Nova",r={type:s.PLATFORMS_MAP.mobile,vendor:"Huawei"};return t&&(r.model=t),r}},{test:[/nexus\s*(?:7|8|9|10).*/i],describe:function(){return {type:s.PLATFORMS_MAP.tablet,vendor:"Nexus"}}},{test:[/ipad/i],describe:function(){return {type:s.PLATFORMS_MAP.tablet,vendor:"Apple",model:"iPad"}}},{test:[/Macintosh(.*?) FxiOS(.*?)\//],describe:function(){return {type:s.PLATFORMS_MAP.tablet,vendor:"Apple",model:"iPad"}}},{test:[/kftt build/i],describe:function(){return {type:s.PLATFORMS_MAP.tablet,vendor:"Amazon",model:"Kindle Fire HD 7"}}},{test:[/silk/i],describe:function(){return {type:s.PLATFORMS_MAP.tablet,vendor:"Amazon"}}},{test:[/tablet(?! pc)/i],describe:function(){return {type:s.PLATFORMS_MAP.tablet}}},{test:function(e){var t=e.test(/ipod|iphone/i),r=e.test(/like (ipod|iphone)/i);return t&&!r},describe:function(e){var t=i.default.getFirstMatch(/(ipod|iphone)/i,e);return {type:s.PLATFORMS_MAP.mobile,vendor:"Apple",model:t}}},{test:[/nexus\s*[0-6].*/i,/galaxy nexus/i],describe:function(){return {type:s.PLATFORMS_MAP.mobile,vendor:"Nexus"}}},{test:[/[^-]mobi/i],describe:function(){return {type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return "blackberry"===e.getBrowserName(!0)},describe:function(){return {type:s.PLATFORMS_MAP.mobile,vendor:"BlackBerry"}}},{test:function(e){return "bada"===e.getBrowserName(!0)},describe:function(){return {type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return "windows phone"===e.getBrowserName()},describe:function(){return {type:s.PLATFORMS_MAP.mobile,vendor:"Microsoft"}}},{test:function(e){var t=Number(String(e.getOSVersion()).split(".")[0]);return "android"===e.getOSName(!0)&&t>=3},describe:function(){return {type:s.PLATFORMS_MAP.tablet}}},{test:function(e){return "android"===e.getOSName(!0)},describe:function(){return {type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return "macos"===e.getOSName(!0)},describe:function(){return {type:s.PLATFORMS_MAP.desktop,vendor:"Apple"}}},{test:function(e){return "windows"===e.getOSName(!0)},describe:function(){return {type:s.PLATFORMS_MAP.desktop}}},{test:function(e){return "linux"===e.getOSName(!0)},describe:function(){return {type:s.PLATFORMS_MAP.desktop}}},{test:function(e){return "playstation 4"===e.getOSName(!0)},describe:function(){return {type:s.PLATFORMS_MAP.tv}}},{test:function(e){return "roku"===e.getOSName(!0)},describe:function(){return {type:s.PLATFORMS_MAP.tv}}}];t.default=a,e.exports=t.default;},95:function(e,t,r){t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:function(e){return "microsoft edge"===e.getBrowserName(!0)},describe:function(e){if(/\sedg\//i.test(e))return {name:s.ENGINE_MAP.Blink};var t=i.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i,e);return {name:s.ENGINE_MAP.EdgeHTML,version:t}}},{test:[/trident/i],describe:function(e){var t={name:s.ENGINE_MAP.Trident},r=i.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){return e.test(/presto/i)},describe:function(e){var t={name:s.ENGINE_MAP.Presto},r=i.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){var t=e.test(/gecko/i),r=e.test(/like gecko/i);return t&&!r},describe:function(e){var t={name:s.ENGINE_MAP.Gecko},r=i.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(apple)?webkit\/537\.36/i],describe:function(){return {name:s.ENGINE_MAP.Blink}}},{test:[/(apple)?webkit/i],describe:function(e){var t={name:s.ENGINE_MAP.WebKit},r=i.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}}];t.default=a,e.exports=t.default;}})});})(es5);var es5Exports=es5.exports;var bowser=/*@__PURE__*/getDefaultExportFromCjs(es5Exports);const defaultUserAgent=_ref42=>{let{serviceId,clientVersion}=_ref42;return async()=>{var _window,_parsedUA$os,_parsedUA$os2,_parsedUA$browser$nam,_parsedUA$browser,_parsedUA$browser$ver,_parsedUA$browser2;const parsedUA=typeof window!=="undefined"&&(_window=window)!==null&&_window!==void 0&&(_window=_window.navigator)!==null&&_window!==void 0&&_window.userAgent?bowser.parse(window.navigator.userAgent):undefined;const sections=[["aws-sdk-js",clientVersion],["ua","2.0"],["os/".concat((parsedUA===null||parsedUA===void 0||(_parsedUA$os=parsedUA.os)===null||_parsedUA$os===void 0?void 0:_parsedUA$os.name)||"other"),parsedUA===null||parsedUA===void 0||(_parsedUA$os2=parsedUA.os)===null||_parsedUA$os2===void 0?void 0:_parsedUA$os2.version],["lang/js"],["md/browser","".concat((_parsedUA$browser$nam=parsedUA===null||parsedUA===void 0||(_parsedUA$browser=parsedUA.browser)===null||_parsedUA$browser===void 0?void 0:_parsedUA$browser.name)!==null&&_parsedUA$browser$nam!==void 0?_parsedUA$browser$nam:"unknown","_").concat((_parsedUA$browser$ver=parsedUA===null||parsedUA===void 0||(_parsedUA$browser2=parsedUA.browser)===null||_parsedUA$browser2===void 0?void 0:_parsedUA$browser2.version)!==null&&_parsedUA$browser$ver!==void 0?_parsedUA$browser$ver:"unknown")]];if(serviceId){sections.push(["api/".concat(serviceId),clientVersion]);}return sections}};const invalidProvider=message=>()=>Promise.reject(message);const TEXT_ENCODER=typeof TextEncoder=="function"?new TextEncoder:null;const calculateBodyLength=body=>{if(typeof body==="string"){if(TEXT_ENCODER){return TEXT_ENCODER.encode(body).byteLength}let len=body.length;for(let i=len-1;i>=0;i--){const code=body.charCodeAt(i);if(code>127&&code<=2047)len++;else if(code>2047&&code<=65535)len+=2;if(code>=56320&&code<=57343)i--;}return len}else if(typeof body.byteLength==="number"){return body.byteLength}else if(typeof body.size==="number"){return body.size}throw new Error("Body Length computation failed for ".concat(body))};const fromUtf8=input=>new TextEncoder().encode(input);const toUtf8=input=>{if(typeof input==="string"){return input}if(typeof input!=="object"||typeof input.byteOffset!=="number"||typeof input.byteLength!=="number"){throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.")}return new TextDecoder("utf-8").decode(input)};const s="required",t="fn",u="argv",v="ref";const a=true,b="isSet",c="booleanEquals",d="error",e="endpoint",f="tree",g="PartitionResult",h={[s]:false,"type":"String"},i={[s]:true,"default":false,"type":"Boolean"},j={[v]:"Endpoint"},k={[t]:c,[u]:[{[v]:"UseFIPS"},true]},l={[t]:c,[u]:[{[v]:"UseDualStack"},true]},m={},n={[t]:"getAttr",[u]:[{[v]:g},"supportsFIPS"]},o={[t]:c,[u]:[true,{[t]:"getAttr",[u]:[{[v]:g},"supportsDualStack"]}]},p=[k],q=[l],r=[{[v]:"Region"}];const _data={version:"1.0",parameters:{Region:h,UseDualStack:i,UseFIPS:i,Endpoint:h},rules:[{conditions:[{[t]:b,[u]:[j]}],rules:[{conditions:p,error:"Invalid Configuration: FIPS and custom endpoint are not supported",type:d},{conditions:q,error:"Invalid Configuration: Dualstack and custom endpoint are not supported",type:d},{endpoint:{url:j,properties:m,headers:m},type:e}],type:f},{conditions:[{[t]:b,[u]:r}],rules:[{conditions:[{[t]:"aws.partition",[u]:r,assign:g}],rules:[{conditions:[k,l],rules:[{conditions:[{[t]:c,[u]:[a,n]},o],rules:[{endpoint:{url:"https://cognito-identity-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",properties:m,headers:m},type:e}],type:f},{error:"FIPS and DualStack are enabled, but this partition does not support one or both",type:d}],type:f},{conditions:p,rules:[{conditions:[{[t]:c,[u]:[n,a]}],rules:[{endpoint:{url:"https://cognito-identity-fips.{Region}.{PartitionResult#dnsSuffix}",properties:m,headers:m},type:e}],type:f},{error:"FIPS is enabled but this partition does not support FIPS",type:d}],type:f},{conditions:q,rules:[{conditions:[o],rules:[{endpoint:{url:"https://cognito-identity.{Region}.{PartitionResult#dualStackDnsSuffix}",properties:m,headers:m},type:e}],type:f},{error:"DualStack is enabled but this partition does not support DualStack",type:d}],type:f},{endpoint:{url:"https://cognito-identity.{Region}.{PartitionResult#dnsSuffix}",properties:m,headers:m},type:e}],type:f}],type:f},{error:"Invalid Configuration: Missing Region",type:d}]};const ruleSet=_data;const defaultEndpointResolver=function(endpointParams){let context=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};return resolveEndpoint(ruleSet,{endpointParams:endpointParams,logger:context.logger})};customEndpointFunctions.aws=awsEndpointFunctions;const getRuntimeConfig$1=config=>{var _config$base64Decoder,_config$base64Encoder,_config$disableHostPr,_config$endpointProvi,_config$extensions,_config$httpAuthSchem,_config$httpAuthSchem2,_config$logger,_config$serviceId,_config$urlParser,_config$utf8Decoder,_config$utf8Encoder;return {apiVersion:"2014-06-30",base64Decoder:(_config$base64Decoder=config===null||config===void 0?void 0:config.base64Decoder)!==null&&_config$base64Decoder!==void 0?_config$base64Decoder:fromBase64,base64Encoder:(_config$base64Encoder=config===null||config===void 0?void 0:config.base64Encoder)!==null&&_config$base64Encoder!==void 0?_config$base64Encoder:toBase64,disableHostPrefix:(_config$disableHostPr=config===null||config===void 0?void 0:config.disableHostPrefix)!==null&&_config$disableHostPr!==void 0?_config$disableHostPr:false,endpointProvider:(_config$endpointProvi=config===null||config===void 0?void 0:config.endpointProvider)!==null&&_config$endpointProvi!==void 0?_config$endpointProvi:defaultEndpointResolver,extensions:(_config$extensions=config===null||config===void 0?void 0:config.extensions)!==null&&_config$extensions!==void 0?_config$extensions:[],httpAuthSchemeProvider:(_config$httpAuthSchem=config===null||config===void 0?void 0:config.httpAuthSchemeProvider)!==null&&_config$httpAuthSchem!==void 0?_config$httpAuthSchem:defaultCognitoIdentityHttpAuthSchemeProvider,httpAuthSchemes:(_config$httpAuthSchem2=config===null||config===void 0?void 0:config.httpAuthSchemes)!==null&&_config$httpAuthSchem2!==void 0?_config$httpAuthSchem2:[{schemeId:"aws.auth#sigv4",identityProvider:ipc=>ipc.getIdentityProvider("aws.auth#sigv4"),signer:new AwsSdkSigV4Signer},{schemeId:"smithy.api#noAuth",identityProvider:ipc=>ipc.getIdentityProvider("smithy.api#noAuth")||(async()=>({})),signer:new NoAuthSigner}],logger:(_config$logger=config===null||config===void 0?void 0:config.logger)!==null&&_config$logger!==void 0?_config$logger:new NoOpLogger,serviceId:(_config$serviceId=config===null||config===void 0?void 0:config.serviceId)!==null&&_config$serviceId!==void 0?_config$serviceId:"Cognito Identity",urlParser:(_config$urlParser=config===null||config===void 0?void 0:config.urlParser)!==null&&_config$urlParser!==void 0?_config$urlParser:parseUrl,utf8Decoder:(_config$utf8Decoder=config===null||config===void 0?void 0:config.utf8Decoder)!==null&&_config$utf8Decoder!==void 0?_config$utf8Decoder:fromUtf8,utf8Encoder:(_config$utf8Encoder=config===null||config===void 0?void 0:config.utf8Encoder)!==null&&_config$utf8Encoder!==void 0?_config$utf8Encoder:toUtf8}};const DEFAULTS_MODE_OPTIONS=["in-region","cross-region","mobile","standard","legacy"];const resolveDefaultsModeConfig=function(){let{defaultsMode}=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};return memoize(async()=>{const mode=typeof defaultsMode==="function"?await defaultsMode():defaultsMode;switch(mode===null||mode===void 0?void 0:mode.toLowerCase()){case"auto":return Promise.resolve(isMobileBrowser()?"mobile":"standard");case"mobile":case"in-region":case"cross-region":case"standard":case"legacy":return Promise.resolve(mode===null||mode===void 0?void 0:mode.toLocaleLowerCase());case undefined:return Promise.resolve("legacy");default:throw new Error("Invalid parameter for \"defaultsMode\", expect ".concat(DEFAULTS_MODE_OPTIONS.join(", "),", got ").concat(mode))}})};const isMobileBrowser=()=>{var _window2,_parsedUA$platform;const parsedUA=typeof window!=="undefined"&&(_window2=window)!==null&&_window2!==void 0&&(_window2=_window2.navigator)!==null&&_window2!==void 0&&_window2.userAgent?bowser.parse(window.navigator.userAgent):undefined;const platform=parsedUA===null||parsedUA===void 0||(_parsedUA$platform=parsedUA.platform)===null||_parsedUA$platform===void 0?void 0:_parsedUA$platform.type;return platform==="tablet"||platform==="mobile"};const getRuntimeConfig=config=>{var _config$bodyLengthChe,_config$credentialDef,_config$defaultUserAg,_config$maxAttempts,_config$region,_config$requestHandle,_config$retryMode,_config$sha,_config$streamCollect,_config$useDualstackE,_config$useFipsEndpoi;const defaultsMode=resolveDefaultsModeConfig(config);const defaultConfigProvider=()=>defaultsMode().then(loadConfigsForDefaultMode);const clientSharedValues=getRuntimeConfig$1(config);return {...clientSharedValues,...config,runtime:"browser",defaultsMode,bodyLengthChecker:(_config$bodyLengthChe=config===null||config===void 0?void 0:config.bodyLengthChecker)!==null&&_config$bodyLengthChe!==void 0?_config$bodyLengthChe:calculateBodyLength,credentialDefaultProvider:(_config$credentialDef=config===null||config===void 0?void 0:config.credentialDefaultProvider)!==null&&_config$credentialDef!==void 0?_config$credentialDef:_=>()=>Promise.reject(new Error("Credential is missing")),defaultUserAgentProvider:(_config$defaultUserAg=config===null||config===void 0?void 0:config.defaultUserAgentProvider)!==null&&_config$defaultUserAg!==void 0?_config$defaultUserAg:defaultUserAgent({serviceId:clientSharedValues.serviceId,clientVersion:packageInfo.version}),maxAttempts:(_config$maxAttempts=config===null||config===void 0?void 0:config.maxAttempts)!==null&&_config$maxAttempts!==void 0?_config$maxAttempts:DEFAULT_MAX_ATTEMPTS,region:(_config$region=config===null||config===void 0?void 0:config.region)!==null&&_config$region!==void 0?_config$region:invalidProvider("Region is missing"),requestHandler:FetchHttpHandler.create((_config$requestHandle=config===null||config===void 0?void 0:config.requestHandler)!==null&&_config$requestHandle!==void 0?_config$requestHandle:defaultConfigProvider),retryMode:(_config$retryMode=config===null||config===void 0?void 0:config.retryMode)!==null&&_config$retryMode!==void 0?_config$retryMode:async()=>(await defaultConfigProvider()).retryMode||DEFAULT_RETRY_MODE,sha256:(_config$sha=config===null||config===void 0?void 0:config.sha256)!==null&&_config$sha!==void 0?_config$sha:Sha256,streamCollector:(_config$streamCollect=config===null||config===void 0?void 0:config.streamCollector)!==null&&_config$streamCollect!==void 0?_config$streamCollect:streamCollector,useDualstackEndpoint:(_config$useDualstackE=config===null||config===void 0?void 0:config.useDualstackEndpoint)!==null&&_config$useDualstackE!==void 0?_config$useDualstackE:()=>Promise.resolve(DEFAULT_USE_DUALSTACK_ENDPOINT),useFipsEndpoint:(_config$useFipsEndpoi=config===null||config===void 0?void 0:config.useFipsEndpoint)!==null&&_config$useFipsEndpoi!==void 0?_config$useFipsEndpoi:()=>Promise.resolve(DEFAULT_USE_FIPS_ENDPOINT)}};const getAwsRegionExtensionConfiguration=runtimeConfig=>{let runtimeConfigRegion=async()=>{if(runtimeConfig.region===undefined){throw new Error("Region is missing from runtimeConfig")}const region=runtimeConfig.region;if(typeof region==="string"){return region}return region()};return {setRegion(region){runtimeConfigRegion=region;},region(){return runtimeConfigRegion}}};const resolveAwsRegionExtensionConfiguration=awsRegionExtensionConfiguration=>{return {region:awsRegionExtensionConfiguration.region()}};const getHttpAuthExtensionConfiguration=runtimeConfig=>{const _httpAuthSchemes=runtimeConfig.httpAuthSchemes;let _httpAuthSchemeProvider=runtimeConfig.httpAuthSchemeProvider;let _credentials=runtimeConfig.credentials;return {setHttpAuthScheme(httpAuthScheme){const index=_httpAuthSchemes.findIndex(scheme=>scheme.schemeId===httpAuthScheme.schemeId);if(index===-1){_httpAuthSchemes.push(httpAuthScheme);}else {_httpAuthSchemes.splice(index,1,httpAuthScheme);}},httpAuthSchemes(){return _httpAuthSchemes},setHttpAuthSchemeProvider(httpAuthSchemeProvider){_httpAuthSchemeProvider=httpAuthSchemeProvider;},httpAuthSchemeProvider(){return _httpAuthSchemeProvider},setCredentials(credentials){_credentials=credentials;},credentials(){return _credentials}}};const resolveHttpAuthRuntimeConfig=config=>{return {httpAuthSchemes:config.httpAuthSchemes(),httpAuthSchemeProvider:config.httpAuthSchemeProvider(),credentials:config.credentials()}};const asPartial=t=>t;const resolveRuntimeExtensions=(runtimeConfig,extensions)=>{const extensionConfiguration={...asPartial(getAwsRegionExtensionConfiguration(runtimeConfig)),...asPartial(getDefaultExtensionConfiguration(runtimeConfig)),...asPartial(getHttpHandlerExtensionConfiguration(runtimeConfig)),...asPartial(getHttpAuthExtensionConfiguration(runtimeConfig))};extensions.forEach(extension=>extension.configure(extensionConfiguration));return {...runtimeConfig,...resolveAwsRegionExtensionConfiguration(extensionConfiguration),...resolveDefaultRuntimeConfig(extensionConfiguration),...resolveHttpHandlerRuntimeConfig(extensionConfiguration),...resolveHttpAuthRuntimeConfig(extensionConfiguration)}};class CognitoIdentityClient extends Client{constructor(){for(var _len2=arguments.length,_ref43=new Array(_len2),_key2=0;_key2<_len2;_key2++){_ref43[_key2]=arguments[_key2];}let[configuration]=_ref43;const _config_0=getRuntimeConfig(configuration||{});const _config_1=resolveClientEndpointParameters(_config_0);const _config_2=resolveRegionConfig(_config_1);const _config_3=resolveEndpointConfig(_config_2);const _config_4=resolveHostHeaderConfig(_config_3);const _config_5=resolveUserAgentConfig(_config_4);const _config_6=resolveRetryConfig(_config_5);const _config_7=resolveHttpAuthSchemeConfig(_config_6);const _config_8=resolveRuntimeExtensions(_config_7,(configuration===null||configuration===void 0?void 0:configuration.extensions)||[]);super(_config_8);this.config=_config_8;this.middlewareStack.use(getHostHeaderPlugin(this.config));this.middlewareStack.use(getLoggerPlugin(this.config));this.middlewareStack.use(getRecursionDetectionPlugin(this.config));this.middlewareStack.use(getUserAgentPlugin(this.config));this.middlewareStack.use(getRetryPlugin(this.config));this.middlewareStack.use(getContentLengthPlugin(this.config));this.middlewareStack.use(getHttpAuthSchemeEndpointRuleSetPlugin(this.config,{httpAuthSchemeParametersProvider:this.getDefaultHttpAuthSchemeParametersProvider(),identityProviderConfigProvider:this.getIdentityProviderConfigProvider()}));this.middlewareStack.use(getHttpSigningPlugin(this.config));}destroy(){super.destroy();}getDefaultHttpAuthSchemeParametersProvider(){return defaultCognitoIdentityHttpAuthSchemeParametersProvider}getIdentityProviderConfigProvider(){return async config=>new DefaultIdentityProviderConfig({"aws.auth#sigv4":config.credentials})}}class CognitoIdentityServiceException extends ServiceException{constructor(options){super(options);Object.setPrototypeOf(this,CognitoIdentityServiceException.prototype);}}class InternalErrorException extends CognitoIdentityServiceException{constructor(opts){super({name:"InternalErrorException",$fault:"server",...opts});this.name="InternalErrorException";this.$fault="server";Object.setPrototypeOf(this,InternalErrorException.prototype);}}class InvalidParameterException extends CognitoIdentityServiceException{constructor(opts){super({name:"InvalidParameterException",$fault:"client",...opts});this.name="InvalidParameterException";this.$fault="client";Object.setPrototypeOf(this,InvalidParameterException.prototype);}}class LimitExceededException extends CognitoIdentityServiceException{constructor(opts){super({name:"LimitExceededException",$fault:"client",...opts});this.name="LimitExceededException";this.$fault="client";Object.setPrototypeOf(this,LimitExceededException.prototype);}}class NotAuthorizedException extends CognitoIdentityServiceException{constructor(opts){super({name:"NotAuthorizedException",$fault:"client",...opts});this.name="NotAuthorizedException";this.$fault="client";Object.setPrototypeOf(this,NotAuthorizedException.prototype);}}class ResourceConflictException extends CognitoIdentityServiceException{constructor(opts){super({name:"ResourceConflictException",$fault:"client",...opts});this.name="ResourceConflictException";this.$fault="client";Object.setPrototypeOf(this,ResourceConflictException.prototype);}}class TooManyRequestsException extends CognitoIdentityServiceException{constructor(opts){super({name:"TooManyRequestsException",$fault:"client",...opts});this.name="TooManyRequestsException";this.$fault="client";Object.setPrototypeOf(this,TooManyRequestsException.prototype);}}class ResourceNotFoundException extends CognitoIdentityServiceException{constructor(opts){super({name:"ResourceNotFoundException",$fault:"client",...opts});this.name="ResourceNotFoundException";this.$fault="client";Object.setPrototypeOf(this,ResourceNotFoundException.prototype);}}class ExternalServiceException extends CognitoIdentityServiceException{constructor(opts){super({name:"ExternalServiceException",$fault:"client",...opts});this.name="ExternalServiceException";this.$fault="client";Object.setPrototypeOf(this,ExternalServiceException.prototype);}}class InvalidIdentityPoolConfigurationException extends CognitoIdentityServiceException{constructor(opts){super({name:"InvalidIdentityPoolConfigurationException",$fault:"client",...opts});this.name="InvalidIdentityPoolConfigurationException";this.$fault="client";Object.setPrototypeOf(this,InvalidIdentityPoolConfigurationException.prototype);}}class DeveloperUserAlreadyRegisteredException extends CognitoIdentityServiceException{constructor(opts){super({name:"DeveloperUserAlreadyRegisteredException",$fault:"client",...opts});this.name="DeveloperUserAlreadyRegisteredException";this.$fault="client";Object.setPrototypeOf(this,DeveloperUserAlreadyRegisteredException.prototype);}}class ConcurrentModificationException extends CognitoIdentityServiceException{constructor(opts){super({name:"ConcurrentModificationException",$fault:"client",...opts});this.name="ConcurrentModificationException";this.$fault="client";Object.setPrototypeOf(this,ConcurrentModificationException.prototype);}}const se_GetCredentialsForIdentityCommand=async(input,context)=>{const headers=sharedHeaders("GetCredentialsForIdentity");let body;body=JSON.stringify(_json(input));return buildHttpRpcRequest(context,headers,"/",undefined,body)};const se_GetIdCommand=async(input,context)=>{const headers=sharedHeaders("GetId");let body;body=JSON.stringify(_json(input));return buildHttpRpcRequest(context,headers,"/",undefined,body)};const de_GetCredentialsForIdentityCommand=async(output,context)=>{if(output.statusCode>=300){return de_CommandError(output,context)}const data=await parseJsonBody(output.body,context);let contents={};contents=de_GetCredentialsForIdentityResponse(data);const response={$metadata:deserializeMetadata(output),...contents};return response};const de_GetIdCommand=async(output,context)=>{if(output.statusCode>=300){return de_CommandError(output,context)}const data=await parseJsonBody(output.body,context);let contents={};contents=_json(data);const response={$metadata:deserializeMetadata(output),...contents};return response};const de_CommandError=async(output,context)=>{const parsedOutput={...output,body:await parseJsonErrorBody(output.body,context)};const errorCode=loadRestJsonErrorCode(output,parsedOutput.body);switch(errorCode){case"InternalErrorException":case"com.amazonaws.cognitoidentity#InternalErrorException":throw await de_InternalErrorExceptionRes(parsedOutput);case"InvalidParameterException":case"com.amazonaws.cognitoidentity#InvalidParameterException":throw await de_InvalidParameterExceptionRes(parsedOutput);case"LimitExceededException":case"com.amazonaws.cognitoidentity#LimitExceededException":throw await de_LimitExceededExceptionRes(parsedOutput);case"NotAuthorizedException":case"com.amazonaws.cognitoidentity#NotAuthorizedException":throw await de_NotAuthorizedExceptionRes(parsedOutput);case"ResourceConflictException":case"com.amazonaws.cognitoidentity#ResourceConflictException":throw await de_ResourceConflictExceptionRes(parsedOutput);case"TooManyRequestsException":case"com.amazonaws.cognitoidentity#TooManyRequestsException":throw await de_TooManyRequestsExceptionRes(parsedOutput);case"ResourceNotFoundException":case"com.amazonaws.cognitoidentity#ResourceNotFoundException":throw await de_ResourceNotFoundExceptionRes(parsedOutput);case"ExternalServiceException":case"com.amazonaws.cognitoidentity#ExternalServiceException":throw await de_ExternalServiceExceptionRes(parsedOutput);case"InvalidIdentityPoolConfigurationException":case"com.amazonaws.cognitoidentity#InvalidIdentityPoolConfigurationException":throw await de_InvalidIdentityPoolConfigurationExceptionRes(parsedOutput);case"DeveloperUserAlreadyRegisteredException":case"com.amazonaws.cognitoidentity#DeveloperUserAlreadyRegisteredException":throw await de_DeveloperUserAlreadyRegisteredExceptionRes(parsedOutput);case"ConcurrentModificationException":case"com.amazonaws.cognitoidentity#ConcurrentModificationException":throw await de_ConcurrentModificationExceptionRes(parsedOutput);default:const parsedBody=parsedOutput.body;return throwDefaultError({output,parsedBody,errorCode})}};const de_ConcurrentModificationExceptionRes=async(parsedOutput,context)=>{const body=parsedOutput.body;const deserialized=_json(body);const exception=new ConcurrentModificationException({$metadata:deserializeMetadata(parsedOutput),...deserialized});return decorateServiceException(exception,body)};const de_DeveloperUserAlreadyRegisteredExceptionRes=async(parsedOutput,context)=>{const body=parsedOutput.body;const deserialized=_json(body);const exception=new DeveloperUserAlreadyRegisteredException({$metadata:deserializeMetadata(parsedOutput),...deserialized});return decorateServiceException(exception,body)};const de_ExternalServiceExceptionRes=async(parsedOutput,context)=>{const body=parsedOutput.body;const deserialized=_json(body);const exception=new ExternalServiceException({$metadata:deserializeMetadata(parsedOutput),...deserialized});return decorateServiceException(exception,body)};const de_InternalErrorExceptionRes=async(parsedOutput,context)=>{const body=parsedOutput.body;const deserialized=_json(body);const exception=new InternalErrorException({$metadata:deserializeMetadata(parsedOutput),...deserialized});return decorateServiceException(exception,body)};const de_InvalidIdentityPoolConfigurationExceptionRes=async(parsedOutput,context)=>{const body=parsedOutput.body;const deserialized=_json(body);const exception=new InvalidIdentityPoolConfigurationException({$metadata:deserializeMetadata(parsedOutput),...deserialized});return decorateServiceException(exception,body)};const de_InvalidParameterExceptionRes=async(parsedOutput,context)=>{const body=parsedOutput.body;const deserialized=_json(body);const exception=new InvalidParameterException({$metadata:deserializeMetadata(parsedOutput),...deserialized});return decorateServiceException(exception,body)};const de_LimitExceededExceptionRes=async(parsedOutput,context)=>{const body=parsedOutput.body;const deserialized=_json(body);const exception=new LimitExceededException({$metadata:deserializeMetadata(parsedOutput),...deserialized});return decorateServiceException(exception,body)};const de_NotAuthorizedExceptionRes=async(parsedOutput,context)=>{const body=parsedOutput.body;const deserialized=_json(body);const exception=new NotAuthorizedException({$metadata:deserializeMetadata(parsedOutput),...deserialized});return decorateServiceException(exception,body)};const de_ResourceConflictExceptionRes=async(parsedOutput,context)=>{const body=parsedOutput.body;const deserialized=_json(body);const exception=new ResourceConflictException({$metadata:deserializeMetadata(parsedOutput),...deserialized});return decorateServiceException(exception,body)};const de_ResourceNotFoundExceptionRes=async(parsedOutput,context)=>{const body=parsedOutput.body;const deserialized=_json(body);const exception=new ResourceNotFoundException({$metadata:deserializeMetadata(parsedOutput),...deserialized});return decorateServiceException(exception,body)};const de_TooManyRequestsExceptionRes=async(parsedOutput,context)=>{const body=parsedOutput.body;const deserialized=_json(body);const exception=new TooManyRequestsException({$metadata:deserializeMetadata(parsedOutput),...deserialized});return decorateServiceException(exception,body)};const de_Credentials=(output,context)=>{return take(output,{AccessKeyId:expectString,Expiration:_=>expectNonNull(parseEpochTimestamp(expectNumber(_))),SecretKey:expectString,SessionToken:expectString})};const de_GetCredentialsForIdentityResponse=(output,context)=>{return take(output,{Credentials:_=>de_Credentials(_),IdentityId:expectString})};const deserializeMetadata=output=>{var _ref44,_output$headers$xAmz2;return {httpStatusCode:output.statusCode,requestId:(_ref44=(_output$headers$xAmz2=output.headers["x-amzn-requestid"])!==null&&_output$headers$xAmz2!==void 0?_output$headers$xAmz2:output.headers["x-amzn-request-id"])!==null&&_ref44!==void 0?_ref44:output.headers["x-amz-request-id"],extendedRequestId:output.headers["x-amz-id-2"],cfId:output.headers["x-amz-cf-id"]}};const throwDefaultError=withBaseException(CognitoIdentityServiceException);const buildHttpRpcRequest=async(context,headers,path,resolvedHostname,body)=>{const{hostname,protocol="https",port,path:basePath}=await context.endpoint();const contents={protocol,hostname,port,method:"POST",path:basePath.endsWith("/")?basePath.slice(0,-1)+path:basePath+path,headers};if(body!==undefined){contents.body=body;}return new HttpRequest(contents)};function sharedHeaders(operation){return {"content-type":"application/x-amz-json-1.1","x-amz-target":"AWSCognitoIdentityService.".concat(operation)}}class GetCredentialsForIdentityCommand extends Command.classBuilder().ep({...commonParams}).m(function(Command,cs,config,o){return [getSerdePlugin(config,this.serialize,this.deserialize),getEndpointPlugin(config,Command.getEndpointParameterInstructions())]}).s("AWSCognitoIdentityService","GetCredentialsForIdentity",{}).n("CognitoIdentityClient","GetCredentialsForIdentityCommand").f(void 0,void 0).ser(se_GetCredentialsForIdentityCommand).de(de_GetCredentialsForIdentityCommand).build(){}class GetIdCommand extends Command.classBuilder().ep({...commonParams}).m(function(Command,cs,config,o){return [getSerdePlugin(config,this.serialize,this.deserialize),getEndpointPlugin(config,Command.getEndpointParameterInstructions())]}).s("AWSCognitoIdentityService","GetId",{}).n("CognitoIdentityClient","GetIdCommand").f(void 0,void 0).ser(se_GetIdCommand).de(de_GetIdCommand).build(){}var loadCognitoIdentity=/*#__PURE__*/Object.freeze({__proto__:null,CognitoIdentityClient:CognitoIdentityClient,GetCredentialsForIdentityCommand:GetCredentialsForIdentityCommand,GetIdCommand:GetIdCommand});}); 
    	} (amazonLocationAuthHelper));
    	return amazonLocationAuthHelper;
    }

    var amazonLocationAuthHelperExports = requireAmazonLocationAuthHelper();

    var name$4 = "@amzn/geomaps-client";
    var description$4 = "@amzn/geomaps-client client";
    var version$4 = "0.0.1";
    var scripts$4 = {
    	build: "concurrently 'npm:build:cjs' 'npm:build:es' 'npm:build:types'",
    	"build:cjs": "tsc -p tsconfig.cjs.json",
    	"build:docs": "typedoc",
    	"build:es": "tsc -p tsconfig.es.json",
    	"build:types": "tsc -p tsconfig.types.json",
    	"build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    	clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    	prepack: "npm run clean && npm run build"
    };
    var main$4 = "./dist-cjs/index.js";
    var types$4 = "./dist-types/index.d.ts";
    var module$4 = "./dist-es/index.js";
    var sideEffects$4 = false;
    var dependencies$4 = {
    	tslib: "^2.5.0",
    	"@aws-crypto/sha256-browser": "3.0.0",
    	"@aws-crypto/sha256-js": "3.0.0",
    	"@aws-sdk/client-sts": "3.441.0",
    	"@aws-sdk/core": "3.441.0",
    	"@aws-sdk/credential-provider-node": "3.441.0",
    	"@aws-sdk/middleware-host-header": "3.433.0",
    	"@aws-sdk/middleware-logger": "3.433.0",
    	"@aws-sdk/middleware-recursion-detection": "3.433.0",
    	"@aws-sdk/middleware-signing": "3.433.0",
    	"@aws-sdk/middleware-user-agent": "3.438.0",
    	"@aws-sdk/region-config-resolver": "3.433.0",
    	"@aws-sdk/types": "3.433.0",
    	"@aws-sdk/util-user-agent-browser": "3.433.0",
    	"@aws-sdk/util-user-agent-node": "3.437.0",
    	"@smithy/config-resolver": "^2.0.16",
    	"@smithy/fetch-http-handler": "^2.2.4",
    	"@smithy/hash-node": "^2.0.12",
    	"@smithy/invalid-dependency": "^2.0.12",
    	"@smithy/middleware-content-length": "^2.0.14",
    	"@smithy/middleware-retry": "^2.0.18",
    	"@smithy/middleware-serde": "^2.0.12",
    	"@smithy/middleware-stack": "^2.0.6",
    	"@smithy/node-config-provider": "^2.1.3",
    	"@smithy/node-http-handler": "^2.1.8",
    	"@smithy/protocol-http": "^3.0.8",
    	"@smithy/smithy-client": "^2.1.12",
    	"@smithy/types": "^2.4.0",
    	"@smithy/url-parser": "^2.0.12",
    	"@smithy/util-base64": "^2.0.0",
    	"@smithy/util-body-length-browser": "^2.0.0",
    	"@smithy/util-body-length-node": "^2.1.0",
    	"@smithy/util-defaults-mode-browser": "^2.0.16",
    	"@smithy/util-defaults-mode-node": "^2.0.21",
    	"@smithy/util-retry": "^2.0.5",
    	"@smithy/util-stream": "^2.0.17",
    	"@smithy/util-utf8": "^2.0.0"
    };
    var devDependencies$4 = {
    	"@tsconfig/node14": "1.0.3",
    	concurrently: "7.0.0",
    	"downlevel-dts": "0.10.1",
    	rimraf: "^3.0.0",
    	typedoc: "0.23.23",
    	typescript: "~4.9.5",
    	"@smithy/service-client-documentation-generator": "^2.0.0",
    	"@types/node": "^14.14.31"
    };
    var engines$4 = {
    	node: ">=14.0.0"
    };
    var typesVersions$4 = {
    	"<4.0": {
    		"dist-types/*": [
    			"dist-types/ts3.4/*"
    		]
    	}
    };
    var files$4 = [
    	"dist-*/**"
    ];
    var browser$4 = {
    	"./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
    };
    var packageInfo$4 = {
    	name: name$4,
    	description: description$4,
    	version: version$4,
    	scripts: scripts$4,
    	main: main$4,
    	types: types$4,
    	module: module$4,
    	sideEffects: sideEffects$4,
    	dependencies: dependencies$4,
    	devDependencies: devDependencies$4,
    	engines: engines$4,
    	typesVersions: typesVersions$4,
    	files: files$4,
    	browser: browser$4,
    	"react-native": {
    	"./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
    }
    };

    var build$c = {};

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics$9 = function(d, b) {
        extendStatics$9 = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics$9(d, b);
    };

    function __extends$9(d, b) {
        extendStatics$9(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign$9 = function() {
        __assign$9 = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign$9.apply(this, arguments);
    };

    function __rest$9(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate$9(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param$9(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata$9(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter$9(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator$9(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __createBinding$9(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }

    function __exportStar$9(m, exports) {
        for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values$9(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read$9(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread$9() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read$9(arguments[i]));
        return ar;
    }

    function __spreadArrays$9() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __await$9(v) {
        return this instanceof __await$9 ? (this.v = v, this) : new __await$9(v);
    }

    function __asyncGenerator$9(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await$9 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator$9(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await$9(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues$9(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values$9 === "function" ? __values$9(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject$9(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    }
    function __importStar$9(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault$9(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    function __classPrivateFieldGet$9(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }

    function __classPrivateFieldSet$9(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    var tslib_es6$9 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        get __assign () { return __assign$9; },
        __asyncDelegator: __asyncDelegator$9,
        __asyncGenerator: __asyncGenerator$9,
        __asyncValues: __asyncValues$9,
        __await: __await$9,
        __awaiter: __awaiter$9,
        __classPrivateFieldGet: __classPrivateFieldGet$9,
        __classPrivateFieldSet: __classPrivateFieldSet$9,
        __createBinding: __createBinding$9,
        __decorate: __decorate$9,
        __exportStar: __exportStar$9,
        __extends: __extends$9,
        __generator: __generator$9,
        __importDefault: __importDefault$9,
        __importStar: __importStar$9,
        __makeTemplateObject: __makeTemplateObject$9,
        __metadata: __metadata$9,
        __param: __param$9,
        __read: __read$9,
        __rest: __rest$9,
        __spread: __spread$9,
        __spreadArrays: __spreadArrays$9,
        __values: __values$9
    });

    var require$$0$a = /*@__PURE__*/getAugmentedNamespace(tslib_es6$9);

    var crossPlatformSha256$2 = {};

    var ie11Sha256$2 = {};

    var isEmptyData$5 = {};

    var hasRequiredIsEmptyData$5;

    function requireIsEmptyData$5 () {
    	if (hasRequiredIsEmptyData$5) return isEmptyData$5;
    	hasRequiredIsEmptyData$5 = 1;
    	Object.defineProperty(isEmptyData$5, "__esModule", { value: true });
    	isEmptyData$5.isEmptyData = void 0;
    	function isEmptyData(data) {
    	    if (typeof data === "string") {
    	        return data.length === 0;
    	    }
    	    return data.byteLength === 0;
    	}
    	isEmptyData$5.isEmptyData = isEmptyData;
    	
    	return isEmptyData$5;
    }

    var constants$5 = {};

    var hasRequiredConstants$5;

    function requireConstants$5 () {
    	if (hasRequiredConstants$5) return constants$5;
    	hasRequiredConstants$5 = 1;
    	(function (exports) {
    		Object.defineProperty(exports, "__esModule", { value: true });
    		exports.EMPTY_DATA_SHA_256 = exports.SHA_256_HMAC_ALGO = exports.SHA_256_HASH = void 0;
    		exports.SHA_256_HASH = { name: "SHA-256" };
    		exports.SHA_256_HMAC_ALGO = {
    		    name: "HMAC",
    		    hash: exports.SHA_256_HASH
    		};
    		exports.EMPTY_DATA_SHA_256 = new Uint8Array([
    		    227,
    		    176,
    		    196,
    		    66,
    		    152,
    		    252,
    		    28,
    		    20,
    		    154,
    		    251,
    		    244,
    		    200,
    		    153,
    		    111,
    		    185,
    		    36,
    		    39,
    		    174,
    		    65,
    		    228,
    		    100,
    		    155,
    		    147,
    		    76,
    		    164,
    		    149,
    		    153,
    		    27,
    		    120,
    		    82,
    		    184,
    		    85
    		]);
    		
    	} (constants$5));
    	return constants$5;
    }

    const fromUtf8$6 = (input) => {
        const bytes = [];
        for (let i = 0, len = input.length; i < len; i++) {
            const value = input.charCodeAt(i);
            if (value < 0x80) {
                bytes.push(value);
            }
            else if (value < 0x800) {
                bytes.push((value >> 6) | 0b11000000, (value & 0b111111) | 0b10000000);
            }
            else if (i + 1 < input.length && (value & 0xfc00) === 0xd800 && (input.charCodeAt(i + 1) & 0xfc00) === 0xdc00) {
                const surrogatePair = 0x10000 + ((value & 0b1111111111) << 10) + (input.charCodeAt(++i) & 0b1111111111);
                bytes.push((surrogatePair >> 18) | 0b11110000, ((surrogatePair >> 12) & 0b111111) | 0b10000000, ((surrogatePair >> 6) & 0b111111) | 0b10000000, (surrogatePair & 0b111111) | 0b10000000);
            }
            else {
                bytes.push((value >> 12) | 0b11100000, ((value >> 6) & 0b111111) | 0b10000000, (value & 0b111111) | 0b10000000);
            }
        }
        return Uint8Array.from(bytes);
    };
    const toUtf8$5 = (input) => {
        let decoded = "";
        for (let i = 0, len = input.length; i < len; i++) {
            const byte = input[i];
            if (byte < 0x80) {
                decoded += String.fromCharCode(byte);
            }
            else if (0b11000000 <= byte && byte < 0b11100000) {
                const nextByte = input[++i];
                decoded += String.fromCharCode(((byte & 0b11111) << 6) | (nextByte & 0b111111));
            }
            else if (0b11110000 <= byte && byte < 0b101101101) {
                const surrogatePair = [byte, input[++i], input[++i], input[++i]];
                const encoded = "%" + surrogatePair.map((byteValue) => byteValue.toString(16)).join("%");
                decoded += decodeURIComponent(encoded);
            }
            else {
                decoded += String.fromCharCode(((byte & 0b1111) << 12) | ((input[++i] & 0b111111) << 6) | (input[++i] & 0b111111));
            }
        }
        return decoded;
    };

    function fromUtf8$5(input) {
        return new TextEncoder().encode(input);
    }
    function toUtf8$4(input) {
        return new TextDecoder("utf-8").decode(input);
    }

    const fromUtf8$4 = (input) => typeof TextEncoder === "function" ? fromUtf8$5(input) : fromUtf8$6(input);
    const toUtf8$3 = (input) => typeof TextDecoder === "function" ? toUtf8$4(input) : toUtf8$5(input);

    var distEs = /*#__PURE__*/Object.freeze({
        __proto__: null,
        fromUtf8: fromUtf8$4,
        toUtf8: toUtf8$3
    });

    var require$$0$9 = /*@__PURE__*/getAugmentedNamespace(distEs);

    var require$$5 = /*@__PURE__*/getAugmentedNamespace(distEs$1);

    var hasRequiredIe11Sha256$2;

    function requireIe11Sha256$2 () {
    	if (hasRequiredIe11Sha256$2) return ie11Sha256$2;
    	hasRequiredIe11Sha256$2 = 1;
    	Object.defineProperty(ie11Sha256$2, "__esModule", { value: true });
    	ie11Sha256$2.Sha256 = void 0;
    	var isEmptyData_1 = requireIsEmptyData$5();
    	var constants_1 = requireConstants$5();
    	var util_utf8_browser_1 = require$$0$9;
    	var util_locate_window_1 = require$$5;
    	var Sha256 = /** @class */ (function () {
    	    function Sha256(secret) {
    	        this.secret = secret;
    	        this.reset();
    	    }
    	    Sha256.prototype.update = function (toHash) {
    	        var _this = this;
    	        if ((0, isEmptyData_1.isEmptyData)(toHash)) {
    	            return;
    	        }
    	        this.operation = this.operation.then(function (operation) {
    	            operation.onerror = function () {
    	                _this.operation = Promise.reject(new Error("Error encountered updating hash"));
    	            };
    	            operation.process(toArrayBufferView(toHash));
    	            return operation;
    	        });
    	        this.operation.catch(function () { });
    	    };
    	    Sha256.prototype.digest = function () {
    	        return this.operation.then(function (operation) {
    	            return new Promise(function (resolve, reject) {
    	                operation.onerror = function () {
    	                    reject(new Error("Error encountered finalizing hash"));
    	                };
    	                operation.oncomplete = function () {
    	                    if (operation.result) {
    	                        resolve(new Uint8Array(operation.result));
    	                    }
    	                    reject(new Error("Error encountered finalizing hash"));
    	                };
    	                operation.finish();
    	            });
    	        });
    	    };
    	    Sha256.prototype.reset = function () {
    	        if (this.secret) {
    	            this.operation = getKeyPromise(this.secret).then(function (keyData) {
    	                return (0, util_locate_window_1.locateWindow)().msCrypto.subtle.sign(constants_1.SHA_256_HMAC_ALGO, keyData);
    	            });
    	            this.operation.catch(function () { });
    	        }
    	        else {
    	            this.operation = Promise.resolve((0, util_locate_window_1.locateWindow)().msCrypto.subtle.digest("SHA-256"));
    	        }
    	    };
    	    return Sha256;
    	}());
    	ie11Sha256$2.Sha256 = Sha256;
    	function getKeyPromise(secret) {
    	    return new Promise(function (resolve, reject) {
    	        var keyOperation = (0, util_locate_window_1.locateWindow)().msCrypto.subtle.importKey("raw", toArrayBufferView(secret), constants_1.SHA_256_HMAC_ALGO, false, ["sign"]);
    	        keyOperation.oncomplete = function () {
    	            if (keyOperation.result) {
    	                resolve(keyOperation.result);
    	            }
    	            reject(new Error("ImportKey completed without importing key."));
    	        };
    	        keyOperation.onerror = function () {
    	            reject(new Error("ImportKey failed to import key."));
    	        };
    	    });
    	}
    	function toArrayBufferView(data) {
    	    if (typeof data === "string") {
    	        return (0, util_utf8_browser_1.fromUtf8)(data);
    	    }
    	    if (ArrayBuffer.isView(data)) {
    	        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    	    }
    	    return new Uint8Array(data);
    	}
    	
    	return ie11Sha256$2;
    }

    var webCryptoSha256$2 = {};

    var build$b = {};

    var convertToBuffer$2 = {};

    var hasRequiredConvertToBuffer$2;

    function requireConvertToBuffer$2 () {
    	if (hasRequiredConvertToBuffer$2) return convertToBuffer$2;
    	hasRequiredConvertToBuffer$2 = 1;
    	// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
    	// SPDX-License-Identifier: Apache-2.0
    	Object.defineProperty(convertToBuffer$2, "__esModule", { value: true });
    	convertToBuffer$2.convertToBuffer = void 0;
    	var util_utf8_browser_1 = require$$0$9;
    	// Quick polyfill
    	var fromUtf8 = typeof Buffer !== "undefined" && Buffer.from
    	    ? function (input) { return Buffer.from(input, "utf8"); }
    	    : util_utf8_browser_1.fromUtf8;
    	function convertToBuffer(data) {
    	    // Already a Uint8, do nothing
    	    if (data instanceof Uint8Array)
    	        return data;
    	    if (typeof data === "string") {
    	        return fromUtf8(data);
    	    }
    	    if (ArrayBuffer.isView(data)) {
    	        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    	    }
    	    return new Uint8Array(data);
    	}
    	convertToBuffer$2.convertToBuffer = convertToBuffer;
    	
    	return convertToBuffer$2;
    }

    var isEmptyData$4 = {};

    var hasRequiredIsEmptyData$4;

    function requireIsEmptyData$4 () {
    	if (hasRequiredIsEmptyData$4) return isEmptyData$4;
    	hasRequiredIsEmptyData$4 = 1;
    	// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
    	// SPDX-License-Identifier: Apache-2.0
    	Object.defineProperty(isEmptyData$4, "__esModule", { value: true });
    	isEmptyData$4.isEmptyData = void 0;
    	function isEmptyData(data) {
    	    if (typeof data === "string") {
    	        return data.length === 0;
    	    }
    	    return data.byteLength === 0;
    	}
    	isEmptyData$4.isEmptyData = isEmptyData;
    	
    	return isEmptyData$4;
    }

    var numToUint8$2 = {};

    var hasRequiredNumToUint8$2;

    function requireNumToUint8$2 () {
    	if (hasRequiredNumToUint8$2) return numToUint8$2;
    	hasRequiredNumToUint8$2 = 1;
    	// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
    	// SPDX-License-Identifier: Apache-2.0
    	Object.defineProperty(numToUint8$2, "__esModule", { value: true });
    	numToUint8$2.numToUint8 = void 0;
    	function numToUint8(num) {
    	    return new Uint8Array([
    	        (num & 0xff000000) >> 24,
    	        (num & 0x00ff0000) >> 16,
    	        (num & 0x0000ff00) >> 8,
    	        num & 0x000000ff,
    	    ]);
    	}
    	numToUint8$2.numToUint8 = numToUint8;
    	
    	return numToUint8$2;
    }

    var uint32ArrayFrom$2 = {};

    var hasRequiredUint32ArrayFrom$2;

    function requireUint32ArrayFrom$2 () {
    	if (hasRequiredUint32ArrayFrom$2) return uint32ArrayFrom$2;
    	hasRequiredUint32ArrayFrom$2 = 1;
    	// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
    	// SPDX-License-Identifier: Apache-2.0
    	Object.defineProperty(uint32ArrayFrom$2, "__esModule", { value: true });
    	uint32ArrayFrom$2.uint32ArrayFrom = void 0;
    	// IE 11 does not support Array.from, so we do it manually
    	function uint32ArrayFrom(a_lookUpTable) {
    	    if (!Uint32Array.from) {
    	        var return_array = new Uint32Array(a_lookUpTable.length);
    	        var a_index = 0;
    	        while (a_index < a_lookUpTable.length) {
    	            return_array[a_index] = a_lookUpTable[a_index];
    	            a_index += 1;
    	        }
    	        return return_array;
    	    }
    	    return Uint32Array.from(a_lookUpTable);
    	}
    	uint32ArrayFrom$2.uint32ArrayFrom = uint32ArrayFrom;
    	
    	return uint32ArrayFrom$2;
    }

    var hasRequiredBuild$c;

    function requireBuild$c () {
    	if (hasRequiredBuild$c) return build$b;
    	hasRequiredBuild$c = 1;
    	(function (exports) {
    		// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
    		// SPDX-License-Identifier: Apache-2.0
    		Object.defineProperty(exports, "__esModule", { value: true });
    		exports.uint32ArrayFrom = exports.numToUint8 = exports.isEmptyData = exports.convertToBuffer = void 0;
    		var convertToBuffer_1 = requireConvertToBuffer$2();
    		Object.defineProperty(exports, "convertToBuffer", { enumerable: true, get: function () { return convertToBuffer_1.convertToBuffer; } });
    		var isEmptyData_1 = requireIsEmptyData$4();
    		Object.defineProperty(exports, "isEmptyData", { enumerable: true, get: function () { return isEmptyData_1.isEmptyData; } });
    		var numToUint8_1 = requireNumToUint8$2();
    		Object.defineProperty(exports, "numToUint8", { enumerable: true, get: function () { return numToUint8_1.numToUint8; } });
    		var uint32ArrayFrom_1 = requireUint32ArrayFrom$2();
    		Object.defineProperty(exports, "uint32ArrayFrom", { enumerable: true, get: function () { return uint32ArrayFrom_1.uint32ArrayFrom; } });
    		
    	} (build$b));
    	return build$b;
    }

    var hasRequiredWebCryptoSha256$2;

    function requireWebCryptoSha256$2 () {
    	if (hasRequiredWebCryptoSha256$2) return webCryptoSha256$2;
    	hasRequiredWebCryptoSha256$2 = 1;
    	Object.defineProperty(webCryptoSha256$2, "__esModule", { value: true });
    	webCryptoSha256$2.Sha256 = void 0;
    	var util_1 = requireBuild$c();
    	var constants_1 = requireConstants$5();
    	var util_locate_window_1 = require$$5;
    	var Sha256 = /** @class */ (function () {
    	    function Sha256(secret) {
    	        this.toHash = new Uint8Array(0);
    	        this.secret = secret;
    	        this.reset();
    	    }
    	    Sha256.prototype.update = function (data) {
    	        if ((0, util_1.isEmptyData)(data)) {
    	            return;
    	        }
    	        var update = (0, util_1.convertToBuffer)(data);
    	        var typedArray = new Uint8Array(this.toHash.byteLength + update.byteLength);
    	        typedArray.set(this.toHash, 0);
    	        typedArray.set(update, this.toHash.byteLength);
    	        this.toHash = typedArray;
    	    };
    	    Sha256.prototype.digest = function () {
    	        var _this = this;
    	        if (this.key) {
    	            return this.key.then(function (key) {
    	                return (0, util_locate_window_1.locateWindow)()
    	                    .crypto.subtle.sign(constants_1.SHA_256_HMAC_ALGO, key, _this.toHash)
    	                    .then(function (data) { return new Uint8Array(data); });
    	            });
    	        }
    	        if ((0, util_1.isEmptyData)(this.toHash)) {
    	            return Promise.resolve(constants_1.EMPTY_DATA_SHA_256);
    	        }
    	        return Promise.resolve()
    	            .then(function () {
    	            return (0, util_locate_window_1.locateWindow)().crypto.subtle.digest(constants_1.SHA_256_HASH, _this.toHash);
    	        })
    	            .then(function (data) { return Promise.resolve(new Uint8Array(data)); });
    	    };
    	    Sha256.prototype.reset = function () {
    	        var _this = this;
    	        this.toHash = new Uint8Array(0);
    	        if (this.secret && this.secret !== void 0) {
    	            this.key = new Promise(function (resolve, reject) {
    	                (0, util_locate_window_1.locateWindow)()
    	                    .crypto.subtle.importKey("raw", (0, util_1.convertToBuffer)(_this.secret), constants_1.SHA_256_HMAC_ALGO, false, ["sign"])
    	                    .then(resolve, reject);
    	            });
    	            this.key.catch(function () { });
    	        }
    	    };
    	    return Sha256;
    	}());
    	webCryptoSha256$2.Sha256 = Sha256;
    	
    	return webCryptoSha256$2;
    }

    var build$a = {};

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics$8 = function(d, b) {
        extendStatics$8 = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics$8(d, b);
    };

    function __extends$8(d, b) {
        extendStatics$8(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign$8 = function() {
        __assign$8 = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign$8.apply(this, arguments);
    };

    function __rest$8(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate$8(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param$8(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata$8(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter$8(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator$8(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __createBinding$8(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }

    function __exportStar$8(m, exports) {
        for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values$8(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read$8(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread$8() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read$8(arguments[i]));
        return ar;
    }

    function __spreadArrays$8() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __await$8(v) {
        return this instanceof __await$8 ? (this.v = v, this) : new __await$8(v);
    }

    function __asyncGenerator$8(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await$8 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator$8(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await$8(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues$8(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values$8 === "function" ? __values$8(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject$8(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    }
    function __importStar$8(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault$8(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    function __classPrivateFieldGet$8(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }

    function __classPrivateFieldSet$8(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    var tslib_es6$8 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        get __assign () { return __assign$8; },
        __asyncDelegator: __asyncDelegator$8,
        __asyncGenerator: __asyncGenerator$8,
        __asyncValues: __asyncValues$8,
        __await: __await$8,
        __awaiter: __awaiter$8,
        __classPrivateFieldGet: __classPrivateFieldGet$8,
        __classPrivateFieldSet: __classPrivateFieldSet$8,
        __createBinding: __createBinding$8,
        __decorate: __decorate$8,
        __exportStar: __exportStar$8,
        __extends: __extends$8,
        __generator: __generator$8,
        __importDefault: __importDefault$8,
        __importStar: __importStar$8,
        __makeTemplateObject: __makeTemplateObject$8,
        __metadata: __metadata$8,
        __param: __param$8,
        __read: __read$8,
        __rest: __rest$8,
        __spread: __spread$8,
        __spreadArrays: __spreadArrays$8,
        __values: __values$8
    });

    var require$$0$8 = /*@__PURE__*/getAugmentedNamespace(tslib_es6$8);

    var jsSha256$2 = {};

    var constants$4 = {};

    var hasRequiredConstants$4;

    function requireConstants$4 () {
    	if (hasRequiredConstants$4) return constants$4;
    	hasRequiredConstants$4 = 1;
    	Object.defineProperty(constants$4, "__esModule", { value: true });
    	constants$4.MAX_HASHABLE_LENGTH = constants$4.INIT = constants$4.KEY = constants$4.DIGEST_LENGTH = constants$4.BLOCK_SIZE = void 0;
    	/**
    	 * @internal
    	 */
    	constants$4.BLOCK_SIZE = 64;
    	/**
    	 * @internal
    	 */
    	constants$4.DIGEST_LENGTH = 32;
    	/**
    	 * @internal
    	 */
    	constants$4.KEY = new Uint32Array([
    	    0x428a2f98,
    	    0x71374491,
    	    0xb5c0fbcf,
    	    0xe9b5dba5,
    	    0x3956c25b,
    	    0x59f111f1,
    	    0x923f82a4,
    	    0xab1c5ed5,
    	    0xd807aa98,
    	    0x12835b01,
    	    0x243185be,
    	    0x550c7dc3,
    	    0x72be5d74,
    	    0x80deb1fe,
    	    0x9bdc06a7,
    	    0xc19bf174,
    	    0xe49b69c1,
    	    0xefbe4786,
    	    0x0fc19dc6,
    	    0x240ca1cc,
    	    0x2de92c6f,
    	    0x4a7484aa,
    	    0x5cb0a9dc,
    	    0x76f988da,
    	    0x983e5152,
    	    0xa831c66d,
    	    0xb00327c8,
    	    0xbf597fc7,
    	    0xc6e00bf3,
    	    0xd5a79147,
    	    0x06ca6351,
    	    0x14292967,
    	    0x27b70a85,
    	    0x2e1b2138,
    	    0x4d2c6dfc,
    	    0x53380d13,
    	    0x650a7354,
    	    0x766a0abb,
    	    0x81c2c92e,
    	    0x92722c85,
    	    0xa2bfe8a1,
    	    0xa81a664b,
    	    0xc24b8b70,
    	    0xc76c51a3,
    	    0xd192e819,
    	    0xd6990624,
    	    0xf40e3585,
    	    0x106aa070,
    	    0x19a4c116,
    	    0x1e376c08,
    	    0x2748774c,
    	    0x34b0bcb5,
    	    0x391c0cb3,
    	    0x4ed8aa4a,
    	    0x5b9cca4f,
    	    0x682e6ff3,
    	    0x748f82ee,
    	    0x78a5636f,
    	    0x84c87814,
    	    0x8cc70208,
    	    0x90befffa,
    	    0xa4506ceb,
    	    0xbef9a3f7,
    	    0xc67178f2
    	]);
    	/**
    	 * @internal
    	 */
    	constants$4.INIT = [
    	    0x6a09e667,
    	    0xbb67ae85,
    	    0x3c6ef372,
    	    0xa54ff53a,
    	    0x510e527f,
    	    0x9b05688c,
    	    0x1f83d9ab,
    	    0x5be0cd19
    	];
    	/**
    	 * @internal
    	 */
    	constants$4.MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;
    	
    	return constants$4;
    }

    var RawSha256$2 = {};

    var hasRequiredRawSha256$2;

    function requireRawSha256$2 () {
    	if (hasRequiredRawSha256$2) return RawSha256$2;
    	hasRequiredRawSha256$2 = 1;
    	Object.defineProperty(RawSha256$2, "__esModule", { value: true });
    	RawSha256$2.RawSha256 = void 0;
    	var constants_1 = requireConstants$4();
    	/**
    	 * @internal
    	 */
    	var RawSha256 = /** @class */ (function () {
    	    function RawSha256() {
    	        this.state = Int32Array.from(constants_1.INIT);
    	        this.temp = new Int32Array(64);
    	        this.buffer = new Uint8Array(64);
    	        this.bufferLength = 0;
    	        this.bytesHashed = 0;
    	        /**
    	         * @internal
    	         */
    	        this.finished = false;
    	    }
    	    RawSha256.prototype.update = function (data) {
    	        if (this.finished) {
    	            throw new Error("Attempted to update an already finished hash.");
    	        }
    	        var position = 0;
    	        var byteLength = data.byteLength;
    	        this.bytesHashed += byteLength;
    	        if (this.bytesHashed * 8 > constants_1.MAX_HASHABLE_LENGTH) {
    	            throw new Error("Cannot hash more than 2^53 - 1 bits");
    	        }
    	        while (byteLength > 0) {
    	            this.buffer[this.bufferLength++] = data[position++];
    	            byteLength--;
    	            if (this.bufferLength === constants_1.BLOCK_SIZE) {
    	                this.hashBuffer();
    	                this.bufferLength = 0;
    	            }
    	        }
    	    };
    	    RawSha256.prototype.digest = function () {
    	        if (!this.finished) {
    	            var bitsHashed = this.bytesHashed * 8;
    	            var bufferView = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);
    	            var undecoratedLength = this.bufferLength;
    	            bufferView.setUint8(this.bufferLength++, 0x80);
    	            // Ensure the final block has enough room for the hashed length
    	            if (undecoratedLength % constants_1.BLOCK_SIZE >= constants_1.BLOCK_SIZE - 8) {
    	                for (var i = this.bufferLength; i < constants_1.BLOCK_SIZE; i++) {
    	                    bufferView.setUint8(i, 0);
    	                }
    	                this.hashBuffer();
    	                this.bufferLength = 0;
    	            }
    	            for (var i = this.bufferLength; i < constants_1.BLOCK_SIZE - 8; i++) {
    	                bufferView.setUint8(i, 0);
    	            }
    	            bufferView.setUint32(constants_1.BLOCK_SIZE - 8, Math.floor(bitsHashed / 0x100000000), true);
    	            bufferView.setUint32(constants_1.BLOCK_SIZE - 4, bitsHashed);
    	            this.hashBuffer();
    	            this.finished = true;
    	        }
    	        // The value in state is little-endian rather than big-endian, so flip
    	        // each word into a new Uint8Array
    	        var out = new Uint8Array(constants_1.DIGEST_LENGTH);
    	        for (var i = 0; i < 8; i++) {
    	            out[i * 4] = (this.state[i] >>> 24) & 0xff;
    	            out[i * 4 + 1] = (this.state[i] >>> 16) & 0xff;
    	            out[i * 4 + 2] = (this.state[i] >>> 8) & 0xff;
    	            out[i * 4 + 3] = (this.state[i] >>> 0) & 0xff;
    	        }
    	        return out;
    	    };
    	    RawSha256.prototype.hashBuffer = function () {
    	        var _a = this, buffer = _a.buffer, state = _a.state;
    	        var state0 = state[0], state1 = state[1], state2 = state[2], state3 = state[3], state4 = state[4], state5 = state[5], state6 = state[6], state7 = state[7];
    	        for (var i = 0; i < constants_1.BLOCK_SIZE; i++) {
    	            if (i < 16) {
    	                this.temp[i] =
    	                    ((buffer[i * 4] & 0xff) << 24) |
    	                        ((buffer[i * 4 + 1] & 0xff) << 16) |
    	                        ((buffer[i * 4 + 2] & 0xff) << 8) |
    	                        (buffer[i * 4 + 3] & 0xff);
    	            }
    	            else {
    	                var u = this.temp[i - 2];
    	                var t1_1 = ((u >>> 17) | (u << 15)) ^ ((u >>> 19) | (u << 13)) ^ (u >>> 10);
    	                u = this.temp[i - 15];
    	                var t2_1 = ((u >>> 7) | (u << 25)) ^ ((u >>> 18) | (u << 14)) ^ (u >>> 3);
    	                this.temp[i] =
    	                    ((t1_1 + this.temp[i - 7]) | 0) + ((t2_1 + this.temp[i - 16]) | 0);
    	            }
    	            var t1 = ((((((state4 >>> 6) | (state4 << 26)) ^
    	                ((state4 >>> 11) | (state4 << 21)) ^
    	                ((state4 >>> 25) | (state4 << 7))) +
    	                ((state4 & state5) ^ (~state4 & state6))) |
    	                0) +
    	                ((state7 + ((constants_1.KEY[i] + this.temp[i]) | 0)) | 0)) |
    	                0;
    	            var t2 = ((((state0 >>> 2) | (state0 << 30)) ^
    	                ((state0 >>> 13) | (state0 << 19)) ^
    	                ((state0 >>> 22) | (state0 << 10))) +
    	                ((state0 & state1) ^ (state0 & state2) ^ (state1 & state2))) |
    	                0;
    	            state7 = state6;
    	            state6 = state5;
    	            state5 = state4;
    	            state4 = (state3 + t1) | 0;
    	            state3 = state2;
    	            state2 = state1;
    	            state1 = state0;
    	            state0 = (t1 + t2) | 0;
    	        }
    	        state[0] += state0;
    	        state[1] += state1;
    	        state[2] += state2;
    	        state[3] += state3;
    	        state[4] += state4;
    	        state[5] += state5;
    	        state[6] += state6;
    	        state[7] += state7;
    	    };
    	    return RawSha256;
    	}());
    	RawSha256$2.RawSha256 = RawSha256;
    	
    	return RawSha256$2;
    }

    var hasRequiredJsSha256$2;

    function requireJsSha256$2 () {
    	if (hasRequiredJsSha256$2) return jsSha256$2;
    	hasRequiredJsSha256$2 = 1;
    	Object.defineProperty(jsSha256$2, "__esModule", { value: true });
    	jsSha256$2.Sha256 = void 0;
    	var tslib_1 = require$$0$8;
    	var constants_1 = requireConstants$4();
    	var RawSha256_1 = requireRawSha256$2();
    	var util_1 = requireBuild$c();
    	var Sha256 = /** @class */ (function () {
    	    function Sha256(secret) {
    	        this.secret = secret;
    	        this.hash = new RawSha256_1.RawSha256();
    	        this.reset();
    	    }
    	    Sha256.prototype.update = function (toHash) {
    	        if ((0, util_1.isEmptyData)(toHash) || this.error) {
    	            return;
    	        }
    	        try {
    	            this.hash.update((0, util_1.convertToBuffer)(toHash));
    	        }
    	        catch (e) {
    	            this.error = e;
    	        }
    	    };
    	    /* This synchronous method keeps compatibility
    	     * with the v2 aws-sdk.
    	     */
    	    Sha256.prototype.digestSync = function () {
    	        if (this.error) {
    	            throw this.error;
    	        }
    	        if (this.outer) {
    	            if (!this.outer.finished) {
    	                this.outer.update(this.hash.digest());
    	            }
    	            return this.outer.digest();
    	        }
    	        return this.hash.digest();
    	    };
    	    /* The underlying digest method here is synchronous.
    	     * To keep the same interface with the other hash functions
    	     * the default is to expose this as an async method.
    	     * However, it can sometimes be useful to have a sync method.
    	     */
    	    Sha256.prototype.digest = function () {
    	        return tslib_1.__awaiter(this, void 0, void 0, function () {
    	            return tslib_1.__generator(this, function (_a) {
    	                return [2 /*return*/, this.digestSync()];
    	            });
    	        });
    	    };
    	    Sha256.prototype.reset = function () {
    	        this.hash = new RawSha256_1.RawSha256();
    	        if (this.secret) {
    	            this.outer = new RawSha256_1.RawSha256();
    	            var inner = bufferFromSecret(this.secret);
    	            var outer = new Uint8Array(constants_1.BLOCK_SIZE);
    	            outer.set(inner);
    	            for (var i = 0; i < constants_1.BLOCK_SIZE; i++) {
    	                inner[i] ^= 0x36;
    	                outer[i] ^= 0x5c;
    	            }
    	            this.hash.update(inner);
    	            this.outer.update(outer);
    	            // overwrite the copied key in memory
    	            for (var i = 0; i < inner.byteLength; i++) {
    	                inner[i] = 0;
    	            }
    	        }
    	    };
    	    return Sha256;
    	}());
    	jsSha256$2.Sha256 = Sha256;
    	function bufferFromSecret(secret) {
    	    var input = (0, util_1.convertToBuffer)(secret);
    	    if (input.byteLength > constants_1.BLOCK_SIZE) {
    	        var bufferHash = new RawSha256_1.RawSha256();
    	        bufferHash.update(input);
    	        input = bufferHash.digest();
    	    }
    	    var buffer = new Uint8Array(constants_1.BLOCK_SIZE);
    	    buffer.set(input);
    	    return buffer;
    	}
    	
    	return jsSha256$2;
    }

    var hasRequiredBuild$b;

    function requireBuild$b () {
    	if (hasRequiredBuild$b) return build$a;
    	hasRequiredBuild$b = 1;
    	(function (exports) {
    		Object.defineProperty(exports, "__esModule", { value: true });
    		var tslib_1 = require$$0$8;
    		tslib_1.__exportStar(requireJsSha256$2(), exports);
    		
    	} (build$a));
    	return build$a;
    }

    var build$9 = {};

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics$7 = function(d, b) {
        extendStatics$7 = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics$7(d, b);
    };

    function __extends$7(d, b) {
        extendStatics$7(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign$7 = function() {
        __assign$7 = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign$7.apply(this, arguments);
    };

    function __rest$7(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate$7(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param$7(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata$7(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter$7(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator$7(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __createBinding$7(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }

    function __exportStar$7(m, exports) {
        for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values$7(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read$7(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread$7() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read$7(arguments[i]));
        return ar;
    }

    function __spreadArrays$7() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __await$7(v) {
        return this instanceof __await$7 ? (this.v = v, this) : new __await$7(v);
    }

    function __asyncGenerator$7(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await$7 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator$7(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await$7(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues$7(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values$7 === "function" ? __values$7(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject$7(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    }
    function __importStar$7(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault$7(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    function __classPrivateFieldGet$7(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }

    function __classPrivateFieldSet$7(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    var tslib_es6$7 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        get __assign () { return __assign$7; },
        __asyncDelegator: __asyncDelegator$7,
        __asyncGenerator: __asyncGenerator$7,
        __asyncValues: __asyncValues$7,
        __await: __await$7,
        __awaiter: __awaiter$7,
        __classPrivateFieldGet: __classPrivateFieldGet$7,
        __classPrivateFieldSet: __classPrivateFieldSet$7,
        __createBinding: __createBinding$7,
        __decorate: __decorate$7,
        __exportStar: __exportStar$7,
        __extends: __extends$7,
        __generator: __generator$7,
        __importDefault: __importDefault$7,
        __importStar: __importStar$7,
        __makeTemplateObject: __makeTemplateObject$7,
        __metadata: __metadata$7,
        __param: __param$7,
        __read: __read$7,
        __rest: __rest$7,
        __spread: __spread$7,
        __spreadArrays: __spreadArrays$7,
        __values: __values$7
    });

    var require$$0$7 = /*@__PURE__*/getAugmentedNamespace(tslib_es6$7);

    var supportsWebCrypto$2 = {};

    var hasRequiredSupportsWebCrypto$2;

    function requireSupportsWebCrypto$2 () {
    	if (hasRequiredSupportsWebCrypto$2) return supportsWebCrypto$2;
    	hasRequiredSupportsWebCrypto$2 = 1;
    	Object.defineProperty(supportsWebCrypto$2, "__esModule", { value: true });
    	supportsWebCrypto$2.supportsZeroByteGCM = supportsWebCrypto$2.supportsSubtleCrypto = supportsWebCrypto$2.supportsSecureRandom = supportsWebCrypto$2.supportsWebCrypto = void 0;
    	var tslib_1 = require$$0$7;
    	var subtleCryptoMethods = [
    	    "decrypt",
    	    "digest",
    	    "encrypt",
    	    "exportKey",
    	    "generateKey",
    	    "importKey",
    	    "sign",
    	    "verify"
    	];
    	function supportsWebCrypto(window) {
    	    if (supportsSecureRandom(window) &&
    	        typeof window.crypto.subtle === "object") {
    	        var subtle = window.crypto.subtle;
    	        return supportsSubtleCrypto(subtle);
    	    }
    	    return false;
    	}
    	supportsWebCrypto$2.supportsWebCrypto = supportsWebCrypto;
    	function supportsSecureRandom(window) {
    	    if (typeof window === "object" && typeof window.crypto === "object") {
    	        var getRandomValues = window.crypto.getRandomValues;
    	        return typeof getRandomValues === "function";
    	    }
    	    return false;
    	}
    	supportsWebCrypto$2.supportsSecureRandom = supportsSecureRandom;
    	function supportsSubtleCrypto(subtle) {
    	    return (subtle &&
    	        subtleCryptoMethods.every(function (methodName) { return typeof subtle[methodName] === "function"; }));
    	}
    	supportsWebCrypto$2.supportsSubtleCrypto = supportsSubtleCrypto;
    	function supportsZeroByteGCM(subtle) {
    	    return tslib_1.__awaiter(this, void 0, void 0, function () {
    	        var key, zeroByteAuthTag;
    	        return tslib_1.__generator(this, function (_b) {
    	            switch (_b.label) {
    	                case 0:
    	                    if (!supportsSubtleCrypto(subtle))
    	                        return [2 /*return*/, false];
    	                    _b.label = 1;
    	                case 1:
    	                    _b.trys.push([1, 4, , 5]);
    	                    return [4 /*yield*/, subtle.generateKey({ name: "AES-GCM", length: 128 }, false, ["encrypt"])];
    	                case 2:
    	                    key = _b.sent();
    	                    return [4 /*yield*/, subtle.encrypt({
    	                            name: "AES-GCM",
    	                            iv: new Uint8Array(Array(12)),
    	                            additionalData: new Uint8Array(Array(16)),
    	                            tagLength: 128
    	                        }, key, new Uint8Array(0))];
    	                case 3:
    	                    zeroByteAuthTag = _b.sent();
    	                    return [2 /*return*/, zeroByteAuthTag.byteLength === 16];
    	                case 4:
    	                    _b.sent();
    	                    return [2 /*return*/, false];
    	                case 5: return [2 /*return*/];
    	            }
    	        });
    	    });
    	}
    	supportsWebCrypto$2.supportsZeroByteGCM = supportsZeroByteGCM;
    	
    	return supportsWebCrypto$2;
    }

    var hasRequiredBuild$a;

    function requireBuild$a () {
    	if (hasRequiredBuild$a) return build$9;
    	hasRequiredBuild$a = 1;
    	(function (exports) {
    		Object.defineProperty(exports, "__esModule", { value: true });
    		var tslib_1 = require$$0$7;
    		tslib_1.__exportStar(requireSupportsWebCrypto$2(), exports);
    		
    	} (build$9));
    	return build$9;
    }

    var build$8 = {};

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics$6 = function(d, b) {
        extendStatics$6 = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics$6(d, b);
    };

    function __extends$6(d, b) {
        extendStatics$6(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign$6 = function() {
        __assign$6 = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign$6.apply(this, arguments);
    };

    function __rest$6(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate$6(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param$6(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata$6(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter$6(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator$6(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __createBinding$6(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }

    function __exportStar$6(m, exports) {
        for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values$6(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read$6(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread$6() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read$6(arguments[i]));
        return ar;
    }

    function __spreadArrays$6() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __await$6(v) {
        return this instanceof __await$6 ? (this.v = v, this) : new __await$6(v);
    }

    function __asyncGenerator$6(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await$6 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator$6(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await$6(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues$6(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values$6 === "function" ? __values$6(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject$6(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    }
    function __importStar$6(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault$6(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    function __classPrivateFieldGet$6(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }

    function __classPrivateFieldSet$6(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    var tslib_es6$6 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        get __assign () { return __assign$6; },
        __asyncDelegator: __asyncDelegator$6,
        __asyncGenerator: __asyncGenerator$6,
        __asyncValues: __asyncValues$6,
        __await: __await$6,
        __awaiter: __awaiter$6,
        __classPrivateFieldGet: __classPrivateFieldGet$6,
        __classPrivateFieldSet: __classPrivateFieldSet$6,
        __createBinding: __createBinding$6,
        __decorate: __decorate$6,
        __exportStar: __exportStar$6,
        __extends: __extends$6,
        __generator: __generator$6,
        __importDefault: __importDefault$6,
        __importStar: __importStar$6,
        __makeTemplateObject: __makeTemplateObject$6,
        __metadata: __metadata$6,
        __param: __param$6,
        __read: __read$6,
        __rest: __rest$6,
        __spread: __spread$6,
        __spreadArrays: __spreadArrays$6,
        __values: __values$6
    });

    var require$$0$6 = /*@__PURE__*/getAugmentedNamespace(tslib_es6$6);

    var CryptoOperation = {};

    var hasRequiredCryptoOperation;

    function requireCryptoOperation () {
    	if (hasRequiredCryptoOperation) return CryptoOperation;
    	hasRequiredCryptoOperation = 1;
    	Object.defineProperty(CryptoOperation, "__esModule", { value: true });
    	
    	return CryptoOperation;
    }

    var Key = {};

    var hasRequiredKey;

    function requireKey () {
    	if (hasRequiredKey) return Key;
    	hasRequiredKey = 1;
    	Object.defineProperty(Key, "__esModule", { value: true });
    	
    	return Key;
    }

    var KeyOperation = {};

    var hasRequiredKeyOperation;

    function requireKeyOperation () {
    	if (hasRequiredKeyOperation) return KeyOperation;
    	hasRequiredKeyOperation = 1;
    	Object.defineProperty(KeyOperation, "__esModule", { value: true });
    	
    	return KeyOperation;
    }

    var MsSubtleCrypto = {};

    var hasRequiredMsSubtleCrypto;

    function requireMsSubtleCrypto () {
    	if (hasRequiredMsSubtleCrypto) return MsSubtleCrypto;
    	hasRequiredMsSubtleCrypto = 1;
    	Object.defineProperty(MsSubtleCrypto, "__esModule", { value: true });
    	
    	return MsSubtleCrypto;
    }

    var MsWindow = {};

    var hasRequiredMsWindow;

    function requireMsWindow () {
    	if (hasRequiredMsWindow) return MsWindow;
    	hasRequiredMsWindow = 1;
    	Object.defineProperty(MsWindow, "__esModule", { value: true });
    	MsWindow.isMsWindow = void 0;
    	var msSubtleCryptoMethods = [
    	    "decrypt",
    	    "digest",
    	    "encrypt",
    	    "exportKey",
    	    "generateKey",
    	    "importKey",
    	    "sign",
    	    "verify"
    	];
    	function quacksLikeAnMsWindow(window) {
    	    return "MSInputMethodContext" in window && "msCrypto" in window;
    	}
    	/**
    	 * Determines if the provided window is (or is like) the window object one would
    	 * expect to encounter in Internet Explorer 11.
    	 */
    	function isMsWindow(window) {
    	    if (quacksLikeAnMsWindow(window) && window.msCrypto.subtle !== undefined) {
    	        var _a = window.msCrypto, getRandomValues = _a.getRandomValues, subtle_1 = _a.subtle;
    	        return msSubtleCryptoMethods
    	            .map(function (methodName) { return subtle_1[methodName]; })
    	            .concat(getRandomValues)
    	            .every(function (method) { return typeof method === "function"; });
    	    }
    	    return false;
    	}
    	MsWindow.isMsWindow = isMsWindow;
    	
    	return MsWindow;
    }

    var hasRequiredBuild$9;

    function requireBuild$9 () {
    	if (hasRequiredBuild$9) return build$8;
    	hasRequiredBuild$9 = 1;
    	(function (exports) {
    		Object.defineProperty(exports, "__esModule", { value: true });
    		var tslib_1 = require$$0$6;
    		tslib_1.__exportStar(requireCryptoOperation(), exports);
    		tslib_1.__exportStar(requireKey(), exports);
    		tslib_1.__exportStar(requireKeyOperation(), exports);
    		tslib_1.__exportStar(requireMsSubtleCrypto(), exports);
    		tslib_1.__exportStar(requireMsWindow(), exports);
    		
    	} (build$8));
    	return build$8;
    }

    var hasRequiredCrossPlatformSha256$2;

    function requireCrossPlatformSha256$2 () {
    	if (hasRequiredCrossPlatformSha256$2) return crossPlatformSha256$2;
    	hasRequiredCrossPlatformSha256$2 = 1;
    	Object.defineProperty(crossPlatformSha256$2, "__esModule", { value: true });
    	crossPlatformSha256$2.Sha256 = void 0;
    	var ie11Sha256_1 = requireIe11Sha256$2();
    	var webCryptoSha256_1 = requireWebCryptoSha256$2();
    	var sha256_js_1 = requireBuild$b();
    	var supports_web_crypto_1 = requireBuild$a();
    	var ie11_detection_1 = requireBuild$9();
    	var util_locate_window_1 = require$$5;
    	var util_1 = requireBuild$c();
    	var Sha256 = /** @class */ (function () {
    	    function Sha256(secret) {
    	        if ((0, supports_web_crypto_1.supportsWebCrypto)((0, util_locate_window_1.locateWindow)())) {
    	            this.hash = new webCryptoSha256_1.Sha256(secret);
    	        }
    	        else if ((0, ie11_detection_1.isMsWindow)((0, util_locate_window_1.locateWindow)())) {
    	            this.hash = new ie11Sha256_1.Sha256(secret);
    	        }
    	        else {
    	            this.hash = new sha256_js_1.Sha256(secret);
    	        }
    	    }
    	    Sha256.prototype.update = function (data, encoding) {
    	        this.hash.update((0, util_1.convertToBuffer)(data));
    	    };
    	    Sha256.prototype.digest = function () {
    	        return this.hash.digest();
    	    };
    	    Sha256.prototype.reset = function () {
    	        this.hash.reset();
    	    };
    	    return Sha256;
    	}());
    	crossPlatformSha256$2.Sha256 = Sha256;
    	
    	return crossPlatformSha256$2;
    }

    var hasRequiredBuild$8;

    function requireBuild$8 () {
    	if (hasRequiredBuild$8) return build$c;
    	hasRequiredBuild$8 = 1;
    	(function (exports) {
    		Object.defineProperty(exports, "__esModule", { value: true });
    		exports.WebCryptoSha256 = exports.Ie11Sha256 = void 0;
    		var tslib_1 = require$$0$a;
    		tslib_1.__exportStar(requireCrossPlatformSha256$2(), exports);
    		var ie11Sha256_1 = requireIe11Sha256$2();
    		Object.defineProperty(exports, "Ie11Sha256", { enumerable: true, get: function () { return ie11Sha256_1.Sha256; } });
    		var webCryptoSha256_1 = requireWebCryptoSha256$2();
    		Object.defineProperty(exports, "WebCryptoSha256", { enumerable: true, get: function () { return webCryptoSha256_1.Sha256; } });
    		
    	} (build$c));
    	return build$c;
    }

    var buildExports$2 = requireBuild$8();

    const defaultUserAgent$2 = ({ serviceId, clientVersion }) => async () => {
        const parsedUA = typeof window !== "undefined" && window?.navigator?.userAgent
            ? bowser.parse(window.navigator.userAgent)
            : undefined;
        const sections = [
            ["aws-sdk-js", clientVersion],
            ["ua", "2.0"],
            [`os/${parsedUA?.os?.name || "other"}`, parsedUA?.os?.version],
            ["lang/js"],
            ["md/browser", `${parsedUA?.browser?.name ?? "unknown"}_${parsedUA?.browser?.version ?? "unknown"}`],
        ];
        if (serviceId) {
            sections.push([`api/${serviceId}`, clientVersion]);
        }
        return sections;
    };

    var SelectorType$2;
    (function (SelectorType) {
        SelectorType["ENV"] = "env";
        SelectorType["CONFIG"] = "shared config entry";
    })(SelectorType$2 || (SelectorType$2 = {}));

    const DEFAULT_USE_DUALSTACK_ENDPOINT$2 = false;

    const DEFAULT_USE_FIPS_ENDPOINT$2 = false;

    var HttpAuthLocation$3;
    (function (HttpAuthLocation) {
        HttpAuthLocation["HEADER"] = "header";
        HttpAuthLocation["QUERY"] = "query";
    })(HttpAuthLocation$3 || (HttpAuthLocation$3 = {}));

    var HttpApiKeyAuthLocation$3;
    (function (HttpApiKeyAuthLocation) {
        HttpApiKeyAuthLocation["HEADER"] = "header";
        HttpApiKeyAuthLocation["QUERY"] = "query";
    })(HttpApiKeyAuthLocation$3 || (HttpApiKeyAuthLocation$3 = {}));

    var EndpointURLScheme$3;
    (function (EndpointURLScheme) {
        EndpointURLScheme["HTTP"] = "http";
        EndpointURLScheme["HTTPS"] = "https";
    })(EndpointURLScheme$3 || (EndpointURLScheme$3 = {}));

    var AlgorithmId$3;
    (function (AlgorithmId) {
        AlgorithmId["MD5"] = "md5";
        AlgorithmId["CRC32"] = "crc32";
        AlgorithmId["CRC32C"] = "crc32c";
        AlgorithmId["SHA1"] = "sha1";
        AlgorithmId["SHA256"] = "sha256";
    })(AlgorithmId$3 || (AlgorithmId$3 = {}));

    var FieldPosition$3;
    (function (FieldPosition) {
        FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
        FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
    })(FieldPosition$3 || (FieldPosition$3 = {}));

    const SMITHY_CONTEXT_KEY$2 = "__smithy_context";

    var IniSectionType$3;
    (function (IniSectionType) {
        IniSectionType["PROFILE"] = "profile";
        IniSectionType["SSO_SESSION"] = "sso-session";
        IniSectionType["SERVICES"] = "services";
    })(IniSectionType$3 || (IniSectionType$3 = {}));

    var RequestHandlerProtocol$3;
    (function (RequestHandlerProtocol) {
        RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
        RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
        RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
    })(RequestHandlerProtocol$3 || (RequestHandlerProtocol$3 = {}));

    const normalizeProvider$3 = (input) => {
        if (typeof input === "function")
            return input;
        const promisified = Promise.resolve(input);
        return () => promisified;
    };

    const getEndpointFromRegion$2 = async (input) => {
        const { tls = true } = input;
        const region = await input.region();
        const dnsHostRegex = new RegExp(/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/);
        if (!dnsHostRegex.test(region)) {
            throw new Error("Invalid region in client config");
        }
        const useDualstackEndpoint = await input.useDualstackEndpoint();
        const useFipsEndpoint = await input.useFipsEndpoint();
        const { hostname } = (await input.regionInfoProvider(region, { useDualstackEndpoint, useFipsEndpoint })) ?? {};
        if (!hostname) {
            throw new Error("Cannot resolve hostname from client config");
        }
        return input.urlParser(`${tls ? "https:" : "http:"}//${hostname}`);
    };

    const resolveEndpointsConfig$2 = (input) => {
        const useDualstackEndpoint = normalizeProvider$3(input.useDualstackEndpoint ?? false);
        const { endpoint, useFipsEndpoint, urlParser } = input;
        return {
            ...input,
            tls: input.tls ?? true,
            endpoint: endpoint
                ? normalizeProvider$3(typeof endpoint === "string" ? urlParser(endpoint) : endpoint)
                : () => getEndpointFromRegion$2({ ...input, useDualstackEndpoint, useFipsEndpoint }),
            isCustomEndpoint: !!endpoint,
            useDualstackEndpoint,
        };
    };

    const isFipsRegion$2 = (region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));

    const getRealRegion$2 = (region) => isFipsRegion$2(region)
        ? ["fips-aws-global", "aws-fips"].includes(region)
            ? "us-east-1"
            : region.replace(/fips-(dkr-|prod-)?|-fips/, "")
        : region;

    const resolveRegionConfig$2 = (input) => {
        const { region, useFipsEndpoint } = input;
        if (!region) {
            throw new Error("Region is missing");
        }
        return {
            ...input,
            region: async () => {
                if (typeof region === "string") {
                    return getRealRegion$2(region);
                }
                const providedRegion = await region();
                return getRealRegion$2(providedRegion);
            },
            useFipsEndpoint: async () => {
                const providedRegion = typeof region === "string" ? region : await region();
                if (isFipsRegion$2(providedRegion)) {
                    return true;
                }
                return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
            },
        };
    };

    const getHostnameFromVariants$2 = (variants = [], { useFipsEndpoint, useDualstackEndpoint }) => variants.find(({ tags }) => useFipsEndpoint === tags.includes("fips") && useDualstackEndpoint === tags.includes("dualstack"))?.hostname;

    const getResolvedHostname$2 = (resolvedRegion, { regionHostname, partitionHostname }) => regionHostname
        ? regionHostname
        : partitionHostname
            ? partitionHostname.replace("{region}", resolvedRegion)
            : undefined;

    const getResolvedPartition$2 = (region, { partitionHash }) => Object.keys(partitionHash || {}).find((key) => partitionHash[key].regions.includes(region)) ?? "aws";

    const getResolvedSigningRegion$2 = (hostname, { signingRegion, regionRegex, useFipsEndpoint }) => {
        if (signingRegion) {
            return signingRegion;
        }
        else if (useFipsEndpoint) {
            const regionRegexJs = regionRegex.replace("\\\\", "\\").replace(/^\^/g, "\\.").replace(/\$$/g, "\\.");
            const regionRegexmatchArray = hostname.match(regionRegexJs);
            if (regionRegexmatchArray) {
                return regionRegexmatchArray[0].slice(1, -1);
            }
        }
    };

    const getRegionInfo$2 = (region, { useFipsEndpoint = false, useDualstackEndpoint = false, signingService, regionHash, partitionHash, }) => {
        const partition = getResolvedPartition$2(region, { partitionHash });
        const resolvedRegion = region in regionHash ? region : partitionHash[partition]?.endpoint ?? region;
        const hostnameOptions = { useFipsEndpoint, useDualstackEndpoint };
        const regionHostname = getHostnameFromVariants$2(regionHash[resolvedRegion]?.variants, hostnameOptions);
        const partitionHostname = getHostnameFromVariants$2(partitionHash[partition]?.variants, hostnameOptions);
        const hostname = getResolvedHostname$2(resolvedRegion, { regionHostname, partitionHostname });
        if (hostname === undefined) {
            throw new Error(`Endpoint resolution failed for: ${{ resolvedRegion, useFipsEndpoint, useDualstackEndpoint }}`);
        }
        const signingRegion = getResolvedSigningRegion$2(hostname, {
            signingRegion: regionHash[resolvedRegion]?.signingRegion,
            regionRegex: partitionHash[partition].regionRegex,
            useFipsEndpoint,
        });
        return {
            partition,
            signingService,
            hostname,
            ...(signingRegion && { signingRegion }),
            ...(regionHash[resolvedRegion]?.signingService && {
                signingService: regionHash[resolvedRegion].signingService,
            }),
        };
    };

    const getHttpHandlerExtensionConfiguration$2 = (runtimeConfig) => {
        let httpHandler = runtimeConfig.httpHandler;
        return {
            setHttpHandler(handler) {
                httpHandler = handler;
            },
            httpHandler() {
                return httpHandler;
            },
            updateHttpClientConfig(key, value) {
                httpHandler.updateHttpClientConfig(key, value);
            },
            httpHandlerConfigs() {
                return httpHandler.httpHandlerConfigs();
            },
        };
    };
    const resolveHttpHandlerRuntimeConfig$2 = (httpHandlerExtensionConfiguration) => {
        return {
            httpHandler: httpHandlerExtensionConfiguration.httpHandler(),
        };
    };

    let HttpRequest$3 = class HttpRequest {
        constructor(options) {
            this.method = options.method || "GET";
            this.hostname = options.hostname || "localhost";
            this.port = options.port;
            this.query = options.query || {};
            this.headers = options.headers || {};
            this.body = options.body;
            this.protocol = options.protocol
                ? options.protocol.slice(-1) !== ":"
                    ? `${options.protocol}:`
                    : options.protocol
                : "https:";
            this.path = options.path ? (options.path.charAt(0) !== "/" ? `/${options.path}` : options.path) : "/";
            this.username = options.username;
            this.password = options.password;
            this.fragment = options.fragment;
        }
        static isInstance(request) {
            if (!request)
                return false;
            const req = request;
            return ("method" in req &&
                "protocol" in req &&
                "hostname" in req &&
                "path" in req &&
                typeof req["query"] === "object" &&
                typeof req["headers"] === "object");
        }
        clone() {
            const cloned = new HttpRequest({
                ...this,
                headers: { ...this.headers },
            });
            if (cloned.query)
                cloned.query = cloneQuery$4(cloned.query);
            return cloned;
        }
    };
    function cloneQuery$4(query) {
        return Object.keys(query).reduce((carry, paramName) => {
            const param = query[paramName];
            return {
                ...carry,
                [paramName]: Array.isArray(param) ? [...param] : param,
            };
        }, {});
    }

    let HttpResponse$3 = class HttpResponse {
        constructor(options) {
            this.statusCode = options.statusCode;
            this.reason = options.reason;
            this.headers = options.headers || {};
            this.body = options.body;
        }
        static isInstance(response) {
            if (!response)
                return false;
            const resp = response;
            return typeof resp.statusCode === "number" && typeof resp.headers === "object";
        }
    };

    const escapeUri$3 = (uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode$3);
    const hexEncode$3 = (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`;

    function buildQueryString$2(query) {
        const parts = [];
        for (let key of Object.keys(query).sort()) {
            const value = query[key];
            key = escapeUri$3(key);
            if (Array.isArray(value)) {
                for (let i = 0, iLen = value.length; i < iLen; i++) {
                    parts.push(`${key}=${escapeUri$3(value[i])}`);
                }
            }
            else {
                let qsEntry = key;
                if (value || typeof value === "string") {
                    qsEntry += `=${escapeUri$3(value)}`;
                }
                parts.push(qsEntry);
            }
        }
        return parts.join("&");
    }

    function requestTimeout$2(timeoutInMs = 0) {
        return new Promise((resolve, reject) => {
            if (timeoutInMs) {
                setTimeout(() => {
                    const timeoutError = new Error(`Request did not complete within ${timeoutInMs} ms`);
                    timeoutError.name = "TimeoutError";
                    reject(timeoutError);
                }, timeoutInMs);
            }
        });
    }

    const keepAliveSupport$2 = {
        supported: Boolean(typeof Request !== "undefined" && "keepalive" in new Request("https://[::1]")),
    };
    let FetchHttpHandler$2 = class FetchHttpHandler {
        static create(instanceOrOptions) {
            if (typeof instanceOrOptions?.handle === "function") {
                return instanceOrOptions;
            }
            return new FetchHttpHandler(instanceOrOptions);
        }
        constructor(options) {
            if (typeof options === "function") {
                this.configProvider = options().then((opts) => opts || {});
            }
            else {
                this.config = options ?? {};
                this.configProvider = Promise.resolve(this.config);
            }
        }
        destroy() {
        }
        async handle(request, { abortSignal } = {}) {
            if (!this.config) {
                this.config = await this.configProvider;
            }
            const requestTimeoutInMs = this.config.requestTimeout;
            const keepAlive = this.config.keepAlive === true;
            if (abortSignal?.aborted) {
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                return Promise.reject(abortError);
            }
            let path = request.path;
            const queryString = buildQueryString$2(request.query || {});
            if (queryString) {
                path += `?${queryString}`;
            }
            if (request.fragment) {
                path += `#${request.fragment}`;
            }
            let auth = "";
            if (request.username != null || request.password != null) {
                const username = request.username ?? "";
                const password = request.password ?? "";
                auth = `${username}:${password}@`;
            }
            const { port, method } = request;
            const url = `${request.protocol}//${auth}${request.hostname}${port ? `:${port}` : ""}${path}`;
            const body = method === "GET" || method === "HEAD" ? undefined : request.body;
            const requestOptions = { body, headers: new Headers(request.headers), method: method };
            if (typeof AbortController !== "undefined") {
                requestOptions["signal"] = abortSignal;
            }
            if (keepAliveSupport$2.supported) {
                requestOptions["keepalive"] = keepAlive;
            }
            const fetchRequest = new Request(url, requestOptions);
            const raceOfPromises = [
                fetch(fetchRequest).then((response) => {
                    const fetchHeaders = response.headers;
                    const transformedHeaders = {};
                    for (const pair of fetchHeaders.entries()) {
                        transformedHeaders[pair[0]] = pair[1];
                    }
                    const hasReadableStream = response.body != undefined;
                    if (!hasReadableStream) {
                        return response.blob().then((body) => ({
                            response: new HttpResponse$3({
                                headers: transformedHeaders,
                                reason: response.statusText,
                                statusCode: response.status,
                                body,
                            }),
                        }));
                    }
                    return {
                        response: new HttpResponse$3({
                            headers: transformedHeaders,
                            reason: response.statusText,
                            statusCode: response.status,
                            body: response.body,
                        }),
                    };
                }),
                requestTimeout$2(requestTimeoutInMs),
            ];
            if (abortSignal) {
                raceOfPromises.push(new Promise((resolve, reject) => {
                    abortSignal.onabort = () => {
                        const abortError = new Error("Request aborted");
                        abortError.name = "AbortError";
                        reject(abortError);
                    };
                }));
            }
            return Promise.race(raceOfPromises);
        }
        updateHttpClientConfig(key, value) {
            this.config = undefined;
            this.configProvider = this.configProvider.then((config) => {
                config[key] = value;
                return config;
            });
        }
        httpHandlerConfigs() {
            return this.config ?? {};
        }
    };

    const alphabetByEncoding$2 = {};
    const alphabetByValue$2 = new Array(64);
    for (let i = 0, start = "A".charCodeAt(0), limit = "Z".charCodeAt(0); i + start <= limit; i++) {
        const char = String.fromCharCode(i + start);
        alphabetByEncoding$2[char] = i;
        alphabetByValue$2[i] = char;
    }
    for (let i = 0, start = "a".charCodeAt(0), limit = "z".charCodeAt(0); i + start <= limit; i++) {
        const char = String.fromCharCode(i + start);
        const index = i + 26;
        alphabetByEncoding$2[char] = index;
        alphabetByValue$2[index] = char;
    }
    for (let i = 0; i < 10; i++) {
        alphabetByEncoding$2[i.toString(10)] = i + 52;
        const char = i.toString(10);
        const index = i + 52;
        alphabetByEncoding$2[char] = index;
        alphabetByValue$2[index] = char;
    }
    alphabetByEncoding$2["+"] = 62;
    alphabetByValue$2[62] = "+";
    alphabetByEncoding$2["/"] = 63;
    alphabetByValue$2[63] = "/";
    const bitsPerLetter$2 = 6;
    const bitsPerByte$2 = 8;
    const maxLetterValue$2 = 0b111111;

    const fromBase64$2 = (input) => {
        let totalByteLength = (input.length / 4) * 3;
        if (input.slice(-2) === "==") {
            totalByteLength -= 2;
        }
        else if (input.slice(-1) === "=") {
            totalByteLength--;
        }
        const out = new ArrayBuffer(totalByteLength);
        const dataView = new DataView(out);
        for (let i = 0; i < input.length; i += 4) {
            let bits = 0;
            let bitLength = 0;
            for (let j = i, limit = i + 3; j <= limit; j++) {
                if (input[j] !== "=") {
                    if (!(input[j] in alphabetByEncoding$2)) {
                        throw new TypeError(`Invalid character ${input[j]} in base64 string.`);
                    }
                    bits |= alphabetByEncoding$2[input[j]] << ((limit - j) * bitsPerLetter$2);
                    bitLength += bitsPerLetter$2;
                }
                else {
                    bits >>= bitsPerLetter$2;
                }
            }
            const chunkOffset = (i / 4) * 3;
            bits >>= bitLength % bitsPerByte$2;
            const byteLength = Math.floor(bitLength / bitsPerByte$2);
            for (let k = 0; k < byteLength; k++) {
                const offset = (byteLength - k - 1) * bitsPerByte$2;
                dataView.setUint8(chunkOffset + k, (bits & (255 << offset)) >> offset);
            }
        }
        return new Uint8Array(out);
    };

    const fromUtf8$3 = (input) => new TextEncoder().encode(input);

    const toUtf8$2 = (input) => {
        if (typeof input === "string") {
            return input;
        }
        if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
            throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
        }
        return new TextDecoder("utf-8").decode(input);
    };

    function toBase64$2(_input) {
        let input;
        if (typeof _input === "string") {
            input = fromUtf8$3(_input);
        }
        else {
            input = _input;
        }
        const isArrayLike = typeof input === "object" && typeof input.length === "number";
        const isUint8Array = typeof input === "object" &&
            typeof input.byteOffset === "number" &&
            typeof input.byteLength === "number";
        if (!isArrayLike && !isUint8Array) {
            throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
        }
        let str = "";
        for (let i = 0; i < input.length; i += 3) {
            let bits = 0;
            let bitLength = 0;
            for (let j = i, limit = Math.min(i + 3, input.length); j < limit; j++) {
                bits |= input[j] << ((limit - j - 1) * bitsPerByte$2);
                bitLength += bitsPerByte$2;
            }
            const bitClusterCount = Math.ceil(bitLength / bitsPerLetter$2);
            bits <<= bitClusterCount * bitsPerLetter$2 - bitLength;
            for (let k = 1; k <= bitClusterCount; k++) {
                const offset = (bitClusterCount - k) * bitsPerLetter$2;
                str += alphabetByValue$2[(bits & (maxLetterValue$2 << offset)) >> offset];
            }
            str += "==".slice(0, 4 - bitClusterCount);
        }
        return str;
    }

    const streamCollector$2 = (stream) => {
        if (typeof Blob === "function" && stream instanceof Blob) {
            return collectBlob$2(stream);
        }
        return collectStream$2(stream);
    };
    async function collectBlob$2(blob) {
        const base64 = await readToBase64$2(blob);
        const arrayBuffer = fromBase64$2(base64);
        return new Uint8Array(arrayBuffer);
    }
    async function collectStream$2(stream) {
        let res = new Uint8Array(0);
        const reader = stream.getReader();
        let isDone = false;
        while (!isDone) {
            const { done, value } = await reader.read();
            if (value) {
                const prior = res;
                res = new Uint8Array(prior.length + value.length);
                res.set(prior);
                res.set(value, prior.length);
            }
            isDone = done;
        }
        return res;
    }
    function readToBase64$2(blob) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => {
                if (reader.readyState !== 2) {
                    return reject(new Error("Reader aborted too early"));
                }
                const result = (reader.result ?? "");
                const commaIndex = result.indexOf(",");
                const dataOffset = commaIndex > -1 ? commaIndex + 1 : result.length;
                resolve(result.substring(dataOffset));
            };
            reader.onabort = () => reject(new Error("Read aborted"));
            reader.onerror = () => reject(reader.error);
            reader.readAsDataURL(blob);
        });
    }

    const invalidProvider$2 = (message) => () => Promise.reject(message);

    const TEXT_ENCODER$2 = typeof TextEncoder == "function" ? new TextEncoder() : null;
    const calculateBodyLength$2 = (body) => {
        if (typeof body === "string") {
            if (TEXT_ENCODER$2) {
                return TEXT_ENCODER$2.encode(body).byteLength;
            }
            let len = body.length;
            for (let i = len - 1; i >= 0; i--) {
                const code = body.charCodeAt(i);
                if (code > 0x7f && code <= 0x7ff)
                    len++;
                else if (code > 0x7ff && code <= 0xffff)
                    len += 2;
                if (code >= 0xdc00 && code <= 0xdfff)
                    i--;
            }
            return len;
        }
        else if (typeof body.byteLength === "number") {
            return body.byteLength;
        }
        else if (typeof body.size === "number") {
            return body.size;
        }
        throw new Error(`Body Length computation failed for ${body}`);
    };

    var RETRY_MODES$2;
    (function (RETRY_MODES) {
        RETRY_MODES["STANDARD"] = "standard";
        RETRY_MODES["ADAPTIVE"] = "adaptive";
    })(RETRY_MODES$2 || (RETRY_MODES$2 = {}));
    const DEFAULT_MAX_ATTEMPTS$2 = 3;
    const DEFAULT_RETRY_MODE$2 = RETRY_MODES$2.STANDARD;

    const THROTTLING_ERROR_CODES$2 = [
        "BandwidthLimitExceeded",
        "EC2ThrottledException",
        "LimitExceededException",
        "PriorRequestNotComplete",
        "ProvisionedThroughputExceededException",
        "RequestLimitExceeded",
        "RequestThrottled",
        "RequestThrottledException",
        "SlowDown",
        "ThrottledException",
        "Throttling",
        "ThrottlingException",
        "TooManyRequestsException",
        "TransactionInProgressException",
    ];
    const TRANSIENT_ERROR_CODES$2 = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"];
    const TRANSIENT_ERROR_STATUS_CODES$2 = [500, 502, 503, 504];
    const NODEJS_TIMEOUT_ERROR_CODES$2 = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"];

    const isClockSkewCorrectedError$2 = (error) => error.$metadata?.clockSkewCorrected;
    const isThrottlingError$2 = (error) => error.$metadata?.httpStatusCode === 429 ||
        THROTTLING_ERROR_CODES$2.includes(error.name) ||
        error.$retryable?.throttling == true;
    const isTransientError$2 = (error) => isClockSkewCorrectedError$2(error) ||
        TRANSIENT_ERROR_CODES$2.includes(error.name) ||
        NODEJS_TIMEOUT_ERROR_CODES$2.includes(error?.code || "") ||
        TRANSIENT_ERROR_STATUS_CODES$2.includes(error.$metadata?.httpStatusCode || 0);
    const isServerError$2 = (error) => {
        if (error.$metadata?.httpStatusCode !== undefined) {
            const statusCode = error.$metadata.httpStatusCode;
            if (500 <= statusCode && statusCode <= 599 && !isTransientError$2(error)) {
                return true;
            }
            return false;
        }
        return false;
    };

    let DefaultRateLimiter$2 = class DefaultRateLimiter {
        constructor(options) {
            this.currentCapacity = 0;
            this.enabled = false;
            this.lastMaxRate = 0;
            this.measuredTxRate = 0;
            this.requestCount = 0;
            this.lastTimestamp = 0;
            this.timeWindow = 0;
            this.beta = options?.beta ?? 0.7;
            this.minCapacity = options?.minCapacity ?? 1;
            this.minFillRate = options?.minFillRate ?? 0.5;
            this.scaleConstant = options?.scaleConstant ?? 0.4;
            this.smooth = options?.smooth ?? 0.8;
            const currentTimeInSeconds = this.getCurrentTimeInSeconds();
            this.lastThrottleTime = currentTimeInSeconds;
            this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());
            this.fillRate = this.minFillRate;
            this.maxCapacity = this.minCapacity;
        }
        getCurrentTimeInSeconds() {
            return Date.now() / 1000;
        }
        async getSendToken() {
            return this.acquireTokenBucket(1);
        }
        async acquireTokenBucket(amount) {
            if (!this.enabled) {
                return;
            }
            this.refillTokenBucket();
            if (amount > this.currentCapacity) {
                const delay = ((amount - this.currentCapacity) / this.fillRate) * 1000;
                await new Promise((resolve) => setTimeout(resolve, delay));
            }
            this.currentCapacity = this.currentCapacity - amount;
        }
        refillTokenBucket() {
            const timestamp = this.getCurrentTimeInSeconds();
            if (!this.lastTimestamp) {
                this.lastTimestamp = timestamp;
                return;
            }
            const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;
            this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);
            this.lastTimestamp = timestamp;
        }
        updateClientSendingRate(response) {
            let calculatedRate;
            this.updateMeasuredRate();
            if (isThrottlingError$2(response)) {
                const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);
                this.lastMaxRate = rateToUse;
                this.calculateTimeWindow();
                this.lastThrottleTime = this.getCurrentTimeInSeconds();
                calculatedRate = this.cubicThrottle(rateToUse);
                this.enableTokenBucket();
            }
            else {
                this.calculateTimeWindow();
                calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());
            }
            const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);
            this.updateTokenBucketRate(newRate);
        }
        calculateTimeWindow() {
            this.timeWindow = this.getPrecise(Math.pow((this.lastMaxRate * (1 - this.beta)) / this.scaleConstant, 1 / 3));
        }
        cubicThrottle(rateToUse) {
            return this.getPrecise(rateToUse * this.beta);
        }
        cubicSuccess(timestamp) {
            return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
        }
        enableTokenBucket() {
            this.enabled = true;
        }
        updateTokenBucketRate(newRate) {
            this.refillTokenBucket();
            this.fillRate = Math.max(newRate, this.minFillRate);
            this.maxCapacity = Math.max(newRate, this.minCapacity);
            this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
        }
        updateMeasuredRate() {
            const t = this.getCurrentTimeInSeconds();
            const timeBucket = Math.floor(t * 2) / 2;
            this.requestCount++;
            if (timeBucket > this.lastTxRateBucket) {
                const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);
                this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));
                this.requestCount = 0;
                this.lastTxRateBucket = timeBucket;
            }
        }
        getPrecise(num) {
            return parseFloat(num.toFixed(8));
        }
    };

    const DEFAULT_RETRY_DELAY_BASE$2 = 100;
    const MAXIMUM_RETRY_DELAY$2 = 20 * 1000;
    const THROTTLING_RETRY_DELAY_BASE$2 = 500;
    const INITIAL_RETRY_TOKENS$2 = 500;
    const RETRY_COST$2 = 5;
    const TIMEOUT_RETRY_COST$2 = 10;
    const NO_RETRY_INCREMENT$2 = 1;
    const INVOCATION_ID_HEADER$2 = "amz-sdk-invocation-id";
    const REQUEST_HEADER$2 = "amz-sdk-request";

    const getDefaultRetryBackoffStrategy$2 = () => {
        let delayBase = DEFAULT_RETRY_DELAY_BASE$2;
        const computeNextBackoffDelay = (attempts) => {
            return Math.floor(Math.min(MAXIMUM_RETRY_DELAY$2, Math.random() * 2 ** attempts * delayBase));
        };
        const setDelayBase = (delay) => {
            delayBase = delay;
        };
        return {
            computeNextBackoffDelay,
            setDelayBase,
        };
    };

    const createDefaultRetryToken$2 = ({ retryDelay, retryCount, retryCost, }) => {
        const getRetryCount = () => retryCount;
        const getRetryDelay = () => Math.min(MAXIMUM_RETRY_DELAY$2, retryDelay);
        const getRetryCost = () => retryCost;
        return {
            getRetryCount,
            getRetryDelay,
            getRetryCost,
        };
    };

    let StandardRetryStrategy$2 = class StandardRetryStrategy {
        constructor(maxAttempts) {
            this.maxAttempts = maxAttempts;
            this.mode = RETRY_MODES$2.STANDARD;
            this.capacity = INITIAL_RETRY_TOKENS$2;
            this.retryBackoffStrategy = getDefaultRetryBackoffStrategy$2();
            this.maxAttemptsProvider = typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts;
        }
        async acquireInitialRetryToken(retryTokenScope) {
            return createDefaultRetryToken$2({
                retryDelay: DEFAULT_RETRY_DELAY_BASE$2,
                retryCount: 0,
            });
        }
        async refreshRetryTokenForRetry(token, errorInfo) {
            const maxAttempts = await this.getMaxAttempts();
            if (this.shouldRetry(token, errorInfo, maxAttempts)) {
                const errorType = errorInfo.errorType;
                this.retryBackoffStrategy.setDelayBase(errorType === "THROTTLING" ? THROTTLING_RETRY_DELAY_BASE$2 : DEFAULT_RETRY_DELAY_BASE$2);
                const delayFromErrorType = this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());
                const retryDelay = errorInfo.retryAfterHint
                    ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType)
                    : delayFromErrorType;
                const capacityCost = this.getCapacityCost(errorType);
                this.capacity -= capacityCost;
                return createDefaultRetryToken$2({
                    retryDelay,
                    retryCount: token.getRetryCount() + 1,
                    retryCost: capacityCost,
                });
            }
            throw new Error("No retry token available");
        }
        recordSuccess(token) {
            this.capacity = Math.max(INITIAL_RETRY_TOKENS$2, this.capacity + (token.getRetryCost() ?? NO_RETRY_INCREMENT$2));
        }
        getCapacity() {
            return this.capacity;
        }
        async getMaxAttempts() {
            try {
                return await this.maxAttemptsProvider();
            }
            catch (error) {
                console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS$2}`);
                return DEFAULT_MAX_ATTEMPTS$2;
            }
        }
        shouldRetry(tokenToRenew, errorInfo, maxAttempts) {
            const attempts = tokenToRenew.getRetryCount() + 1;
            return (attempts < maxAttempts &&
                this.capacity >= this.getCapacityCost(errorInfo.errorType) &&
                this.isRetryableError(errorInfo.errorType));
        }
        getCapacityCost(errorType) {
            return errorType === "TRANSIENT" ? TIMEOUT_RETRY_COST$2 : RETRY_COST$2;
        }
        isRetryableError(errorType) {
            return errorType === "THROTTLING" || errorType === "TRANSIENT";
        }
    };

    let AdaptiveRetryStrategy$2 = class AdaptiveRetryStrategy {
        constructor(maxAttemptsProvider, options) {
            this.maxAttemptsProvider = maxAttemptsProvider;
            this.mode = RETRY_MODES$2.ADAPTIVE;
            const { rateLimiter } = options ?? {};
            this.rateLimiter = rateLimiter ?? new DefaultRateLimiter$2();
            this.standardRetryStrategy = new StandardRetryStrategy$2(maxAttemptsProvider);
        }
        async acquireInitialRetryToken(retryTokenScope) {
            await this.rateLimiter.getSendToken();
            return this.standardRetryStrategy.acquireInitialRetryToken(retryTokenScope);
        }
        async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
            this.rateLimiter.updateClientSendingRate(errorInfo);
            return this.standardRetryStrategy.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
        }
        recordSuccess(token) {
            this.rateLimiter.updateClientSendingRate({});
            this.standardRetryStrategy.recordSuccess(token);
        }
    };

    const regionHash$2 = {};
    const partitionHash$2 = {
        "aws": {
            regions: [
                "af-south-1",
                "ap-east-1",
                "ap-northeast-1",
                "ap-northeast-2",
                "ap-northeast-3",
                "ap-south-1",
                "ap-south-2",
                "ap-southeast-1",
                "ap-southeast-2",
                "ap-southeast-3",
                "ap-southeast-4",
                "ca-central-1",
                "eu-central-1",
                "eu-central-2",
                "eu-north-1",
                "eu-south-1",
                "eu-south-2",
                "eu-west-1",
                "eu-west-2",
                "eu-west-3",
                "il-central-1",
                "me-central-1",
                "me-south-1",
                "sa-east-1",
                "us-east-1",
                "us-east-2",
                "us-west-1",
                "us-west-2",
            ],
            regionRegex: "^(us|eu|ap|sa|ca|me|af|il)\\-\\w+\\-\\d+$",
            variants: [
                {
                    "hostname": "geo-maps.{region}.amazonaws.com",
                    "tags": []
                },
                {
                    "hostname": "geo-maps-fips.{region}.amazonaws.com",
                    "tags": [
                        "fips"
                    ]
                },
                {
                    "hostname": "geo-maps-fips.{region}.api.aws",
                    "tags": [
                        "dualstack",
                        "fips"
                    ]
                },
                {
                    "hostname": "geo-maps.{region}.api.aws",
                    "tags": [
                        "dualstack"
                    ]
                }
            ],
        },
        "aws-cn": {
            regions: [
                "cn-north-1",
                "cn-northwest-1",
            ],
            regionRegex: "^cn\\-\\w+\\-\\d+$",
            variants: [
                {
                    "hostname": "geo-maps.{region}.amazonaws.com.cn",
                    "tags": []
                },
                {
                    "hostname": "geo-maps-fips.{region}.amazonaws.com.cn",
                    "tags": [
                        "fips"
                    ]
                },
                {
                    "hostname": "geo-maps-fips.{region}.api.amazonwebservices.com.cn",
                    "tags": [
                        "dualstack",
                        "fips"
                    ]
                },
                {
                    "hostname": "geo-maps.{region}.api.amazonwebservices.com.cn",
                    "tags": [
                        "dualstack"
                    ]
                }
            ],
        },
        "aws-iso": {
            regions: [
                "us-iso-east-1",
                "us-iso-west-1",
            ],
            regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
            variants: [
                {
                    "hostname": "geo-maps.{region}.c2s.ic.gov",
                    "tags": []
                },
                {
                    "hostname": "geo-maps-fips.{region}.c2s.ic.gov",
                    "tags": [
                        "fips"
                    ]
                }
            ],
        },
        "aws-iso-b": {
            regions: [
                "us-isob-east-1",
            ],
            regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
            variants: [
                {
                    "hostname": "geo-maps.{region}.sc2s.sgov.gov",
                    "tags": []
                },
                {
                    "hostname": "geo-maps-fips.{region}.sc2s.sgov.gov",
                    "tags": [
                        "fips"
                    ]
                }
            ],
        },
        "aws-iso-e": {
            regions: [],
            regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
            variants: [
                {
                    "hostname": "geo-maps.{region}.cloud.adc-e.uk",
                    "tags": []
                },
                {
                    "hostname": "geo-maps-fips.{region}.cloud.adc-e.uk",
                    "tags": [
                        "fips"
                    ]
                }
            ],
        },
        "aws-iso-f": {
            regions: [],
            regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
            variants: [
                {
                    "hostname": "geo-maps.{region}.csp.hci.ic.gov",
                    "tags": []
                },
                {
                    "hostname": "geo-maps-fips.{region}.csp.hci.ic.gov",
                    "tags": [
                        "fips"
                    ]
                }
            ],
        },
        "aws-us-gov": {
            regions: [
                "us-gov-east-1",
                "us-gov-west-1",
            ],
            regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
            variants: [
                {
                    "hostname": "geo-maps.{region}.amazonaws.com",
                    "tags": []
                },
                {
                    "hostname": "geo-maps-fips.{region}.amazonaws.com",
                    "tags": [
                        "fips"
                    ]
                },
                {
                    "hostname": "geo-maps-fips.{region}.api.aws",
                    "tags": [
                        "dualstack",
                        "fips"
                    ]
                },
                {
                    "hostname": "geo-maps.{region}.api.aws",
                    "tags": [
                        "dualstack"
                    ]
                }
            ],
        },
    };
    const defaultRegionInfoProvider$2 = async (region, options) => getRegionInfo$2(region, {
        ...options,
        signingService: "geo-maps",
        regionHash: regionHash$2,
        partitionHash: partitionHash$2,
    });

    let NoOpLogger$2 = class NoOpLogger {
        trace() { }
        debug() { }
        info() { }
        warn() { }
        error() { }
    };

    const getAllAliases$2 = (name, aliases) => {
        const _aliases = [];
        if (name) {
            _aliases.push(name);
        }
        if (aliases) {
            for (const alias of aliases) {
                _aliases.push(alias);
            }
        }
        return _aliases;
    };
    const getMiddlewareNameWithAliases$2 = (name, aliases) => {
        return `${name || "anonymous"}${aliases && aliases.length > 0 ? ` (a.k.a. ${aliases.join(",")})` : ""}`;
    };
    const constructStack$2 = () => {
        let absoluteEntries = [];
        let relativeEntries = [];
        let identifyOnResolve = false;
        const entriesNameSet = new Set();
        const sort = (entries) => entries.sort((a, b) => stepWeights$2[b.step] - stepWeights$2[a.step] ||
            priorityWeights$2[b.priority || "normal"] - priorityWeights$2[a.priority || "normal"]);
        const removeByName = (toRemove) => {
            let isRemoved = false;
            const filterCb = (entry) => {
                const aliases = getAllAliases$2(entry.name, entry.aliases);
                if (aliases.includes(toRemove)) {
                    isRemoved = true;
                    for (const alias of aliases) {
                        entriesNameSet.delete(alias);
                    }
                    return false;
                }
                return true;
            };
            absoluteEntries = absoluteEntries.filter(filterCb);
            relativeEntries = relativeEntries.filter(filterCb);
            return isRemoved;
        };
        const removeByReference = (toRemove) => {
            let isRemoved = false;
            const filterCb = (entry) => {
                if (entry.middleware === toRemove) {
                    isRemoved = true;
                    for (const alias of getAllAliases$2(entry.name, entry.aliases)) {
                        entriesNameSet.delete(alias);
                    }
                    return false;
                }
                return true;
            };
            absoluteEntries = absoluteEntries.filter(filterCb);
            relativeEntries = relativeEntries.filter(filterCb);
            return isRemoved;
        };
        const cloneTo = (toStack) => {
            absoluteEntries.forEach((entry) => {
                toStack.add(entry.middleware, { ...entry });
            });
            relativeEntries.forEach((entry) => {
                toStack.addRelativeTo(entry.middleware, { ...entry });
            });
            toStack.identifyOnResolve?.(stack.identifyOnResolve());
            return toStack;
        };
        const expandRelativeMiddlewareList = (from) => {
            const expandedMiddlewareList = [];
            from.before.forEach((entry) => {
                if (entry.before.length === 0 && entry.after.length === 0) {
                    expandedMiddlewareList.push(entry);
                }
                else {
                    expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
                }
            });
            expandedMiddlewareList.push(from);
            from.after.reverse().forEach((entry) => {
                if (entry.before.length === 0 && entry.after.length === 0) {
                    expandedMiddlewareList.push(entry);
                }
                else {
                    expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
                }
            });
            return expandedMiddlewareList;
        };
        const getMiddlewareList = (debug = false) => {
            const normalizedAbsoluteEntries = [];
            const normalizedRelativeEntries = [];
            const normalizedEntriesNameMap = {};
            absoluteEntries.forEach((entry) => {
                const normalizedEntry = {
                    ...entry,
                    before: [],
                    after: [],
                };
                for (const alias of getAllAliases$2(normalizedEntry.name, normalizedEntry.aliases)) {
                    normalizedEntriesNameMap[alias] = normalizedEntry;
                }
                normalizedAbsoluteEntries.push(normalizedEntry);
            });
            relativeEntries.forEach((entry) => {
                const normalizedEntry = {
                    ...entry,
                    before: [],
                    after: [],
                };
                for (const alias of getAllAliases$2(normalizedEntry.name, normalizedEntry.aliases)) {
                    normalizedEntriesNameMap[alias] = normalizedEntry;
                }
                normalizedRelativeEntries.push(normalizedEntry);
            });
            normalizedRelativeEntries.forEach((entry) => {
                if (entry.toMiddleware) {
                    const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
                    if (toMiddleware === undefined) {
                        if (debug) {
                            return;
                        }
                        throw new Error(`${entry.toMiddleware} is not found when adding ` +
                            `${getMiddlewareNameWithAliases$2(entry.name, entry.aliases)} ` +
                            `middleware ${entry.relation} ${entry.toMiddleware}`);
                    }
                    if (entry.relation === "after") {
                        toMiddleware.after.push(entry);
                    }
                    if (entry.relation === "before") {
                        toMiddleware.before.push(entry);
                    }
                }
            });
            const mainChain = sort(normalizedAbsoluteEntries)
                .map(expandRelativeMiddlewareList)
                .reduce((wholeList, expandedMiddlewareList) => {
                wholeList.push(...expandedMiddlewareList);
                return wholeList;
            }, []);
            return mainChain;
        };
        const stack = {
            add: (middleware, options = {}) => {
                const { name, override, aliases: _aliases } = options;
                const entry = {
                    step: "initialize",
                    priority: "normal",
                    middleware,
                    ...options,
                };
                const aliases = getAllAliases$2(name, _aliases);
                if (aliases.length > 0) {
                    if (aliases.some((alias) => entriesNameSet.has(alias))) {
                        if (!override)
                            throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases$2(name, _aliases)}'`);
                        for (const alias of aliases) {
                            const toOverrideIndex = absoluteEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));
                            if (toOverrideIndex === -1) {
                                continue;
                            }
                            const toOverride = absoluteEntries[toOverrideIndex];
                            if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {
                                throw new Error(`"${getMiddlewareNameWithAliases$2(toOverride.name, toOverride.aliases)}" middleware with ` +
                                    `${toOverride.priority} priority in ${toOverride.step} step cannot ` +
                                    `be overridden by "${getMiddlewareNameWithAliases$2(name, _aliases)}" middleware with ` +
                                    `${entry.priority} priority in ${entry.step} step.`);
                            }
                            absoluteEntries.splice(toOverrideIndex, 1);
                        }
                    }
                    for (const alias of aliases) {
                        entriesNameSet.add(alias);
                    }
                }
                absoluteEntries.push(entry);
            },
            addRelativeTo: (middleware, options) => {
                const { name, override, aliases: _aliases } = options;
                const entry = {
                    middleware,
                    ...options,
                };
                const aliases = getAllAliases$2(name, _aliases);
                if (aliases.length > 0) {
                    if (aliases.some((alias) => entriesNameSet.has(alias))) {
                        if (!override)
                            throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases$2(name, _aliases)}'`);
                        for (const alias of aliases) {
                            const toOverrideIndex = relativeEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));
                            if (toOverrideIndex === -1) {
                                continue;
                            }
                            const toOverride = relativeEntries[toOverrideIndex];
                            if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
                                throw new Error(`"${getMiddlewareNameWithAliases$2(toOverride.name, toOverride.aliases)}" middleware ` +
                                    `${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden ` +
                                    `by "${getMiddlewareNameWithAliases$2(name, _aliases)}" middleware ${entry.relation} ` +
                                    `"${entry.toMiddleware}" middleware.`);
                            }
                            relativeEntries.splice(toOverrideIndex, 1);
                        }
                    }
                    for (const alias of aliases) {
                        entriesNameSet.add(alias);
                    }
                }
                relativeEntries.push(entry);
            },
            clone: () => cloneTo(constructStack$2()),
            use: (plugin) => {
                plugin.applyToStack(stack);
            },
            remove: (toRemove) => {
                if (typeof toRemove === "string")
                    return removeByName(toRemove);
                else
                    return removeByReference(toRemove);
            },
            removeByTag: (toRemove) => {
                let isRemoved = false;
                const filterCb = (entry) => {
                    const { tags, name, aliases: _aliases } = entry;
                    if (tags && tags.includes(toRemove)) {
                        const aliases = getAllAliases$2(name, _aliases);
                        for (const alias of aliases) {
                            entriesNameSet.delete(alias);
                        }
                        isRemoved = true;
                        return false;
                    }
                    return true;
                };
                absoluteEntries = absoluteEntries.filter(filterCb);
                relativeEntries = relativeEntries.filter(filterCb);
                return isRemoved;
            },
            concat: (from) => {
                const cloned = cloneTo(constructStack$2());
                cloned.use(from);
                cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || (from.identifyOnResolve?.() ?? false));
                return cloned;
            },
            applyToStack: cloneTo,
            identify: () => {
                return getMiddlewareList(true).map((mw) => {
                    const step = mw.step ??
                        mw.relation +
                            " " +
                            mw.toMiddleware;
                    return getMiddlewareNameWithAliases$2(mw.name, mw.aliases) + " - " + step;
                });
            },
            identifyOnResolve(toggle) {
                if (typeof toggle === "boolean")
                    identifyOnResolve = toggle;
                return identifyOnResolve;
            },
            resolve: (handler, context) => {
                for (const middleware of getMiddlewareList()
                    .map((entry) => entry.middleware)
                    .reverse()) {
                    handler = middleware(handler, context);
                }
                if (identifyOnResolve) {
                    console.log(stack.identify());
                }
                return handler;
            },
        };
        return stack;
    };
    const stepWeights$2 = {
        initialize: 5,
        serialize: 4,
        build: 3,
        finalizeRequest: 2,
        deserialize: 1,
    };
    const priorityWeights$2 = {
        high: 3,
        normal: 2,
        low: 1,
    };

    let Client$2 = class Client {
        constructor(config) {
            this.middlewareStack = constructStack$2();
            this.config = config;
        }
        send(command, optionsOrCb, cb) {
            const options = typeof optionsOrCb !== "function" ? optionsOrCb : undefined;
            const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
            const handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
            if (callback) {
                handler(command)
                    .then((result) => callback(null, result.output), (err) => callback(err))
                    .catch(() => { });
            }
            else {
                return handler(command).then((result) => result.output);
            }
        }
        destroy() {
            if (this.config.requestHandler.destroy)
                this.config.requestHandler.destroy();
        }
    };

    function transformToString$2(payload, encoding = "utf-8") {
        if (encoding === "base64") {
            return toBase64$2(payload);
        }
        return toUtf8$2(payload);
    }
    function transformFromString$2(str, encoding) {
        if (encoding === "base64") {
            return Uint8ArrayBlobAdapter$2.mutate(fromBase64$2(str));
        }
        return Uint8ArrayBlobAdapter$2.mutate(fromUtf8$3(str));
    }

    let Uint8ArrayBlobAdapter$2 = class Uint8ArrayBlobAdapter extends Uint8Array {
        static fromString(source, encoding = "utf-8") {
            switch (typeof source) {
                case "string":
                    return transformFromString$2(source, encoding);
                default:
                    throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
            }
        }
        static mutate(source) {
            Object.setPrototypeOf(source, Uint8ArrayBlobAdapter.prototype);
            return source;
        }
        transformToString(encoding = "utf-8") {
            return transformToString$2(this, encoding);
        }
    };

    for (let i = 0; i < 256; i++) {
        let encodedByte = i.toString(16).toLowerCase();
        if (encodedByte.length === 1) {
            encodedByte = `0${encodedByte}`;
        }
    }

    const collectBody$2 = async (streamBody = new Uint8Array(), context) => {
        if (streamBody instanceof Uint8Array) {
            return Uint8ArrayBlobAdapter$2.mutate(streamBody);
        }
        if (!streamBody) {
            return Uint8ArrayBlobAdapter$2.mutate(new Uint8Array());
        }
        const fromContext = context.streamCollector(streamBody);
        return Uint8ArrayBlobAdapter$2.mutate(await fromContext);
    };

    let Command$2 = class Command {
        constructor() {
            this.middlewareStack = constructStack$2();
        }
        static classBuilder() {
            return new ClassBuilder$2();
        }
        resolveMiddlewareWithContext(clientStack, configuration, options, { middlewareFn, clientName, commandName, inputFilterSensitiveLog, outputFilterSensitiveLog, smithyContext, additionalContext, CommandCtor, }) {
            for (const mw of middlewareFn.bind(this)(CommandCtor, clientStack, configuration, options)) {
                this.middlewareStack.use(mw);
            }
            const stack = clientStack.concat(this.middlewareStack);
            const { logger } = configuration;
            const handlerExecutionContext = {
                logger,
                clientName,
                commandName,
                inputFilterSensitiveLog,
                outputFilterSensitiveLog,
                [SMITHY_CONTEXT_KEY$2]: {
                    ...smithyContext,
                },
                ...additionalContext,
            };
            const { requestHandler } = configuration;
            return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
    };
    let ClassBuilder$2 = class ClassBuilder {
        constructor() {
            this._init = () => { };
            this._ep = {};
            this._middlewareFn = () => [];
            this._commandName = "";
            this._clientName = "";
            this._additionalContext = {};
            this._smithyContext = {};
            this._inputFilterSensitiveLog = (_) => _;
            this._outputFilterSensitiveLog = (_) => _;
            this._serializer = null;
            this._deserializer = null;
        }
        init(cb) {
            this._init = cb;
        }
        ep(endpointParameterInstructions) {
            this._ep = endpointParameterInstructions;
            return this;
        }
        m(middlewareSupplier) {
            this._middlewareFn = middlewareSupplier;
            return this;
        }
        s(service, operation, smithyContext = {}) {
            this._smithyContext = {
                service,
                operation,
                ...smithyContext,
            };
            return this;
        }
        c(additionalContext = {}) {
            this._additionalContext = additionalContext;
            return this;
        }
        n(clientName, commandName) {
            this._clientName = clientName;
            this._commandName = commandName;
            return this;
        }
        f(inputFilter = (_) => _, outputFilter = (_) => _) {
            this._inputFilterSensitiveLog = inputFilter;
            this._outputFilterSensitiveLog = outputFilter;
            return this;
        }
        ser(serializer) {
            this._serializer = serializer;
            return this;
        }
        de(deserializer) {
            this._deserializer = deserializer;
            return this;
        }
        build() {
            const closure = this;
            let CommandRef;
            return (CommandRef = class extends Command$2 {
                static getEndpointParameterInstructions() {
                    return closure._ep;
                }
                constructor(...[input]) {
                    super();
                    this.serialize = closure._serializer;
                    this.deserialize = closure._deserializer;
                    this.input = input ?? {};
                    closure._init(this);
                }
                resolveMiddleware(stack, configuration, options) {
                    return this.resolveMiddlewareWithContext(stack, configuration, options, {
                        CommandCtor: CommandRef,
                        middlewareFn: closure._middlewareFn,
                        clientName: closure._clientName,
                        commandName: closure._commandName,
                        inputFilterSensitiveLog: closure._inputFilterSensitiveLog,
                        outputFilterSensitiveLog: closure._outputFilterSensitiveLog,
                        smithyContext: closure._smithyContext,
                        additionalContext: closure._additionalContext,
                    });
                }
            });
        }
    };

    const SENSITIVE_STRING$2 = "***SensitiveInformation***";

    const createAggregatedClient$2 = (commands, Client) => {
        for (const command of Object.keys(commands)) {
            const CommandCtor = commands[command];
            const methodImpl = async function (args, optionsOrCb, cb) {
                const command = new CommandCtor(args);
                if (typeof optionsOrCb === "function") {
                    this.send(command, optionsOrCb);
                }
                else if (typeof cb === "function") {
                    if (typeof optionsOrCb !== "object")
                        throw new Error(`Expected http options but got ${typeof optionsOrCb}`);
                    this.send(command, optionsOrCb || {}, cb);
                }
                else {
                    return this.send(command, optionsOrCb);
                }
            };
            const methodName = (command[0].toLowerCase() + command.slice(1)).replace(/Command$/, "");
            Client.prototype[methodName] = methodImpl;
        }
    };

    const expectNonNull$2 = (value, location) => {
        if (value === null || value === undefined) {
            if (location) {
                throw new TypeError(`Expected a non-null value for ${location}`);
            }
            throw new TypeError("Expected a non-null value");
        }
        return value;
    };
    const expectString$2 = (value) => {
        if (value === null || value === undefined) {
            return undefined;
        }
        if (typeof value === "string") {
            return value;
        }
        if (["boolean", "number", "bigint"].includes(typeof value)) {
            logger$2.warn(stackTraceWarning$2(`Expected string, got ${typeof value}: ${value}`));
            return String(value);
        }
        throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
    };
    const stackTraceWarning$2 = (message) => {
        return String(new TypeError(message).stack || message)
            .split("\n")
            .slice(0, 5)
            .filter((s) => !s.includes("stackTraceWarning"))
            .join("\n");
    };
    const logger$2 = {
        warn: console.warn,
    };

    let ServiceException$2 = class ServiceException extends Error {
        constructor(options) {
            super(options.message);
            Object.setPrototypeOf(this, ServiceException.prototype);
            this.name = options.name;
            this.$fault = options.$fault;
            this.$metadata = options.$metadata;
        }
    };
    const decorateServiceException$2 = (exception, additions = {}) => {
        Object.entries(additions)
            .filter(([, v]) => v !== undefined)
            .forEach(([k, v]) => {
            if (exception[k] == undefined || exception[k] === "") {
                exception[k] = v;
            }
        });
        const message = exception.message || exception.Message || "UnknownError";
        exception.message = message;
        delete exception.Message;
        return exception;
    };

    const throwDefaultError$7 = ({ output, parsedBody, exceptionCtor, errorCode }) => {
        const $metadata = deserializeMetadata$7(output);
        const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
        const response = new exceptionCtor({
            name: parsedBody?.code || parsedBody?.Code || errorCode || statusCode || "UnknownError",
            $fault: "client",
            $metadata,
        });
        throw decorateServiceException$2(response, parsedBody);
    };
    const withBaseException$2 = (ExceptionCtor) => {
        return ({ output, parsedBody, errorCode }) => {
            throwDefaultError$7({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
        };
    };
    const deserializeMetadata$7 = (output) => ({
        httpStatusCode: output.statusCode,
        requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
        extendedRequestId: output.headers["x-amz-id-2"],
        cfId: output.headers["x-amz-cf-id"],
    });

    const loadConfigsForDefaultMode$2 = (mode) => {
        switch (mode) {
            case "standard":
                return {
                    retryMode: "standard",
                    connectionTimeout: 3100,
                };
            case "in-region":
                return {
                    retryMode: "standard",
                    connectionTimeout: 1100,
                };
            case "cross-region":
                return {
                    retryMode: "standard",
                    connectionTimeout: 3100,
                };
            case "mobile":
                return {
                    retryMode: "standard",
                    connectionTimeout: 30000,
                };
            default:
                return {};
        }
    };

    const getChecksumConfiguration$2 = (runtimeConfig) => {
        const checksumAlgorithms = [];
        for (const id in AlgorithmId$3) {
            const algorithmId = AlgorithmId$3[id];
            if (runtimeConfig[algorithmId] === undefined) {
                continue;
            }
            checksumAlgorithms.push({
                algorithmId: () => algorithmId,
                checksumConstructor: () => runtimeConfig[algorithmId],
            });
        }
        return {
            _checksumAlgorithms: checksumAlgorithms,
            addChecksumAlgorithm(algo) {
                this._checksumAlgorithms.push(algo);
            },
            checksumAlgorithms() {
                return this._checksumAlgorithms;
            },
        };
    };
    const resolveChecksumRuntimeConfig$2 = (clientConfig) => {
        const runtimeConfig = {};
        clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
            runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
        });
        return runtimeConfig;
    };

    const getRetryConfiguration$2 = (runtimeConfig) => {
        let _retryStrategy = runtimeConfig.retryStrategy;
        return {
            setRetryStrategy(retryStrategy) {
                _retryStrategy = retryStrategy;
            },
            retryStrategy() {
                return _retryStrategy;
            },
        };
    };
    const resolveRetryRuntimeConfig$2 = (retryStrategyConfiguration) => {
        const runtimeConfig = {};
        runtimeConfig.retryStrategy = retryStrategyConfiguration.retryStrategy();
        return runtimeConfig;
    };

    const getDefaultExtensionConfiguration$2 = (runtimeConfig) => {
        return {
            ...getChecksumConfiguration$2(runtimeConfig),
            ...getRetryConfiguration$2(runtimeConfig),
        };
    };
    const resolveDefaultRuntimeConfig$2 = (config) => {
        return {
            ...resolveChecksumRuntimeConfig$2(config),
            ...resolveRetryRuntimeConfig$2(config),
        };
    };

    function extendedEncodeURIComponent$1(str) {
        return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
            return "%" + c.charCodeAt(0).toString(16).toUpperCase();
        });
    }

    const StringWrapper$2 = function () {
        const Class = Object.getPrototypeOf(this).constructor;
        const Constructor = Function.bind.apply(String, [null, ...arguments]);
        const instance = new Constructor();
        Object.setPrototypeOf(instance, Class.prototype);
        return instance;
    };
    StringWrapper$2.prototype = Object.create(String.prototype, {
        constructor: {
            value: StringWrapper$2,
            enumerable: false,
            writable: true,
            configurable: true,
        },
    });
    Object.setPrototypeOf(StringWrapper$2, String);

    function map$2(arg0, arg1, arg2) {
        let target;
        let filter;
        let instructions;
        if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
            target = {};
            instructions = arg0;
        }
        else {
            target = arg0;
            if (typeof arg1 === "function") {
                filter = arg1;
                instructions = arg2;
                return mapWithFilter$2(target, filter, instructions);
            }
            else {
                instructions = arg1;
            }
        }
        for (const key of Object.keys(instructions)) {
            if (!Array.isArray(instructions[key])) {
                target[key] = instructions[key];
                continue;
            }
            applyInstruction$2(target, null, instructions, key);
        }
        return target;
    }
    const take$2 = (source, instructions) => {
        const out = {};
        for (const key in instructions) {
            applyInstruction$2(out, source, instructions, key);
        }
        return out;
    };
    const mapWithFilter$2 = (target, filter, instructions) => {
        return map$2(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {
            if (Array.isArray(value)) {
                _instructions[key] = value;
            }
            else {
                if (typeof value === "function") {
                    _instructions[key] = [filter, value()];
                }
                else {
                    _instructions[key] = [filter, value];
                }
            }
            return _instructions;
        }, {}));
    };
    const applyInstruction$2 = (target, source, instructions, targetKey) => {
        if (source !== null) {
            let instruction = instructions[targetKey];
            if (typeof instruction === "function") {
                instruction = [, instruction];
            }
            const [filter = nonNullish$2, valueFn = pass$2, sourceKey = targetKey] = instruction;
            if ((typeof filter === "function" && filter(source[sourceKey])) || (typeof filter !== "function" && !!filter)) {
                target[targetKey] = valueFn(source[sourceKey]);
            }
            return;
        }
        let [filter, value] = instructions[targetKey];
        if (typeof value === "function") {
            let _value;
            const defaultFilterPassed = filter === undefined && (_value = value()) != null;
            const customFilterPassed = (typeof filter === "function" && !!filter(void 0)) || (typeof filter !== "function" && !!filter);
            if (defaultFilterPassed) {
                target[targetKey] = _value;
            }
            else if (customFilterPassed) {
                target[targetKey] = value();
            }
        }
        else {
            const defaultFilterPassed = filter === undefined && value != null;
            const customFilterPassed = (typeof filter === "function" && !!filter(value)) || (typeof filter !== "function" && !!filter);
            if (defaultFilterPassed || customFilterPassed) {
                target[targetKey] = value;
            }
        }
    };
    const nonNullish$2 = (_) => _ != null;
    const pass$2 = (_) => _;

    const resolvedPath$1 = (resolvedPath, input, memberName, labelValueProvider, uriLabel, isGreedyLabel) => {
        if (input != null && input[memberName] !== undefined) {
            const labelValue = labelValueProvider();
            if (labelValue.length <= 0) {
                throw new Error("Empty value provided for input HTTP label: " + memberName + ".");
            }
            resolvedPath = resolvedPath.replace(uriLabel, extendedEncodeURIComponent$1(labelValue));
        }
        else {
            throw new Error("No value provided for input HTTP label: " + memberName + ".");
        }
        return resolvedPath;
    };

    function parseQueryString$2(querystring) {
        const query = {};
        querystring = querystring.replace(/^\?/, "");
        if (querystring) {
            for (const pair of querystring.split("&")) {
                let [key, value = null] = pair.split("=");
                key = decodeURIComponent(key);
                if (value) {
                    value = decodeURIComponent(value);
                }
                if (!(key in query)) {
                    query[key] = value;
                }
                else if (Array.isArray(query[key])) {
                    query[key].push(value);
                }
                else {
                    query[key] = [query[key], value];
                }
            }
        }
        return query;
    }

    const parseUrl$2 = (url) => {
        if (typeof url === "string") {
            return parseUrl$2(new URL(url));
        }
        const { hostname, pathname, port, protocol, search } = url;
        let query;
        if (search) {
            query = parseQueryString$2(search);
        }
        return {
            hostname,
            port: port ? parseInt(port) : undefined,
            protocol,
            path: pathname,
            query,
        };
    };

    const getRuntimeConfig$9 = (config) => {
        return {
            apiVersion: "2020-11-19",
            base64Decoder: config?.base64Decoder ?? fromBase64$2,
            base64Encoder: config?.base64Encoder ?? toBase64$2,
            disableHostPrefix: config?.disableHostPrefix ?? false,
            extensions: config?.extensions ?? [],
            logger: config?.logger ?? new NoOpLogger$2(),
            regionInfoProvider: config?.regionInfoProvider ?? defaultRegionInfoProvider$2,
            serviceId: config?.serviceId ?? "GeoMaps",
            urlParser: config?.urlParser ?? parseUrl$2,
            utf8Decoder: config?.utf8Decoder ?? fromUtf8$3,
            utf8Encoder: config?.utf8Encoder ?? toUtf8$2,
        };
    };

    const memoize$3 = (provider, isExpired, requiresRefresh) => {
        let resolved;
        let pending;
        let hasResult;
        let isConstant = false;
        const coalesceProvider = async () => {
            if (!pending) {
                pending = provider();
            }
            try {
                resolved = await pending;
                hasResult = true;
                isConstant = false;
            }
            finally {
                pending = undefined;
            }
            return resolved;
        };
        {
            return async (options) => {
                if (!hasResult || options?.forceRefresh) {
                    resolved = await coalesceProvider();
                }
                return resolved;
            };
        }
    };

    const DEFAULTS_MODE_OPTIONS$2 = ["in-region", "cross-region", "mobile", "standard", "legacy"];

    const resolveDefaultsModeConfig$2 = ({ defaultsMode, } = {}) => memoize$3(async () => {
        const mode = typeof defaultsMode === "function" ? await defaultsMode() : defaultsMode;
        switch (mode?.toLowerCase()) {
            case "auto":
                return Promise.resolve(isMobileBrowser$2() ? "mobile" : "standard");
            case "mobile":
            case "in-region":
            case "cross-region":
            case "standard":
            case "legacy":
                return Promise.resolve(mode?.toLocaleLowerCase());
            case undefined:
                return Promise.resolve("legacy");
            default:
                throw new Error(`Invalid parameter for "defaultsMode", expect ${DEFAULTS_MODE_OPTIONS$2.join(", ")}, got ${mode}`);
        }
    });
    const isMobileBrowser$2 = () => {
        const parsedUA = typeof window !== "undefined" && window?.navigator?.userAgent
            ? bowser.parse(window.navigator.userAgent)
            : undefined;
        const platform = parsedUA?.platform?.type;
        return platform === "tablet" || platform === "mobile";
    };

    const getRuntimeConfig$8 = (config) => {
        const defaultsMode = resolveDefaultsModeConfig$2(config);
        const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode$2);
        const clientSharedValues = getRuntimeConfig$9(config);
        return {
            ...clientSharedValues,
            ...config,
            runtime: "browser",
            defaultsMode,
            bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength$2,
            credentialDefaultProvider: config?.credentialDefaultProvider ?? ((_) => () => Promise.reject(new Error("Credential is missing"))),
            defaultUserAgentProvider: config?.defaultUserAgentProvider ?? defaultUserAgent$2({ serviceId: clientSharedValues.serviceId, clientVersion: packageInfo$4.version }),
            maxAttempts: config?.maxAttempts ?? DEFAULT_MAX_ATTEMPTS$2,
            region: config?.region ?? invalidProvider$2("Region is missing"),
            requestHandler: config?.requestHandler ?? new FetchHttpHandler$2(defaultConfigProvider),
            retryMode: config?.retryMode ?? (async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE$2),
            sha256: config?.sha256 ?? buildExports$2.Sha256,
            streamCollector: config?.streamCollector ?? streamCollector$2,
            useDualstackEndpoint: config?.useDualstackEndpoint ?? (() => Promise.resolve(DEFAULT_USE_DUALSTACK_ENDPOINT$2)),
            useFipsEndpoint: config?.useFipsEndpoint ?? (() => Promise.resolve(DEFAULT_USE_FIPS_ENDPOINT$2)),
        };
    };

    const getAwsRegionExtensionConfiguration$2 = (runtimeConfig) => {
        let runtimeConfigRegion = async () => {
            if (runtimeConfig.region === undefined) {
                throw new Error("Region is missing from runtimeConfig");
            }
            const region = runtimeConfig.region;
            if (typeof region === "string") {
                return region;
            }
            return region();
        };
        return {
            setRegion(region) {
                runtimeConfigRegion = region;
            },
            region() {
                return runtimeConfigRegion;
            },
        };
    };
    const resolveAwsRegionExtensionConfiguration$2 = (awsRegionExtensionConfiguration) => {
        return {
            region: awsRegionExtensionConfiguration.region(),
        };
    };

    const asPartial$4 = (t) => t;
    const resolveRuntimeExtensions$4 = (runtimeConfig, extensions) => {
        const extensionConfiguration = {
            ...asPartial$4(getAwsRegionExtensionConfiguration$2(runtimeConfig)),
            ...asPartial$4(getDefaultExtensionConfiguration$2(runtimeConfig)),
            ...asPartial$4(getHttpHandlerExtensionConfiguration$2(runtimeConfig)),
        };
        extensions.forEach(extension => extension.configure(extensionConfiguration));
        return {
            ...runtimeConfig,
            ...resolveAwsRegionExtensionConfiguration$2(extensionConfiguration),
            ...resolveDefaultRuntimeConfig$2(extensionConfiguration),
            ...resolveHttpHandlerRuntimeConfig$2(extensionConfiguration),
        };
    };

    function resolveHostHeaderConfig$2(input) {
        return input;
    }
    const hostHeaderMiddleware$2 = (options) => (next) => async (args) => {
        if (!HttpRequest$3.isInstance(args.request))
            return next(args);
        const { request } = args;
        const { handlerProtocol = "" } = options.requestHandler.metadata || {};
        if (handlerProtocol.indexOf("h2") >= 0 && !request.headers[":authority"]) {
            delete request.headers["host"];
            request.headers[":authority"] = request.hostname + (request.port ? ":" + request.port : "");
        }
        else if (!request.headers["host"]) {
            let host = request.hostname;
            if (request.port != null)
                host += `:${request.port}`;
            request.headers["host"] = host;
        }
        return next(args);
    };
    const hostHeaderMiddlewareOptions$2 = {
        name: "hostHeaderMiddleware",
        step: "build",
        priority: "low",
        tags: ["HOST"],
        override: true,
    };
    const getHostHeaderPlugin$2 = (options) => ({
        applyToStack: (clientStack) => {
            clientStack.add(hostHeaderMiddleware$2(options), hostHeaderMiddlewareOptions$2);
        },
    });

    const loggerMiddleware$2 = () => (next, context) => async (args) => {
        try {
            const response = await next(args);
            const { clientName, commandName, logger, dynamoDbDocumentClientOptions = {} } = context;
            const { overrideInputFilterSensitiveLog, overrideOutputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
            const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
            const outputFilterSensitiveLog = overrideOutputFilterSensitiveLog ?? context.outputFilterSensitiveLog;
            const { $metadata, ...outputWithoutMetadata } = response.output;
            logger?.info?.({
                clientName,
                commandName,
                input: inputFilterSensitiveLog(args.input),
                output: outputFilterSensitiveLog(outputWithoutMetadata),
                metadata: $metadata,
            });
            return response;
        }
        catch (error) {
            const { clientName, commandName, logger, dynamoDbDocumentClientOptions = {} } = context;
            const { overrideInputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
            const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
            logger?.error?.({
                clientName,
                commandName,
                input: inputFilterSensitiveLog(args.input),
                error,
                metadata: error.$metadata,
            });
            throw error;
        }
    };
    const loggerMiddlewareOptions$2 = {
        name: "loggerMiddleware",
        tags: ["LOGGER"],
        step: "initialize",
        override: true,
    };
    const getLoggerPlugin$2 = (options) => ({
        applyToStack: (clientStack) => {
            clientStack.add(loggerMiddleware$2(), loggerMiddlewareOptions$2);
        },
    });

    const TRACE_ID_HEADER_NAME$2 = "X-Amzn-Trace-Id";
    const ENV_LAMBDA_FUNCTION_NAME$2 = "AWS_LAMBDA_FUNCTION_NAME";
    const ENV_TRACE_ID$2 = "_X_AMZN_TRACE_ID";
    const recursionDetectionMiddleware$2 = (options) => (next) => async (args) => {
        const { request } = args;
        if (!HttpRequest$3.isInstance(request) ||
            options.runtime !== "node" ||
            request.headers.hasOwnProperty(TRACE_ID_HEADER_NAME$2)) {
            return next(args);
        }
        const functionName = process.env[ENV_LAMBDA_FUNCTION_NAME$2];
        const traceId = process.env[ENV_TRACE_ID$2];
        const nonEmptyString = (str) => typeof str === "string" && str.length > 0;
        if (nonEmptyString(functionName) && nonEmptyString(traceId)) {
            request.headers[TRACE_ID_HEADER_NAME$2] = traceId;
        }
        return next({
            ...args,
            request,
        });
    };
    const addRecursionDetectionMiddlewareOptions$2 = {
        step: "build",
        tags: ["RECURSION_DETECTION"],
        name: "recursionDetectionMiddleware",
        override: true,
        priority: "low",
    };
    const getRecursionDetectionPlugin$2 = (options) => ({
        applyToStack: (clientStack) => {
            clientStack.add(recursionDetectionMiddleware$2(options), addRecursionDetectionMiddlewareOptions$2);
        },
    });

    const memoize$2 = (provider, isExpired, requiresRefresh) => {
        let resolved;
        let pending;
        let hasResult;
        let isConstant = false;
        const coalesceProvider = async () => {
            if (!pending) {
                pending = provider();
            }
            try {
                resolved = await pending;
                hasResult = true;
                isConstant = false;
            }
            finally {
                pending = undefined;
            }
            return resolved;
        };
        if (isExpired === undefined) {
            return async (options) => {
                if (!hasResult || options?.forceRefresh) {
                    resolved = await coalesceProvider();
                }
                return resolved;
            };
        }
        return async (options) => {
            if (!hasResult || options?.forceRefresh) {
                resolved = await coalesceProvider();
            }
            if (isConstant) {
                return resolved;
            }
            if (requiresRefresh && !requiresRefresh(resolved)) {
                isConstant = true;
                return resolved;
            }
            if (isExpired(resolved)) {
                await coalesceProvider();
                return resolved;
            }
            return resolved;
        };
    };

    const SHORT_TO_HEX = {};
    const HEX_TO_SHORT = {};
    for (let i = 0; i < 256; i++) {
        let encodedByte = i.toString(16).toLowerCase();
        if (encodedByte.length === 1) {
            encodedByte = `0${encodedByte}`;
        }
        SHORT_TO_HEX[i] = encodedByte;
        HEX_TO_SHORT[encodedByte] = i;
    }
    function fromHex(encoded) {
        if (encoded.length % 2 !== 0) {
            throw new Error("Hex encoded strings must have an even number length");
        }
        const out = new Uint8Array(encoded.length / 2);
        for (let i = 0; i < encoded.length; i += 2) {
            const encodedByte = encoded.slice(i, i + 2).toLowerCase();
            if (encodedByte in HEX_TO_SHORT) {
                out[i / 2] = HEX_TO_SHORT[encodedByte];
            }
            else {
                throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
            }
        }
        return out;
    }
    function toHex(bytes) {
        let out = "";
        for (let i = 0; i < bytes.byteLength; i++) {
            out += SHORT_TO_HEX[bytes[i]];
        }
        return out;
    }

    var HttpAuthLocation$2;
    (function (HttpAuthLocation) {
        HttpAuthLocation["HEADER"] = "header";
        HttpAuthLocation["QUERY"] = "query";
    })(HttpAuthLocation$2 || (HttpAuthLocation$2 = {}));

    var HttpApiKeyAuthLocation$2;
    (function (HttpApiKeyAuthLocation) {
        HttpApiKeyAuthLocation["HEADER"] = "header";
        HttpApiKeyAuthLocation["QUERY"] = "query";
    })(HttpApiKeyAuthLocation$2 || (HttpApiKeyAuthLocation$2 = {}));

    var EndpointURLScheme$2;
    (function (EndpointURLScheme) {
        EndpointURLScheme["HTTP"] = "http";
        EndpointURLScheme["HTTPS"] = "https";
    })(EndpointURLScheme$2 || (EndpointURLScheme$2 = {}));

    var AlgorithmId$2;
    (function (AlgorithmId) {
        AlgorithmId["MD5"] = "md5";
        AlgorithmId["CRC32"] = "crc32";
        AlgorithmId["CRC32C"] = "crc32c";
        AlgorithmId["SHA1"] = "sha1";
        AlgorithmId["SHA256"] = "sha256";
    })(AlgorithmId$2 || (AlgorithmId$2 = {}));

    var FieldPosition$2;
    (function (FieldPosition) {
        FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
        FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
    })(FieldPosition$2 || (FieldPosition$2 = {}));

    var IniSectionType$2;
    (function (IniSectionType) {
        IniSectionType["PROFILE"] = "profile";
        IniSectionType["SSO_SESSION"] = "sso-session";
        IniSectionType["SERVICES"] = "services";
    })(IniSectionType$2 || (IniSectionType$2 = {}));

    var RequestHandlerProtocol$2;
    (function (RequestHandlerProtocol) {
        RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
        RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
        RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
    })(RequestHandlerProtocol$2 || (RequestHandlerProtocol$2 = {}));

    const normalizeProvider$2 = (input) => {
        if (typeof input === "function")
            return input;
        const promisified = Promise.resolve(input);
        return () => promisified;
    };

    const escapeUri$2 = (uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode$2);
    const hexEncode$2 = (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`;

    const fromUtf8$2 = (input) => new TextEncoder().encode(input);

    const toUint8Array = (data) => {
        if (typeof data === "string") {
            return fromUtf8$2(data);
        }
        if (ArrayBuffer.isView(data)) {
            return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
        }
        return new Uint8Array(data);
    };

    const ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
    const CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
    const AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
    const SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
    const EXPIRES_QUERY_PARAM = "X-Amz-Expires";
    const SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
    const TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
    const AUTH_HEADER = "authorization";
    const AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase();
    const DATE_HEADER = "date";
    const GENERATED_HEADERS = [AUTH_HEADER, AMZ_DATE_HEADER, DATE_HEADER];
    const SIGNATURE_HEADER = SIGNATURE_QUERY_PARAM.toLowerCase();
    const SHA256_HEADER = "x-amz-content-sha256";
    const TOKEN_HEADER = TOKEN_QUERY_PARAM.toLowerCase();
    const ALWAYS_UNSIGNABLE_HEADERS = {
        authorization: true,
        "cache-control": true,
        connection: true,
        expect: true,
        from: true,
        "keep-alive": true,
        "max-forwards": true,
        pragma: true,
        referer: true,
        te: true,
        trailer: true,
        "transfer-encoding": true,
        upgrade: true,
        "user-agent": true,
        "x-amzn-trace-id": true,
    };
    const PROXY_HEADER_PATTERN = /^proxy-/;
    const SEC_HEADER_PATTERN = /^sec-/;
    const ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";
    const EVENT_ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256-PAYLOAD";
    const UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
    const MAX_CACHE_SIZE = 50;
    const KEY_TYPE_IDENTIFIER = "aws4_request";
    const MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7;

    const signingKeyCache = {};
    const cacheQueue = [];
    const createScope = (shortDate, region, service) => `${shortDate}/${region}/${service}/${KEY_TYPE_IDENTIFIER}`;
    const getSigningKey = async (sha256Constructor, credentials, shortDate, region, service) => {
        const credsHash = await hmac(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId);
        const cacheKey = `${shortDate}:${region}:${service}:${toHex(credsHash)}:${credentials.sessionToken}`;
        if (cacheKey in signingKeyCache) {
            return signingKeyCache[cacheKey];
        }
        cacheQueue.push(cacheKey);
        while (cacheQueue.length > MAX_CACHE_SIZE) {
            delete signingKeyCache[cacheQueue.shift()];
        }
        let key = `AWS4${credentials.secretAccessKey}`;
        for (const signable of [shortDate, region, service, KEY_TYPE_IDENTIFIER]) {
            key = await hmac(sha256Constructor, key, signable);
        }
        return (signingKeyCache[cacheKey] = key);
    };
    const hmac = (ctor, secret, data) => {
        const hash = new ctor(secret);
        hash.update(toUint8Array(data));
        return hash.digest();
    };

    const getCanonicalHeaders = ({ headers }, unsignableHeaders, signableHeaders) => {
        const canonical = {};
        for (const headerName of Object.keys(headers).sort()) {
            if (headers[headerName] == undefined) {
                continue;
            }
            const canonicalHeaderName = headerName.toLowerCase();
            if (canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS ||
                unsignableHeaders?.has(canonicalHeaderName) ||
                PROXY_HEADER_PATTERN.test(canonicalHeaderName) ||
                SEC_HEADER_PATTERN.test(canonicalHeaderName)) {
                if (!signableHeaders || (signableHeaders && !signableHeaders.has(canonicalHeaderName))) {
                    continue;
                }
            }
            canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\s+/g, " ");
        }
        return canonical;
    };

    const getCanonicalQuery = ({ query = {} }) => {
        const keys = [];
        const serialized = {};
        for (const key of Object.keys(query).sort()) {
            if (key.toLowerCase() === SIGNATURE_HEADER) {
                continue;
            }
            keys.push(key);
            const value = query[key];
            if (typeof value === "string") {
                serialized[key] = `${escapeUri$2(key)}=${escapeUri$2(value)}`;
            }
            else if (Array.isArray(value)) {
                serialized[key] = value
                    .slice(0)
                    .reduce((encoded, value) => encoded.concat([`${escapeUri$2(key)}=${escapeUri$2(value)}`]), [])
                    .sort()
                    .join("&");
            }
        }
        return keys
            .map((key) => serialized[key])
            .filter((serialized) => serialized)
            .join("&");
    };

    const isArrayBuffer = (arg) => (typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer) ||
        Object.prototype.toString.call(arg) === "[object ArrayBuffer]";

    const getPayloadHash = async ({ headers, body }, hashConstructor) => {
        for (const headerName of Object.keys(headers)) {
            if (headerName.toLowerCase() === SHA256_HEADER) {
                return headers[headerName];
            }
        }
        if (body == undefined) {
            return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
        }
        else if (typeof body === "string" || ArrayBuffer.isView(body) || isArrayBuffer(body)) {
            const hashCtor = new hashConstructor();
            hashCtor.update(toUint8Array(body));
            return toHex(await hashCtor.digest());
        }
        return UNSIGNED_PAYLOAD;
    };

    class HeaderFormatter {
        format(headers) {
            const chunks = [];
            for (const headerName of Object.keys(headers)) {
                const bytes = fromUtf8$2(headerName);
                chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
            }
            const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
            let position = 0;
            for (const chunk of chunks) {
                out.set(chunk, position);
                position += chunk.byteLength;
            }
            return out;
        }
        formatHeaderValue(header) {
            switch (header.type) {
                case "boolean":
                    return Uint8Array.from([header.value ? 0 : 1]);
                case "byte":
                    return Uint8Array.from([2, header.value]);
                case "short":
                    const shortView = new DataView(new ArrayBuffer(3));
                    shortView.setUint8(0, 3);
                    shortView.setInt16(1, header.value, false);
                    return new Uint8Array(shortView.buffer);
                case "integer":
                    const intView = new DataView(new ArrayBuffer(5));
                    intView.setUint8(0, 4);
                    intView.setInt32(1, header.value, false);
                    return new Uint8Array(intView.buffer);
                case "long":
                    const longBytes = new Uint8Array(9);
                    longBytes[0] = 5;
                    longBytes.set(header.value.bytes, 1);
                    return longBytes;
                case "binary":
                    const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
                    binView.setUint8(0, 6);
                    binView.setUint16(1, header.value.byteLength, false);
                    const binBytes = new Uint8Array(binView.buffer);
                    binBytes.set(header.value, 3);
                    return binBytes;
                case "string":
                    const utf8Bytes = fromUtf8$2(header.value);
                    const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
                    strView.setUint8(0, 7);
                    strView.setUint16(1, utf8Bytes.byteLength, false);
                    const strBytes = new Uint8Array(strView.buffer);
                    strBytes.set(utf8Bytes, 3);
                    return strBytes;
                case "timestamp":
                    const tsBytes = new Uint8Array(9);
                    tsBytes[0] = 8;
                    tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);
                    return tsBytes;
                case "uuid":
                    if (!UUID_PATTERN.test(header.value)) {
                        throw new Error(`Invalid UUID received: ${header.value}`);
                    }
                    const uuidBytes = new Uint8Array(17);
                    uuidBytes[0] = 9;
                    uuidBytes.set(fromHex(header.value.replace(/\-/g, "")), 1);
                    return uuidBytes;
            }
        }
    }
    var HEADER_VALUE_TYPE;
    (function (HEADER_VALUE_TYPE) {
        HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["boolTrue"] = 0] = "boolTrue";
        HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["boolFalse"] = 1] = "boolFalse";
        HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["byte"] = 2] = "byte";
        HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["short"] = 3] = "short";
        HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["integer"] = 4] = "integer";
        HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["long"] = 5] = "long";
        HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["byteArray"] = 6] = "byteArray";
        HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["string"] = 7] = "string";
        HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["timestamp"] = 8] = "timestamp";
        HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["uuid"] = 9] = "uuid";
    })(HEADER_VALUE_TYPE || (HEADER_VALUE_TYPE = {}));
    const UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
    class Int64 {
        constructor(bytes) {
            this.bytes = bytes;
            if (bytes.byteLength !== 8) {
                throw new Error("Int64 buffers must be exactly 8 bytes");
            }
        }
        static fromNumber(number) {
            if (number > 9223372036854776000 || number < -9223372036854776000) {
                throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
            }
            const bytes = new Uint8Array(8);
            for (let i = 7, remaining = Math.abs(Math.round(number)); i > -1 && remaining > 0; i--, remaining /= 256) {
                bytes[i] = remaining;
            }
            if (number < 0) {
                negate(bytes);
            }
            return new Int64(bytes);
        }
        valueOf() {
            const bytes = this.bytes.slice(0);
            const negative = bytes[0] & 0b10000000;
            if (negative) {
                negate(bytes);
            }
            return parseInt(toHex(bytes), 16) * (negative ? -1 : 1);
        }
        toString() {
            return String(this.valueOf());
        }
    }
    function negate(bytes) {
        for (let i = 0; i < 8; i++) {
            bytes[i] ^= 0xff;
        }
        for (let i = 7; i > -1; i--) {
            bytes[i]++;
            if (bytes[i] !== 0)
                break;
        }
    }

    const hasHeader = (soughtHeader, headers) => {
        soughtHeader = soughtHeader.toLowerCase();
        for (const headerName of Object.keys(headers)) {
            if (soughtHeader === headerName.toLowerCase()) {
                return true;
            }
        }
        return false;
    };

    const cloneRequest = ({ headers, query, ...rest }) => ({
        ...rest,
        headers: { ...headers },
        query: query ? cloneQuery$3(query) : undefined,
    });
    const cloneQuery$3 = (query) => Object.keys(query).reduce((carry, paramName) => {
        const param = query[paramName];
        return {
            ...carry,
            [paramName]: Array.isArray(param) ? [...param] : param,
        };
    }, {});

    const moveHeadersToQuery = (request, options = {}) => {
        const { headers, query = {} } = typeof request.clone === "function" ? request.clone() : cloneRequest(request);
        for (const name of Object.keys(headers)) {
            const lname = name.toLowerCase();
            if (lname.slice(0, 6) === "x-amz-" && !options.unhoistableHeaders?.has(lname)) {
                query[name] = headers[name];
                delete headers[name];
            }
        }
        return {
            ...request,
            headers,
            query,
        };
    };

    const prepareRequest = (request) => {
        request = typeof request.clone === "function" ? request.clone() : cloneRequest(request);
        for (const headerName of Object.keys(request.headers)) {
            if (GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {
                delete request.headers[headerName];
            }
        }
        return request;
    };

    const iso8601 = (time) => toDate(time)
        .toISOString()
        .replace(/\.\d{3}Z$/, "Z");
    const toDate = (time) => {
        if (typeof time === "number") {
            return new Date(time * 1000);
        }
        if (typeof time === "string") {
            if (Number(time)) {
                return new Date(Number(time) * 1000);
            }
            return new Date(time);
        }
        return time;
    };

    class SignatureV4 {
        constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true, }) {
            this.headerFormatter = new HeaderFormatter();
            this.service = service;
            this.sha256 = sha256;
            this.uriEscapePath = uriEscapePath;
            this.applyChecksum = typeof applyChecksum === "boolean" ? applyChecksum : true;
            this.regionProvider = normalizeProvider$2(region);
            this.credentialProvider = normalizeProvider$2(credentials);
        }
        async presign(originalRequest, options = {}) {
            const { signingDate = new Date(), expiresIn = 3600, unsignableHeaders, unhoistableHeaders, signableHeaders, signingRegion, signingService, } = options;
            const credentials = await this.credentialProvider();
            this.validateResolvedCredentials(credentials);
            const region = signingRegion ?? (await this.regionProvider());
            const { longDate, shortDate } = formatDate(signingDate);
            if (expiresIn > MAX_PRESIGNED_TTL) {
                return Promise.reject("Signature version 4 presigned URLs" + " must have an expiration date less than one week in" + " the future");
            }
            const scope = createScope(shortDate, region, signingService ?? this.service);
            const request = moveHeadersToQuery(prepareRequest(originalRequest), { unhoistableHeaders });
            if (credentials.sessionToken) {
                request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;
            }
            request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;
            request.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;
            request.query[AMZ_DATE_QUERY_PARAM] = longDate;
            request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);
            const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
            request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);
            request.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256)));
            return request;
        }
        async sign(toSign, options) {
            if (typeof toSign === "string") {
                return this.signString(toSign, options);
            }
            else if (toSign.headers && toSign.payload) {
                return this.signEvent(toSign, options);
            }
            else if (toSign.message) {
                return this.signMessage(toSign, options);
            }
            else {
                return this.signRequest(toSign, options);
            }
        }
        async signEvent({ headers, payload }, { signingDate = new Date(), priorSignature, signingRegion, signingService }) {
            const region = signingRegion ?? (await this.regionProvider());
            const { shortDate, longDate } = formatDate(signingDate);
            const scope = createScope(shortDate, region, signingService ?? this.service);
            const hashedPayload = await getPayloadHash({ headers: {}, body: payload }, this.sha256);
            const hash = new this.sha256();
            hash.update(headers);
            const hashedHeaders = toHex(await hash.digest());
            const stringToSign = [
                EVENT_ALGORITHM_IDENTIFIER,
                longDate,
                scope,
                priorSignature,
                hashedHeaders,
                hashedPayload,
            ].join("\n");
            return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });
        }
        async signMessage(signableMessage, { signingDate = new Date(), signingRegion, signingService }) {
            const promise = this.signEvent({
                headers: this.headerFormatter.format(signableMessage.message.headers),
                payload: signableMessage.message.body,
            }, {
                signingDate,
                signingRegion,
                signingService,
                priorSignature: signableMessage.priorSignature,
            });
            return promise.then((signature) => {
                return { message: signableMessage.message, signature };
            });
        }
        async signString(stringToSign, { signingDate = new Date(), signingRegion, signingService } = {}) {
            const credentials = await this.credentialProvider();
            this.validateResolvedCredentials(credentials);
            const region = signingRegion ?? (await this.regionProvider());
            const { shortDate } = formatDate(signingDate);
            const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));
            hash.update(toUint8Array(stringToSign));
            return toHex(await hash.digest());
        }
        async signRequest(requestToSign, { signingDate = new Date(), signableHeaders, unsignableHeaders, signingRegion, signingService, } = {}) {
            const credentials = await this.credentialProvider();
            this.validateResolvedCredentials(credentials);
            const region = signingRegion ?? (await this.regionProvider());
            const request = prepareRequest(requestToSign);
            const { longDate, shortDate } = formatDate(signingDate);
            const scope = createScope(shortDate, region, signingService ?? this.service);
            request.headers[AMZ_DATE_HEADER] = longDate;
            if (credentials.sessionToken) {
                request.headers[TOKEN_HEADER] = credentials.sessionToken;
            }
            const payloadHash = await getPayloadHash(request, this.sha256);
            if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {
                request.headers[SHA256_HEADER] = payloadHash;
            }
            const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
            const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));
            request.headers[AUTH_HEADER] =
                `${ALGORITHM_IDENTIFIER} ` +
                    `Credential=${credentials.accessKeyId}/${scope}, ` +
                    `SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, ` +
                    `Signature=${signature}`;
            return request;
        }
        createCanonicalRequest(request, canonicalHeaders, payloadHash) {
            const sortedHeaders = Object.keys(canonicalHeaders).sort();
            return `${request.method}
${this.getCanonicalPath(request)}
${getCanonicalQuery(request)}
${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join("\n")}

${sortedHeaders.join(";")}
${payloadHash}`;
        }
        async createStringToSign(longDate, credentialScope, canonicalRequest) {
            const hash = new this.sha256();
            hash.update(toUint8Array(canonicalRequest));
            const hashedRequest = await hash.digest();
            return `${ALGORITHM_IDENTIFIER}
${longDate}
${credentialScope}
${toHex(hashedRequest)}`;
        }
        getCanonicalPath({ path }) {
            if (this.uriEscapePath) {
                const normalizedPathSegments = [];
                for (const pathSegment of path.split("/")) {
                    if (pathSegment?.length === 0)
                        continue;
                    if (pathSegment === ".")
                        continue;
                    if (pathSegment === "..") {
                        normalizedPathSegments.pop();
                    }
                    else {
                        normalizedPathSegments.push(pathSegment);
                    }
                }
                const normalizedPath = `${path?.startsWith("/") ? "/" : ""}${normalizedPathSegments.join("/")}${normalizedPathSegments.length > 0 && path?.endsWith("/") ? "/" : ""}`;
                const doubleEncoded = escapeUri$2(normalizedPath);
                return doubleEncoded.replace(/%2F/g, "/");
            }
            return path;
        }
        async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {
            const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);
            const hash = new this.sha256(await keyPromise);
            hash.update(toUint8Array(stringToSign));
            return toHex(await hash.digest());
        }
        getSigningKey(credentials, region, shortDate, service) {
            return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);
        }
        validateResolvedCredentials(credentials) {
            if (typeof credentials !== "object" ||
                typeof credentials.accessKeyId !== "string" ||
                typeof credentials.secretAccessKey !== "string") {
                throw new Error("Resolved credential object is not valid");
            }
        }
    }
    const formatDate = (now) => {
        const longDate = iso8601(now).replace(/[\-:]/g, "");
        return {
            longDate,
            shortDate: longDate.slice(0, 8),
        };
    };
    const getCanonicalHeaderList = (headers) => Object.keys(headers).sort().join(";");

    const CREDENTIAL_EXPIRE_WINDOW = 300000;
    const resolveAwsAuthConfig = (input) => {
        const normalizedCreds = input.credentials
            ? normalizeCredentialProvider(input.credentials)
            : input.credentialDefaultProvider(input);
        const { signingEscapePath = true, systemClockOffset = input.systemClockOffset || 0, sha256 } = input;
        let signer;
        if (input.signer) {
            signer = normalizeProvider$2(input.signer);
        }
        else if (input.regionInfoProvider) {
            signer = () => normalizeProvider$2(input.region)()
                .then(async (region) => [
                (await input.regionInfoProvider(region, {
                    useFipsEndpoint: await input.useFipsEndpoint(),
                    useDualstackEndpoint: await input.useDualstackEndpoint(),
                })) || {},
                region,
            ])
                .then(([regionInfo, region]) => {
                const { signingRegion, signingService } = regionInfo;
                input.signingRegion = input.signingRegion || signingRegion || region;
                input.signingName = input.signingName || signingService || input.serviceId;
                const params = {
                    ...input,
                    credentials: normalizedCreds,
                    region: input.signingRegion,
                    service: input.signingName,
                    sha256,
                    uriEscapePath: signingEscapePath,
                };
                const SignerCtor = input.signerConstructor || SignatureV4;
                return new SignerCtor(params);
            });
        }
        else {
            signer = async (authScheme) => {
                authScheme = Object.assign({}, {
                    name: "sigv4",
                    signingName: input.signingName || input.defaultSigningName,
                    signingRegion: await normalizeProvider$2(input.region)(),
                    properties: {},
                }, authScheme);
                const signingRegion = authScheme.signingRegion;
                const signingService = authScheme.signingName;
                input.signingRegion = input.signingRegion || signingRegion;
                input.signingName = input.signingName || signingService || input.serviceId;
                const params = {
                    ...input,
                    credentials: normalizedCreds,
                    region: input.signingRegion,
                    service: input.signingName,
                    sha256,
                    uriEscapePath: signingEscapePath,
                };
                const SignerCtor = input.signerConstructor || SignatureV4;
                return new SignerCtor(params);
            };
        }
        return {
            ...input,
            systemClockOffset,
            signingEscapePath,
            credentials: normalizedCreds,
            signer,
        };
    };
    const normalizeCredentialProvider = (credentials) => {
        if (typeof credentials === "function") {
            return memoize$2(credentials, (credentials) => credentials.expiration !== undefined &&
                credentials.expiration.getTime() - Date.now() < CREDENTIAL_EXPIRE_WINDOW, (credentials) => credentials.expiration !== undefined);
        }
        return normalizeProvider$2(credentials);
    };

    let HttpRequest$2 = class HttpRequest {
        constructor(options) {
            this.method = options.method || "GET";
            this.hostname = options.hostname || "localhost";
            this.port = options.port;
            this.query = options.query || {};
            this.headers = options.headers || {};
            this.body = options.body;
            this.protocol = options.protocol
                ? options.protocol.slice(-1) !== ":"
                    ? `${options.protocol}:`
                    : options.protocol
                : "https:";
            this.path = options.path ? (options.path.charAt(0) !== "/" ? `/${options.path}` : options.path) : "/";
            this.username = options.username;
            this.password = options.password;
            this.fragment = options.fragment;
        }
        static isInstance(request) {
            if (!request)
                return false;
            const req = request;
            return ("method" in req &&
                "protocol" in req &&
                "hostname" in req &&
                "path" in req &&
                typeof req["query"] === "object" &&
                typeof req["headers"] === "object");
        }
        clone() {
            const cloned = new HttpRequest({
                ...this,
                headers: { ...this.headers },
            });
            if (cloned.query)
                cloned.query = cloneQuery$2(cloned.query);
            return cloned;
        }
    };
    function cloneQuery$2(query) {
        return Object.keys(query).reduce((carry, paramName) => {
            const param = query[paramName];
            return {
                ...carry,
                [paramName]: Array.isArray(param) ? [...param] : param,
            };
        }, {});
    }

    let HttpResponse$2 = class HttpResponse {
        constructor(options) {
            this.statusCode = options.statusCode;
            this.reason = options.reason;
            this.headers = options.headers || {};
            this.body = options.body;
        }
        static isInstance(response) {
            if (!response)
                return false;
            const resp = response;
            return typeof resp.statusCode === "number" && typeof resp.headers === "object";
        }
    };

    const getSkewCorrectedDate = (systemClockOffset) => new Date(Date.now() + systemClockOffset);

    const isClockSkewed = (clockTime, systemClockOffset) => Math.abs(getSkewCorrectedDate(systemClockOffset).getTime() - clockTime) >= 300000;

    const getUpdatedSystemClockOffset = (clockTime, currentSystemClockOffset) => {
        const clockTimeInMs = Date.parse(clockTime);
        if (isClockSkewed(clockTimeInMs, currentSystemClockOffset)) {
            return clockTimeInMs - Date.now();
        }
        return currentSystemClockOffset;
    };

    const awsAuthMiddleware = (options) => (next, context) => async function (args) {
        if (!HttpRequest$2.isInstance(args.request))
            return next(args);
        const authScheme = context.endpointV2?.properties?.authSchemes?.[0];
        const multiRegionOverride = authScheme?.name === "sigv4a" ? authScheme?.signingRegionSet?.join(",") : undefined;
        const signer = await options.signer(authScheme);
        const output = await next({
            ...args,
            request: await signer.sign(args.request, {
                signingDate: getSkewCorrectedDate(options.systemClockOffset),
                signingRegion: multiRegionOverride || context["signing_region"],
                signingService: context["signing_service"],
            }),
        }).catch((error) => {
            const serverTime = error.ServerTime ?? getDateHeader(error.$response);
            if (serverTime) {
                options.systemClockOffset = getUpdatedSystemClockOffset(serverTime, options.systemClockOffset);
            }
            throw error;
        });
        const dateHeader = getDateHeader(output.response);
        if (dateHeader) {
            options.systemClockOffset = getUpdatedSystemClockOffset(dateHeader, options.systemClockOffset);
        }
        return output;
    };
    const getDateHeader = (response) => HttpResponse$2.isInstance(response) ? response.headers?.date ?? response.headers?.Date : undefined;
    const awsAuthMiddlewareOptions = {
        name: "awsAuthMiddleware",
        tags: ["SIGNATURE", "AWSAUTH"],
        relation: "after",
        toMiddleware: "retryMiddleware",
        override: true,
    };
    const getAwsAuthPlugin = (options) => ({
        applyToStack: (clientStack) => {
            clientStack.addRelativeTo(awsAuthMiddleware(options), awsAuthMiddlewareOptions);
        },
    });

    function resolveUserAgentConfig$2(input) {
        return {
            ...input,
            customUserAgent: typeof input.customUserAgent === "string" ? [[input.customUserAgent]] : input.customUserAgent,
        };
    }

    ({
        [EndpointURLScheme$3.HTTP]: 80,
        [EndpointURLScheme$3.HTTPS]: 443,
    });

    const USER_AGENT$2 = "user-agent";
    const X_AMZ_USER_AGENT$2 = "x-amz-user-agent";
    const SPACE$2 = " ";
    const UA_NAME_SEPARATOR$2 = "/";
    const UA_NAME_ESCAPE_REGEX$2 = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g;
    const UA_VALUE_ESCAPE_REGEX$2 = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g;
    const UA_ESCAPE_CHAR$2 = "-";

    const userAgentMiddleware$2 = (options) => (next, context) => async (args) => {
        const { request } = args;
        if (!HttpRequest$3.isInstance(request))
            return next(args);
        const { headers } = request;
        const userAgent = context?.userAgent?.map(escapeUserAgent$2) || [];
        const defaultUserAgent = (await options.defaultUserAgentProvider()).map(escapeUserAgent$2);
        const customUserAgent = options?.customUserAgent?.map(escapeUserAgent$2) || [];
        const sdkUserAgentValue = ([])
            .concat([...defaultUserAgent, ...userAgent, ...customUserAgent])
            .join(SPACE$2);
        const normalUAValue = [
            ...defaultUserAgent.filter((section) => section.startsWith("aws-sdk-")),
            ...customUserAgent,
        ].join(SPACE$2);
        if (options.runtime !== "browser") {
            if (normalUAValue) {
                headers[X_AMZ_USER_AGENT$2] = headers[X_AMZ_USER_AGENT$2]
                    ? `${headers[USER_AGENT$2]} ${normalUAValue}`
                    : normalUAValue;
            }
            headers[USER_AGENT$2] = sdkUserAgentValue;
        }
        else {
            headers[X_AMZ_USER_AGENT$2] = sdkUserAgentValue;
        }
        return next({
            ...args,
            request,
        });
    };
    const escapeUserAgent$2 = (userAgentPair) => {
        const name = userAgentPair[0]
            .split(UA_NAME_SEPARATOR$2)
            .map((part) => part.replace(UA_NAME_ESCAPE_REGEX$2, UA_ESCAPE_CHAR$2))
            .join(UA_NAME_SEPARATOR$2);
        const version = userAgentPair[1]?.replace(UA_VALUE_ESCAPE_REGEX$2, UA_ESCAPE_CHAR$2);
        const prefixSeparatorIndex = name.indexOf(UA_NAME_SEPARATOR$2);
        const prefix = name.substring(0, prefixSeparatorIndex);
        let uaName = name.substring(prefixSeparatorIndex + 1);
        if (prefix === "api") {
            uaName = uaName.toLowerCase();
        }
        return [prefix, uaName, version]
            .filter((item) => item && item.length > 0)
            .reduce((acc, item, index) => {
            switch (index) {
                case 0:
                    return item;
                case 1:
                    return `${acc}/${item}`;
                default:
                    return `${acc}#${item}`;
            }
        }, "");
    };
    const getUserAgentMiddlewareOptions$2 = {
        name: "getUserAgentMiddleware",
        step: "build",
        priority: "low",
        tags: ["SET_USER_AGENT", "USER_AGENT"],
        override: true,
    };
    const getUserAgentPlugin$2 = (config) => ({
        applyToStack: (clientStack) => {
            clientStack.add(userAgentMiddleware$2(config), getUserAgentMiddlewareOptions$2);
        },
    });

    const CONTENT_LENGTH_HEADER$2 = "content-length";
    function contentLengthMiddleware$2(bodyLengthChecker) {
        return (next) => async (args) => {
            const request = args.request;
            if (HttpRequest$3.isInstance(request)) {
                const { body, headers } = request;
                if (body &&
                    Object.keys(headers)
                        .map((str) => str.toLowerCase())
                        .indexOf(CONTENT_LENGTH_HEADER$2) === -1) {
                    try {
                        const length = bodyLengthChecker(body);
                        request.headers = {
                            ...request.headers,
                            [CONTENT_LENGTH_HEADER$2]: String(length),
                        };
                    }
                    catch (error) {
                    }
                }
            }
            return next({
                ...args,
                request,
            });
        };
    }
    const contentLengthMiddlewareOptions$2 = {
        step: "build",
        tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
        name: "contentLengthMiddleware",
        override: true,
    };
    const getContentLengthPlugin$2 = (options) => ({
        applyToStack: (clientStack) => {
            clientStack.add(contentLengthMiddleware$2(options.bodyLengthChecker), contentLengthMiddlewareOptions$2);
        },
    });

    const asSdkError$2 = (error) => {
        if (error instanceof Error)
            return error;
        if (error instanceof Object)
            return Object.assign(new Error(), error);
        if (typeof error === "string")
            return new Error(error);
        return new Error(`AWS SDK error wrapper for ${error}`);
    };

    const resolveRetryConfig$2 = (input) => {
        const { retryStrategy } = input;
        const maxAttempts = normalizeProvider$3(input.maxAttempts ?? DEFAULT_MAX_ATTEMPTS$2);
        return {
            ...input,
            maxAttempts,
            retryStrategy: async () => {
                if (retryStrategy) {
                    return retryStrategy;
                }
                const retryMode = await normalizeProvider$3(input.retryMode)();
                if (retryMode === RETRY_MODES$2.ADAPTIVE) {
                    return new AdaptiveRetryStrategy$2(maxAttempts);
                }
                return new StandardRetryStrategy$2(maxAttempts);
            },
        };
    };

    const isStreamingPayload$2 = (request) => request?.body instanceof ReadableStream;

    const retryMiddleware$2 = (options) => (next, context) => async (args) => {
        let retryStrategy = await options.retryStrategy();
        const maxAttempts = await options.maxAttempts();
        if (isRetryStrategyV2$2(retryStrategy)) {
            retryStrategy = retryStrategy;
            let retryToken = await retryStrategy.acquireInitialRetryToken(context["partition_id"]);
            let lastError = new Error();
            let attempts = 0;
            let totalRetryDelay = 0;
            const { request } = args;
            const isRequest = HttpRequest$3.isInstance(request);
            if (isRequest) {
                request.headers[INVOCATION_ID_HEADER$2] = v4();
            }
            while (true) {
                try {
                    if (isRequest) {
                        request.headers[REQUEST_HEADER$2] = `attempt=${attempts + 1}; max=${maxAttempts}`;
                    }
                    const { response, output } = await next(args);
                    retryStrategy.recordSuccess(retryToken);
                    output.$metadata.attempts = attempts + 1;
                    output.$metadata.totalRetryDelay = totalRetryDelay;
                    return { response, output };
                }
                catch (e) {
                    const retryErrorInfo = getRetryErrorInfo$2(e);
                    lastError = asSdkError$2(e);
                    if (isRequest && isStreamingPayload$2(request)) {
                        (context.logger instanceof NoOpLogger$2 ? console : context.logger)?.warn("An error was encountered in a non-retryable streaming request.");
                        throw lastError;
                    }
                    try {
                        retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);
                    }
                    catch (refreshError) {
                        if (!lastError.$metadata) {
                            lastError.$metadata = {};
                        }
                        lastError.$metadata.attempts = attempts + 1;
                        lastError.$metadata.totalRetryDelay = totalRetryDelay;
                        throw lastError;
                    }
                    attempts = retryToken.getRetryCount();
                    const delay = retryToken.getRetryDelay();
                    totalRetryDelay += delay;
                    await new Promise((resolve) => setTimeout(resolve, delay));
                }
            }
        }
        else {
            retryStrategy = retryStrategy;
            if (retryStrategy?.mode)
                context.userAgent = [...(context.userAgent || []), ["cfg/retry-mode", retryStrategy.mode]];
            return retryStrategy.retry(next, args);
        }
    };
    const isRetryStrategyV2$2 = (retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== "undefined" &&
        typeof retryStrategy.refreshRetryTokenForRetry !== "undefined" &&
        typeof retryStrategy.recordSuccess !== "undefined";
    const getRetryErrorInfo$2 = (error) => {
        const errorInfo = {
            error,
            errorType: getRetryErrorType$2(error),
        };
        const retryAfterHint = getRetryAfterHint$2(error.$response);
        if (retryAfterHint) {
            errorInfo.retryAfterHint = retryAfterHint;
        }
        return errorInfo;
    };
    const getRetryErrorType$2 = (error) => {
        if (isThrottlingError$2(error))
            return "THROTTLING";
        if (isTransientError$2(error))
            return "TRANSIENT";
        if (isServerError$2(error))
            return "SERVER_ERROR";
        return "CLIENT_ERROR";
    };
    const retryMiddlewareOptions$2 = {
        name: "retryMiddleware",
        tags: ["RETRY"],
        step: "finalizeRequest",
        priority: "high",
        override: true,
    };
    const getRetryPlugin$2 = (options) => ({
        applyToStack: (clientStack) => {
            clientStack.add(retryMiddleware$2(options), retryMiddlewareOptions$2);
        },
    });
    const getRetryAfterHint$2 = (response) => {
        if (!HttpResponse$3.isInstance(response))
            return;
        const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
        if (!retryAfterHeaderName)
            return;
        const retryAfter = response.headers[retryAfterHeaderName];
        const retryAfterSeconds = Number(retryAfter);
        if (!Number.isNaN(retryAfterSeconds))
            return new Date(retryAfterSeconds * 1000);
        const retryAfterDate = new Date(retryAfter);
        return retryAfterDate;
    };

    class GeoMapsClient extends Client$2 {
        constructor(...[configuration]) {
            let _config_0 = getRuntimeConfig$8(configuration || {});
            let _config_1 = resolveRegionConfig$2(_config_0);
            let _config_2 = resolveEndpointsConfig$2(_config_1);
            let _config_3 = resolveRetryConfig$2(_config_2);
            let _config_4 = resolveHostHeaderConfig$2(_config_3);
            let _config_5 = resolveAwsAuthConfig(_config_4);
            let _config_6 = resolveUserAgentConfig$2(_config_5);
            let _config_7 = resolveRuntimeExtensions$4(_config_6, configuration?.extensions || []);
            super(_config_7);
            this.config = _config_7;
            this.middlewareStack.use(getRetryPlugin$2(this.config));
            this.middlewareStack.use(getContentLengthPlugin$2(this.config));
            this.middlewareStack.use(getHostHeaderPlugin$2(this.config));
            this.middlewareStack.use(getLoggerPlugin$2(this.config));
            this.middlewareStack.use(getRecursionDetectionPlugin$2(this.config));
            this.middlewareStack.use(getAwsAuthPlugin(this.config));
            this.middlewareStack.use(getUserAgentPlugin$2(this.config));
        }
        destroy() {
            super.destroy();
        }
    }

    class GeoMapsServiceException extends ServiceException$2 {
        constructor(options) {
            super(options);
            Object.setPrototypeOf(this, GeoMapsServiceException.prototype);
        }
    }

    let AccessDeniedException$2 = class AccessDeniedException extends GeoMapsServiceException {
        constructor(opts) {
            super({
                name: "AccessDeniedException",
                $fault: "client",
                ...opts
            });
            this.name = "AccessDeniedException";
            this.$fault = "client";
            Object.setPrototypeOf(this, AccessDeniedException.prototype);
            this.Message = opts.Message;
        }
    };
    let InternalServerException$2 = class InternalServerException extends GeoMapsServiceException {
        constructor(opts) {
            super({
                name: "InternalServerException",
                $fault: "server",
                ...opts
            });
            this.name = "InternalServerException";
            this.$fault = "server";
            this.$retryable = {};
            Object.setPrototypeOf(this, InternalServerException.prototype);
            this.Message = opts.Message;
        }
    };
    let ResourceNotFoundException$1 = class ResourceNotFoundException extends GeoMapsServiceException {
        constructor(opts) {
            super({
                name: "ResourceNotFoundException",
                $fault: "client",
                ...opts
            });
            this.name = "ResourceNotFoundException";
            this.$fault = "client";
            Object.setPrototypeOf(this, ResourceNotFoundException.prototype);
            this.Message = opts.Message;
        }
    };
    let ThrottlingException$2 = class ThrottlingException extends GeoMapsServiceException {
        constructor(opts) {
            super({
                name: "ThrottlingException",
                $fault: "client",
                ...opts
            });
            this.name = "ThrottlingException";
            this.$fault = "client";
            this.$retryable = {};
            Object.setPrototypeOf(this, ThrottlingException.prototype);
            this.Message = opts.Message;
        }
    };
    let ValidationException$2 = class ValidationException extends GeoMapsServiceException {
        constructor(opts) {
            super({
                name: "ValidationException",
                $fault: "client",
                ...opts
            });
            this.name = "ValidationException";
            this.$fault = "client";
            Object.setPrototypeOf(this, ValidationException.prototype);
            this.Message = opts.Message;
            this.Reason = opts.Reason;
            this.FieldList = opts.FieldList;
        }
    };
    const ColorScheme = {
        DARK: "Dark",
        LIGHT: "Light",
    };
    const MapStyle = {
        HYBRID: "Hybrid",
        MONOCHROME: "Monochrome",
        SATELLITE: "Satellite",
        STANDARD: "Standard",
    };
    const Variant = {
        DEFAULT: "Default",
        LOGISTICS: "Logistics",
    };
    const StaticMapAdditionalFeature = {
        PLACEHOLDER: "PLACEHOLDER",
    };
    const MapFeatureMode = {
        DISABLED: "Disabled",
        ENABLED: "Enabled",
    };
    const LabelSize = {
        LARGE: "Large",
        SMALL: "Small",
    };
    const ScaleBarUnit = {
        KILOMETERS: "Kilometers",
        KILOMETERS_MILES: "KilometersMiles",
        MILES: "Miles",
        MILES_KILOMETERS: "MilesKilometers",
    };
    const StaticMapStyle = {
        SATELLITE: "Satellite",
    };
    const GetStaticMapRequestFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Key && { Key: SENSITIVE_STRING$2
        }),
        ...(obj.KeyHeader && { KeyHeader: SENSITIVE_STRING$2
        }),
    });
    const GetStyleDescriptorRequestFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Key && { Key: SENSITIVE_STRING$2
        }),
        ...(obj.KeyHeader && { KeyHeader: SENSITIVE_STRING$2
        }),
    });
    const TileAdditionalFeature = {
        PLACEHOLDER: "PLACEHOLDER",
    };
    const GetTileRequestFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Key && { Key: SENSITIVE_STRING$2
        }),
        ...(obj.KeyHeader && { KeyHeader: SENSITIVE_STRING$2
        }),
    });

    const se_GetGlyphsCommand = async (input, context) => {
        const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
        const headers = {};
        let resolvedPath = `${basePath?.endsWith('/') ? basePath.slice(0, -1) : (basePath || '')}` + "/glyphs/{FontStack}/{FontUnicodeRange}";
        resolvedPath = resolvedPath$1(resolvedPath, input, 'FontStack', () => input.FontStack, '{FontStack}');
        resolvedPath = resolvedPath$1(resolvedPath, input, 'FontUnicodeRange', () => input.FontUnicodeRange, '{FontUnicodeRange}');
        const query = map$2({
            "version": [, input.Version],
        });
        let body;
        return new HttpRequest$3({
            protocol,
            hostname,
            port,
            method: "GET",
            headers,
            path: resolvedPath,
            query,
            body,
        });
    };
    const se_GetSpritesCommand = async (input, context) => {
        const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
        const headers = {};
        let resolvedPath = `${basePath?.endsWith('/') ? basePath.slice(0, -1) : (basePath || '')}` + "/styles/{Style}/{ColorScheme}/{Variant}/sprites/{FileName}";
        resolvedPath = resolvedPath$1(resolvedPath, input, 'FileName', () => input.FileName, '{FileName}');
        resolvedPath = resolvedPath$1(resolvedPath, input, 'Style', () => input.Style, '{Style}');
        resolvedPath = resolvedPath$1(resolvedPath, input, 'ColorScheme', () => input.ColorScheme, '{ColorScheme}');
        resolvedPath = resolvedPath$1(resolvedPath, input, 'Variant', () => input.Variant, '{Variant}');
        const query = map$2({
            "version": [, input.Version],
        });
        let body;
        return new HttpRequest$3({
            protocol,
            hostname,
            port,
            method: "GET",
            headers,
            path: resolvedPath,
            query,
            body,
        });
    };
    const se_GetStaticMapCommand = async (input, context) => {
        const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
        const headers = map$2({}, isSerializableHeaderValue$2, {
            'api-key': input.KeyHeader,
        });
        let resolvedPath = `${basePath?.endsWith('/') ? basePath.slice(0, -1) : (basePath || '')}` + "/static/{FileName}";
        resolvedPath = resolvedPath$1(resolvedPath, input, 'FileName', () => input.FileName, '{FileName}');
        const query = map$2({
            "additional-features": [() => input.AdditionalFeatures !== void 0, () => ((input.AdditionalFeatures || []).map(_entry => _entry))],
            "bounding-box": [, input.BoundingBox],
            "bounded-positions": [, input.BoundedPositions],
            "center": [, input.Center],
            "compact-overlay": [, input.CompactOverlay],
            "congestion-zones": [, input.CongestionZones],
            "crop-labels": [() => input.CropLabels !== void 0, () => (input.CropLabels.toString())],
            "environmental-zones": [, input.EnvironmentalZones],
            "geojson-overlay": [, input.GeoJsonOverlay],
            "height": [expectNonNull$2(input.Height, `Height`) != null, () => input.Height.toString()],
            "key": [, input.Key],
            "label-size": [, input.LabelSize],
            "lang": [, input.Language],
            "padding": [() => input.Padding !== void 0, () => (input.Padding.toString())],
            "political-view": [, input.PoliticalView],
            "pois": [, input.PointsOfInterests],
            "radius": [() => input.Radius !== void 0, () => (input.Radius.toString())],
            "scale-unit": [, input.ScaleBarUnit],
            "lang2": [, input.SecondaryLanguage],
            "style": [, input.Style],
            "width": [expectNonNull$2(input.Width, `Width`) != null, () => input.Width.toString()],
            "zoom": [() => input.Zoom !== void 0, () => (((input.Zoom % 1 == 0) ? input.Zoom + ".0" : input.Zoom.toString()))],
            "version": [, input.Version],
        });
        let body;
        return new HttpRequest$3({
            protocol,
            hostname,
            port,
            method: "GET",
            headers,
            path: resolvedPath,
            query,
            body,
        });
    };
    const se_GetStyleDescriptorCommand = async (input, context) => {
        const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
        const headers = map$2({}, isSerializableHeaderValue$2, {
            'api-key': input.KeyHeader,
        });
        let resolvedPath = `${basePath?.endsWith('/') ? basePath.slice(0, -1) : (basePath || '')}` + "/styles/{Style}/descriptor";
        resolvedPath = resolvedPath$1(resolvedPath, input, 'Style', () => input.Style, '{Style}');
        const query = map$2({
            "color-scheme": [, input.ColorScheme],
            "political-view": [, input.PoliticalView],
            "variant": [, input.Variant],
            "version": [, input.Version],
            "key": [, input.Key],
        });
        let body;
        return new HttpRequest$3({
            protocol,
            hostname,
            port,
            method: "GET",
            headers,
            path: resolvedPath,
            query,
            body,
        });
    };
    const se_GetTileCommand = async (input, context) => {
        const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
        const headers = map$2({}, isSerializableHeaderValue$2, {
            'api-key': input.KeyHeader,
        });
        let resolvedPath = `${basePath?.endsWith('/') ? basePath.slice(0, -1) : (basePath || '')}` + "/tiles/{Tileset}/{Z}/{X}/{Y}";
        resolvedPath = resolvedPath$1(resolvedPath, input, 'Tileset', () => input.Tileset, '{Tileset}');
        resolvedPath = resolvedPath$1(resolvedPath, input, 'Z', () => input.Z, '{Z}');
        resolvedPath = resolvedPath$1(resolvedPath, input, 'X', () => input.X, '{X}');
        resolvedPath = resolvedPath$1(resolvedPath, input, 'Y', () => input.Y, '{Y}');
        const query = map$2({
            "additional-features": [() => input.AdditionalFeatures !== void 0, () => ((input.AdditionalFeatures || []).map(_entry => _entry))],
            "version": [, input.Version],
            "key": [, input.Key],
        });
        let body;
        return new HttpRequest$3({
            protocol,
            hostname,
            port,
            method: "GET",
            headers,
            path: resolvedPath,
            query,
            body,
        });
    };
    const de_GetGlyphsCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_GetGlyphsCommandError(output, context);
        }
        const contents = map$2({
            $metadata: deserializeMetadata$6(output),
            ContentType: [, output.headers['content-type']],
            CacheControl: [, output.headers['cache-control']],
            Expires: [, output.headers['expires']],
            ETag: [, output.headers['etag']],
            PricingBucket: [, output.headers['x-amz-geo-pricing-bucket']],
        });
        const data = await collectBody$2(output.body, context);
        contents.Blob = data;
        return contents;
    };
    const de_GetGlyphsCommandError = async (output, context) => {
        const parsedOutput = {
            ...output,
            body: await parseErrorBody$2(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode$2(output, parsedOutput.body);
        switch (errorCode) {
            case "AccessDeniedException":
            case "com.amazonaws.services.waypoint.exceptions#AccessDeniedException":
                throw await de_AccessDeniedExceptionRes$2(parsedOutput);
            case "InternalServerException":
            case "com.amazonaws.services.waypoint.exceptions#InternalServerException":
                throw await de_InternalServerExceptionRes$2(parsedOutput);
            case "ResourceNotFoundException":
            case "com.amazonaws.services.waypoint.exceptions#ResourceNotFoundException":
                throw await de_ResourceNotFoundExceptionRes$1(parsedOutput);
            case "ThrottlingException":
            case "com.amazonaws.services.waypoint.exceptions#ThrottlingException":
                throw await de_ThrottlingExceptionRes$2(parsedOutput);
            default:
                const parsedBody = parsedOutput.body;
                return throwDefaultError$6({
                    output,
                    parsedBody,
                    errorCode
                });
        }
    };
    const de_GetSpritesCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_GetSpritesCommandError(output, context);
        }
        const contents = map$2({
            $metadata: deserializeMetadata$6(output),
            ContentType: [, output.headers['content-type']],
            CacheControl: [, output.headers['cache-control']],
            Expires: [, output.headers['expires']],
            ETag: [, output.headers['etag']],
            PricingBucket: [, output.headers['x-amz-geo-pricing-bucket']],
        });
        const data = await collectBody$2(output.body, context);
        contents.Blob = data;
        return contents;
    };
    const de_GetSpritesCommandError = async (output, context) => {
        const parsedOutput = {
            ...output,
            body: await parseErrorBody$2(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode$2(output, parsedOutput.body);
        switch (errorCode) {
            case "AccessDeniedException":
            case "com.amazonaws.services.waypoint.exceptions#AccessDeniedException":
                throw await de_AccessDeniedExceptionRes$2(parsedOutput);
            case "InternalServerException":
            case "com.amazonaws.services.waypoint.exceptions#InternalServerException":
                throw await de_InternalServerExceptionRes$2(parsedOutput);
            case "ResourceNotFoundException":
            case "com.amazonaws.services.waypoint.exceptions#ResourceNotFoundException":
                throw await de_ResourceNotFoundExceptionRes$1(parsedOutput);
            case "ThrottlingException":
            case "com.amazonaws.services.waypoint.exceptions#ThrottlingException":
                throw await de_ThrottlingExceptionRes$2(parsedOutput);
            default:
                const parsedBody = parsedOutput.body;
                return throwDefaultError$6({
                    output,
                    parsedBody,
                    errorCode
                });
        }
    };
    const de_GetStaticMapCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_GetStaticMapCommandError(output, context);
        }
        const contents = map$2({
            $metadata: deserializeMetadata$6(output),
            ContentType: [, output.headers['content-type']],
            CacheControl: [, output.headers['cache-control']],
            ETag: [, output.headers['etag']],
            PricingBucket: [, output.headers['x-amz-geo-pricing-bucket']],
        });
        const data = await collectBody$2(output.body, context);
        contents.Blob = data;
        return contents;
    };
    const de_GetStaticMapCommandError = async (output, context) => {
        const parsedOutput = {
            ...output,
            body: await parseErrorBody$2(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode$2(output, parsedOutput.body);
        switch (errorCode) {
            case "AccessDeniedException":
            case "com.amazonaws.services.waypoint.exceptions#AccessDeniedException":
                throw await de_AccessDeniedExceptionRes$2(parsedOutput);
            case "InternalServerException":
            case "com.amazonaws.services.waypoint.exceptions#InternalServerException":
                throw await de_InternalServerExceptionRes$2(parsedOutput);
            case "ThrottlingException":
            case "com.amazonaws.services.waypoint.exceptions#ThrottlingException":
                throw await de_ThrottlingExceptionRes$2(parsedOutput);
            case "ValidationException":
            case "com.amazonaws.services.waypoint.exceptions#ValidationException":
                throw await de_ValidationExceptionRes$2(parsedOutput);
            default:
                const parsedBody = parsedOutput.body;
                return throwDefaultError$6({
                    output,
                    parsedBody,
                    errorCode
                });
        }
    };
    const de_GetStyleDescriptorCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_GetStyleDescriptorCommandError(output, context);
        }
        const contents = map$2({
            $metadata: deserializeMetadata$6(output),
            ContentType: [, output.headers['content-type']],
            CacheControl: [, output.headers['cache-control']],
            Expires: [, output.headers['expires']],
            ETag: [, output.headers['etag']],
            PricingBucket: [, output.headers['x-amz-geo-pricing-bucket']],
        });
        const data = await collectBody$2(output.body, context);
        contents.Blob = data;
        return contents;
    };
    const de_GetStyleDescriptorCommandError = async (output, context) => {
        const parsedOutput = {
            ...output,
            body: await parseErrorBody$2(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode$2(output, parsedOutput.body);
        switch (errorCode) {
            case "AccessDeniedException":
            case "com.amazonaws.services.waypoint.exceptions#AccessDeniedException":
                throw await de_AccessDeniedExceptionRes$2(parsedOutput);
            case "InternalServerException":
            case "com.amazonaws.services.waypoint.exceptions#InternalServerException":
                throw await de_InternalServerExceptionRes$2(parsedOutput);
            case "ThrottlingException":
            case "com.amazonaws.services.waypoint.exceptions#ThrottlingException":
                throw await de_ThrottlingExceptionRes$2(parsedOutput);
            case "ValidationException":
            case "com.amazonaws.services.waypoint.exceptions#ValidationException":
                throw await de_ValidationExceptionRes$2(parsedOutput);
            default:
                const parsedBody = parsedOutput.body;
                return throwDefaultError$6({
                    output,
                    parsedBody,
                    errorCode
                });
        }
    };
    const de_GetTileCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_GetTileCommandError(output, context);
        }
        const contents = map$2({
            $metadata: deserializeMetadata$6(output),
            ContentType: [, output.headers['content-type']],
            CacheControl: [, output.headers['cache-control']],
            Expires: [, output.headers['expires']],
            ETag: [, output.headers['etag']],
            PricingBucket: [, output.headers['x-amz-geo-pricing-bucket']],
        });
        const data = await collectBody$2(output.body, context);
        contents.Blob = data;
        return contents;
    };
    const de_GetTileCommandError = async (output, context) => {
        const parsedOutput = {
            ...output,
            body: await parseErrorBody$2(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode$2(output, parsedOutput.body);
        switch (errorCode) {
            case "AccessDeniedException":
            case "com.amazonaws.services.waypoint.exceptions#AccessDeniedException":
                throw await de_AccessDeniedExceptionRes$2(parsedOutput);
            case "InternalServerException":
            case "com.amazonaws.services.waypoint.exceptions#InternalServerException":
                throw await de_InternalServerExceptionRes$2(parsedOutput);
            case "ThrottlingException":
            case "com.amazonaws.services.waypoint.exceptions#ThrottlingException":
                throw await de_ThrottlingExceptionRes$2(parsedOutput);
            case "ValidationException":
            case "com.amazonaws.services.waypoint.exceptions#ValidationException":
                throw await de_ValidationExceptionRes$2(parsedOutput);
            default:
                const parsedBody = parsedOutput.body;
                return throwDefaultError$6({
                    output,
                    parsedBody,
                    errorCode
                });
        }
    };
    const throwDefaultError$6 = withBaseException$2(GeoMapsServiceException);
    const de_AccessDeniedExceptionRes$2 = async (parsedOutput, context) => {
        const contents = map$2({});
        const data = parsedOutput.body;
        const doc = take$2(data, {
            'Message': [, expectString$2, `message`],
        });
        Object.assign(contents, doc);
        const exception = new AccessDeniedException$2({
            $metadata: deserializeMetadata$6(parsedOutput),
            ...contents
        });
        return decorateServiceException$2(exception, parsedOutput.body);
    };
    const de_InternalServerExceptionRes$2 = async (parsedOutput, context) => {
        const contents = map$2({});
        const data = parsedOutput.body;
        const doc = take$2(data, {
            'Message': [, expectString$2, `message`],
        });
        Object.assign(contents, doc);
        const exception = new InternalServerException$2({
            $metadata: deserializeMetadata$6(parsedOutput),
            ...contents
        });
        return decorateServiceException$2(exception, parsedOutput.body);
    };
    const de_ResourceNotFoundExceptionRes$1 = async (parsedOutput, context) => {
        const contents = map$2({});
        const data = parsedOutput.body;
        const doc = take$2(data, {
            'Message': [, expectString$2, `message`],
        });
        Object.assign(contents, doc);
        const exception = new ResourceNotFoundException$1({
            $metadata: deserializeMetadata$6(parsedOutput),
            ...contents
        });
        return decorateServiceException$2(exception, parsedOutput.body);
    };
    const de_ThrottlingExceptionRes$2 = async (parsedOutput, context) => {
        const contents = map$2({});
        const data = parsedOutput.body;
        const doc = take$2(data, {
            'Message': [, expectString$2, `message`],
        });
        Object.assign(contents, doc);
        const exception = new ThrottlingException$2({
            $metadata: deserializeMetadata$6(parsedOutput),
            ...contents
        });
        return decorateServiceException$2(exception, parsedOutput.body);
    };
    const de_ValidationExceptionRes$2 = async (parsedOutput, context) => {
        const contents = map$2({});
        const data = parsedOutput.body;
        const doc = take$2(data, {
            'FieldList': [, _ => de_ValidationExceptionFieldList$2(_), `fieldList`],
            'Message': [, expectString$2, `message`],
            'Reason': [, expectString$2, `reason`],
        });
        Object.assign(contents, doc);
        const exception = new ValidationException$2({
            $metadata: deserializeMetadata$6(parsedOutput),
            ...contents
        });
        return decorateServiceException$2(exception, parsedOutput.body);
    };
    const de_ValidationExceptionField$2 = (output, context) => {
        return take$2(output, {
            'Message': [, expectString$2, `message`],
            'Name': [, expectString$2, `name`],
        });
    };
    const de_ValidationExceptionFieldList$2 = (output, context) => {
        const retVal = (output || []).filter((e) => e != null).map((entry) => {
            return de_ValidationExceptionField$2(entry);
        });
        return retVal;
    };
    const deserializeMetadata$6 = (output) => ({
        httpStatusCode: output.statusCode,
        requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
        extendedRequestId: output.headers["x-amz-id-2"],
        cfId: output.headers["x-amz-cf-id"],
    });
    const collectBodyString$2 = (streamBody, context) => collectBody$2(streamBody, context).then(body => context.utf8Encoder(body));
    const isSerializableHeaderValue$2 = (value) => value !== undefined &&
        value !== null &&
        value !== "" &&
        (!Object.getOwnPropertyNames(value).includes("length") ||
            value.length != 0) &&
        (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
    const parseBody$2 = (streamBody, context) => collectBodyString$2(streamBody, context).then(encoded => {
        if (encoded.length) {
            return JSON.parse(encoded);
        }
        return {};
    });
    const parseErrorBody$2 = async (errorBody, context) => {
        const value = await parseBody$2(errorBody, context);
        value.message = value.message ?? value.Message;
        return value;
    };
    const loadRestJsonErrorCode$2 = (output, data) => {
        const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
        const sanitizeErrorCode = (rawValue) => {
            let cleanValue = rawValue;
            if (typeof cleanValue === "number") {
                cleanValue = cleanValue.toString();
            }
            if (cleanValue.indexOf(",") >= 0) {
                cleanValue = cleanValue.split(",")[0];
            }
            if (cleanValue.indexOf(":") >= 0) {
                cleanValue = cleanValue.split(":")[0];
            }
            if (cleanValue.indexOf("#") >= 0) {
                cleanValue = cleanValue.split("#")[1];
            }
            return cleanValue;
        };
        const headerKey = findKey(output.headers, "x-amzn-errortype");
        if (headerKey !== undefined) {
            return sanitizeErrorCode(output.headers[headerKey]);
        }
        if (data.code !== undefined) {
            return sanitizeErrorCode(data.code);
        }
        if (data["__type"] !== undefined) {
            return sanitizeErrorCode(data["__type"]);
        }
    };

    const deserializerMiddleware$2 = (options, deserializer) => (next, context) => async (args) => {
        const { response } = await next(args);
        try {
            const parsed = await deserializer(response, options);
            return {
                response,
                output: parsed,
            };
        }
        catch (error) {
            Object.defineProperty(error, "$response", {
                value: response,
            });
            if (!("$metadata" in error)) {
                const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
                error.message += "\n  " + hint;
                if (typeof error.$responseBodyText !== "undefined") {
                    if (error.$response) {
                        error.$response.body = error.$responseBodyText;
                    }
                }
            }
            throw error;
        }
    };

    const serializerMiddleware$2 = (options, serializer) => (next, context) => async (args) => {
        const endpoint = context.endpointV2?.url && options.urlParser
            ? async () => options.urlParser(context.endpointV2.url)
            : options.endpoint;
        if (!endpoint) {
            throw new Error("No valid endpoint provider available.");
        }
        const request = await serializer(args.input, { ...options, endpoint });
        return next({
            ...args,
            request,
        });
    };

    const deserializerMiddlewareOption$2 = {
        name: "deserializerMiddleware",
        step: "deserialize",
        tags: ["DESERIALIZER"],
        override: true,
    };
    const serializerMiddlewareOption$2 = {
        name: "serializerMiddleware",
        step: "serialize",
        tags: ["SERIALIZER"],
        override: true,
    };
    function getSerdePlugin$2(config, serializer, deserializer) {
        return {
            applyToStack: (commandStack) => {
                commandStack.add(deserializerMiddleware$2(config, deserializer), deserializerMiddlewareOption$2);
                commandStack.add(serializerMiddleware$2(config, serializer), serializerMiddlewareOption$2);
            },
        };
    }

    class GetGlyphsCommand extends Command$2 {
        constructor(input) {
            super();
            this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
            this.middlewareStack.use(getSerdePlugin$2(configuration, this.serialize, this.deserialize));
            const stack = clientStack.concat(this.middlewareStack);
            const { logger } = configuration;
            const clientName = "GeoMapsClient";
            const commandName = "GetGlyphsCommand";
            const handlerExecutionContext = {
                logger,
                clientName,
                commandName,
                inputFilterSensitiveLog: (_) => _,
                outputFilterSensitiveLog: (_) => _,
                [SMITHY_CONTEXT_KEY$2]: {
                    service: "MapsService",
                    operation: "GetGlyphs",
                },
            };
            const { requestHandler } = configuration;
            return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
            return se_GetGlyphsCommand(input, context);
        }
        deserialize(output, context) {
            return de_GetGlyphsCommand(output, context);
        }
    }

    class GetSpritesCommand extends Command$2 {
        constructor(input) {
            super();
            this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
            this.middlewareStack.use(getSerdePlugin$2(configuration, this.serialize, this.deserialize));
            const stack = clientStack.concat(this.middlewareStack);
            const { logger } = configuration;
            const clientName = "GeoMapsClient";
            const commandName = "GetSpritesCommand";
            const handlerExecutionContext = {
                logger,
                clientName,
                commandName,
                inputFilterSensitiveLog: (_) => _,
                outputFilterSensitiveLog: (_) => _,
                [SMITHY_CONTEXT_KEY$2]: {
                    service: "MapsService",
                    operation: "GetSprites",
                },
            };
            const { requestHandler } = configuration;
            return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
            return se_GetSpritesCommand(input, context);
        }
        deserialize(output, context) {
            return de_GetSpritesCommand(output, context);
        }
    }

    class GetStaticMapCommand extends Command$2 {
        constructor(input) {
            super();
            this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
            this.middlewareStack.use(getSerdePlugin$2(configuration, this.serialize, this.deserialize));
            const stack = clientStack.concat(this.middlewareStack);
            const { logger } = configuration;
            const clientName = "GeoMapsClient";
            const commandName = "GetStaticMapCommand";
            const handlerExecutionContext = {
                logger,
                clientName,
                commandName,
                inputFilterSensitiveLog: GetStaticMapRequestFilterSensitiveLog,
                outputFilterSensitiveLog: (_) => _,
                [SMITHY_CONTEXT_KEY$2]: {
                    service: "MapsService",
                    operation: "GetStaticMap",
                },
            };
            const { requestHandler } = configuration;
            return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
            return se_GetStaticMapCommand(input, context);
        }
        deserialize(output, context) {
            return de_GetStaticMapCommand(output, context);
        }
    }

    class GetStyleDescriptorCommand extends Command$2 {
        constructor(input) {
            super();
            this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
            this.middlewareStack.use(getSerdePlugin$2(configuration, this.serialize, this.deserialize));
            const stack = clientStack.concat(this.middlewareStack);
            const { logger } = configuration;
            const clientName = "GeoMapsClient";
            const commandName = "GetStyleDescriptorCommand";
            const handlerExecutionContext = {
                logger,
                clientName,
                commandName,
                inputFilterSensitiveLog: GetStyleDescriptorRequestFilterSensitiveLog,
                outputFilterSensitiveLog: (_) => _,
                [SMITHY_CONTEXT_KEY$2]: {
                    service: "MapsService",
                    operation: "GetStyleDescriptor",
                },
            };
            const { requestHandler } = configuration;
            return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
            return se_GetStyleDescriptorCommand(input, context);
        }
        deserialize(output, context) {
            return de_GetStyleDescriptorCommand(output, context);
        }
    }

    class GetTileCommand extends Command$2 {
        constructor(input) {
            super();
            this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
            this.middlewareStack.use(getSerdePlugin$2(configuration, this.serialize, this.deserialize));
            const stack = clientStack.concat(this.middlewareStack);
            const { logger } = configuration;
            const clientName = "GeoMapsClient";
            const commandName = "GetTileCommand";
            const handlerExecutionContext = {
                logger,
                clientName,
                commandName,
                inputFilterSensitiveLog: GetTileRequestFilterSensitiveLog,
                outputFilterSensitiveLog: (_) => _,
                [SMITHY_CONTEXT_KEY$2]: {
                    service: "MapsService",
                    operation: "GetTile",
                },
            };
            const { requestHandler } = configuration;
            return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
            return se_GetTileCommand(input, context);
        }
        deserialize(output, context) {
            return de_GetTileCommand(output, context);
        }
    }

    const commands$2 = {
        GetGlyphsCommand,
        GetSpritesCommand,
        GetStaticMapCommand,
        GetStyleDescriptorCommand,
        GetTileCommand,
    };
    class GeoMaps extends GeoMapsClient {
    }
    createAggregatedClient$2(commands$2, GeoMaps);

    var index$3 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        $Command: Command$2,
        AccessDeniedException: AccessDeniedException$2,
        ColorScheme: ColorScheme,
        GeoMaps: GeoMaps,
        GeoMapsClient: GeoMapsClient,
        GeoMapsServiceException: GeoMapsServiceException,
        GetGlyphsCommand: GetGlyphsCommand,
        GetSpritesCommand: GetSpritesCommand,
        GetStaticMapCommand: GetStaticMapCommand,
        GetStaticMapRequestFilterSensitiveLog: GetStaticMapRequestFilterSensitiveLog,
        GetStyleDescriptorCommand: GetStyleDescriptorCommand,
        GetStyleDescriptorRequestFilterSensitiveLog: GetStyleDescriptorRequestFilterSensitiveLog,
        GetTileCommand: GetTileCommand,
        GetTileRequestFilterSensitiveLog: GetTileRequestFilterSensitiveLog,
        InternalServerException: InternalServerException$2,
        LabelSize: LabelSize,
        MapFeatureMode: MapFeatureMode,
        MapStyle: MapStyle,
        ResourceNotFoundException: ResourceNotFoundException$1,
        ScaleBarUnit: ScaleBarUnit,
        StaticMapAdditionalFeature: StaticMapAdditionalFeature,
        StaticMapStyle: StaticMapStyle,
        ThrottlingException: ThrottlingException$2,
        TileAdditionalFeature: TileAdditionalFeature,
        ValidationException: ValidationException$2,
        Variant: Variant,
        __Client: Client$2
    });

    var name$3 = "@amzn/geoplaces-client";
    var description$3 = "@amzn/geoplaces-client client";
    var version$3 = "0.0.1";
    var scripts$3 = {
    	build: "concurrently 'npm:build:cjs' 'npm:build:es' 'npm:build:types'",
    	"build:cjs": "tsc -p tsconfig.cjs.json",
    	"build:docs": "typedoc",
    	"build:es": "tsc -p tsconfig.es.json",
    	"build:types": "tsc -p tsconfig.types.json",
    	"build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    	clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    	prepack: "npm run clean && npm run build"
    };
    var main$3 = "./dist-cjs/index.js";
    var types$3 = "./dist-types/index.d.ts";
    var module$3 = "./dist-es/index.js";
    var sideEffects$3 = false;
    var dependencies$3 = {
    	tslib: "^2.5.0",
    	"@aws-crypto/sha256-browser": "3.0.0",
    	"@aws-crypto/sha256-js": "3.0.0",
    	"@aws-sdk/client-sts": "3.441.0",
    	"@aws-sdk/core": "3.441.0",
    	"@aws-sdk/credential-provider-node": "3.441.0",
    	"@aws-sdk/middleware-host-header": "3.433.0",
    	"@aws-sdk/middleware-logger": "3.433.0",
    	"@aws-sdk/middleware-recursion-detection": "3.433.0",
    	"@aws-sdk/middleware-signing": "3.433.0",
    	"@aws-sdk/middleware-user-agent": "3.438.0",
    	"@aws-sdk/region-config-resolver": "3.433.0",
    	"@aws-sdk/types": "3.433.0",
    	"@aws-sdk/util-user-agent-browser": "3.433.0",
    	"@aws-sdk/util-user-agent-node": "3.437.0",
    	"@smithy/config-resolver": "^2.0.16",
    	"@smithy/fetch-http-handler": "^2.2.4",
    	"@smithy/hash-node": "^2.0.12",
    	"@smithy/invalid-dependency": "^2.0.12",
    	"@smithy/middleware-content-length": "^2.0.14",
    	"@smithy/middleware-retry": "^2.0.18",
    	"@smithy/middleware-serde": "^2.0.12",
    	"@smithy/middleware-stack": "^2.0.6",
    	"@smithy/node-config-provider": "^2.1.3",
    	"@smithy/node-http-handler": "^2.1.8",
    	"@smithy/protocol-http": "^3.0.8",
    	"@smithy/smithy-client": "^2.1.12",
    	"@smithy/types": "^2.4.0",
    	"@smithy/url-parser": "^2.0.12",
    	"@smithy/util-base64": "^2.0.0",
    	"@smithy/util-body-length-browser": "^2.0.0",
    	"@smithy/util-body-length-node": "^2.1.0",
    	"@smithy/util-defaults-mode-browser": "^2.0.16",
    	"@smithy/util-defaults-mode-node": "^2.0.21",
    	"@smithy/util-retry": "^2.0.5",
    	"@smithy/util-utf8": "^2.0.0"
    };
    var devDependencies$3 = {
    	"@tsconfig/node14": "1.0.3",
    	concurrently: "7.0.0",
    	"downlevel-dts": "0.10.1",
    	rimraf: "^3.0.0",
    	typedoc: "0.23.23",
    	typescript: "~4.9.5",
    	"@smithy/service-client-documentation-generator": "^2.0.0",
    	"@types/node": "^14.14.31"
    };
    var engines$3 = {
    	node: ">=14.0.0"
    };
    var typesVersions$3 = {
    	"<4.0": {
    		"dist-types/*": [
    			"dist-types/ts3.4/*"
    		]
    	}
    };
    var files$3 = [
    	"dist-*/**"
    ];
    var browser$3 = {
    	"./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
    };
    var packageInfo$3 = {
    	name: name$3,
    	description: description$3,
    	version: version$3,
    	scripts: scripts$3,
    	main: main$3,
    	types: types$3,
    	module: module$3,
    	sideEffects: sideEffects$3,
    	dependencies: dependencies$3,
    	devDependencies: devDependencies$3,
    	engines: engines$3,
    	typesVersions: typesVersions$3,
    	files: files$3,
    	browser: browser$3,
    	"react-native": {
    	"./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
    }
    };

    var build$7 = {};

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics$5 = function(d, b) {
        extendStatics$5 = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics$5(d, b);
    };

    function __extends$5(d, b) {
        extendStatics$5(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign$5 = function() {
        __assign$5 = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign$5.apply(this, arguments);
    };

    function __rest$5(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate$5(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param$5(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata$5(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter$5(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator$5(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __createBinding$5(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }

    function __exportStar$5(m, exports) {
        for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values$5(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read$5(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread$5() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read$5(arguments[i]));
        return ar;
    }

    function __spreadArrays$5() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __await$5(v) {
        return this instanceof __await$5 ? (this.v = v, this) : new __await$5(v);
    }

    function __asyncGenerator$5(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await$5 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator$5(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await$5(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues$5(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values$5 === "function" ? __values$5(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject$5(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    }
    function __importStar$5(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault$5(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    function __classPrivateFieldGet$5(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }

    function __classPrivateFieldSet$5(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    var tslib_es6$5 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        get __assign () { return __assign$5; },
        __asyncDelegator: __asyncDelegator$5,
        __asyncGenerator: __asyncGenerator$5,
        __asyncValues: __asyncValues$5,
        __await: __await$5,
        __awaiter: __awaiter$5,
        __classPrivateFieldGet: __classPrivateFieldGet$5,
        __classPrivateFieldSet: __classPrivateFieldSet$5,
        __createBinding: __createBinding$5,
        __decorate: __decorate$5,
        __exportStar: __exportStar$5,
        __extends: __extends$5,
        __generator: __generator$5,
        __importDefault: __importDefault$5,
        __importStar: __importStar$5,
        __makeTemplateObject: __makeTemplateObject$5,
        __metadata: __metadata$5,
        __param: __param$5,
        __read: __read$5,
        __rest: __rest$5,
        __spread: __spread$5,
        __spreadArrays: __spreadArrays$5,
        __values: __values$5
    });

    var require$$0$5 = /*@__PURE__*/getAugmentedNamespace(tslib_es6$5);

    var crossPlatformSha256$1 = {};

    var ie11Sha256$1 = {};

    var isEmptyData$3 = {};

    var hasRequiredIsEmptyData$3;

    function requireIsEmptyData$3 () {
    	if (hasRequiredIsEmptyData$3) return isEmptyData$3;
    	hasRequiredIsEmptyData$3 = 1;
    	Object.defineProperty(isEmptyData$3, "__esModule", { value: true });
    	isEmptyData$3.isEmptyData = void 0;
    	function isEmptyData(data) {
    	    if (typeof data === "string") {
    	        return data.length === 0;
    	    }
    	    return data.byteLength === 0;
    	}
    	isEmptyData$3.isEmptyData = isEmptyData;
    	
    	return isEmptyData$3;
    }

    var constants$3 = {};

    var hasRequiredConstants$3;

    function requireConstants$3 () {
    	if (hasRequiredConstants$3) return constants$3;
    	hasRequiredConstants$3 = 1;
    	(function (exports) {
    		Object.defineProperty(exports, "__esModule", { value: true });
    		exports.EMPTY_DATA_SHA_256 = exports.SHA_256_HMAC_ALGO = exports.SHA_256_HASH = void 0;
    		exports.SHA_256_HASH = { name: "SHA-256" };
    		exports.SHA_256_HMAC_ALGO = {
    		    name: "HMAC",
    		    hash: exports.SHA_256_HASH
    		};
    		exports.EMPTY_DATA_SHA_256 = new Uint8Array([
    		    227,
    		    176,
    		    196,
    		    66,
    		    152,
    		    252,
    		    28,
    		    20,
    		    154,
    		    251,
    		    244,
    		    200,
    		    153,
    		    111,
    		    185,
    		    36,
    		    39,
    		    174,
    		    65,
    		    228,
    		    100,
    		    155,
    		    147,
    		    76,
    		    164,
    		    149,
    		    153,
    		    27,
    		    120,
    		    82,
    		    184,
    		    85
    		]);
    		
    	} (constants$3));
    	return constants$3;
    }

    var hasRequiredIe11Sha256$1;

    function requireIe11Sha256$1 () {
    	if (hasRequiredIe11Sha256$1) return ie11Sha256$1;
    	hasRequiredIe11Sha256$1 = 1;
    	Object.defineProperty(ie11Sha256$1, "__esModule", { value: true });
    	ie11Sha256$1.Sha256 = void 0;
    	var isEmptyData_1 = requireIsEmptyData$3();
    	var constants_1 = requireConstants$3();
    	var util_utf8_browser_1 = require$$0$9;
    	var util_locate_window_1 = require$$5;
    	var Sha256 = /** @class */ (function () {
    	    function Sha256(secret) {
    	        this.secret = secret;
    	        this.reset();
    	    }
    	    Sha256.prototype.update = function (toHash) {
    	        var _this = this;
    	        if ((0, isEmptyData_1.isEmptyData)(toHash)) {
    	            return;
    	        }
    	        this.operation = this.operation.then(function (operation) {
    	            operation.onerror = function () {
    	                _this.operation = Promise.reject(new Error("Error encountered updating hash"));
    	            };
    	            operation.process(toArrayBufferView(toHash));
    	            return operation;
    	        });
    	        this.operation.catch(function () { });
    	    };
    	    Sha256.prototype.digest = function () {
    	        return this.operation.then(function (operation) {
    	            return new Promise(function (resolve, reject) {
    	                operation.onerror = function () {
    	                    reject(new Error("Error encountered finalizing hash"));
    	                };
    	                operation.oncomplete = function () {
    	                    if (operation.result) {
    	                        resolve(new Uint8Array(operation.result));
    	                    }
    	                    reject(new Error("Error encountered finalizing hash"));
    	                };
    	                operation.finish();
    	            });
    	        });
    	    };
    	    Sha256.prototype.reset = function () {
    	        if (this.secret) {
    	            this.operation = getKeyPromise(this.secret).then(function (keyData) {
    	                return (0, util_locate_window_1.locateWindow)().msCrypto.subtle.sign(constants_1.SHA_256_HMAC_ALGO, keyData);
    	            });
    	            this.operation.catch(function () { });
    	        }
    	        else {
    	            this.operation = Promise.resolve((0, util_locate_window_1.locateWindow)().msCrypto.subtle.digest("SHA-256"));
    	        }
    	    };
    	    return Sha256;
    	}());
    	ie11Sha256$1.Sha256 = Sha256;
    	function getKeyPromise(secret) {
    	    return new Promise(function (resolve, reject) {
    	        var keyOperation = (0, util_locate_window_1.locateWindow)().msCrypto.subtle.importKey("raw", toArrayBufferView(secret), constants_1.SHA_256_HMAC_ALGO, false, ["sign"]);
    	        keyOperation.oncomplete = function () {
    	            if (keyOperation.result) {
    	                resolve(keyOperation.result);
    	            }
    	            reject(new Error("ImportKey completed without importing key."));
    	        };
    	        keyOperation.onerror = function () {
    	            reject(new Error("ImportKey failed to import key."));
    	        };
    	    });
    	}
    	function toArrayBufferView(data) {
    	    if (typeof data === "string") {
    	        return (0, util_utf8_browser_1.fromUtf8)(data);
    	    }
    	    if (ArrayBuffer.isView(data)) {
    	        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    	    }
    	    return new Uint8Array(data);
    	}
    	
    	return ie11Sha256$1;
    }

    var webCryptoSha256$1 = {};

    var build$6 = {};

    var convertToBuffer$1 = {};

    var hasRequiredConvertToBuffer$1;

    function requireConvertToBuffer$1 () {
    	if (hasRequiredConvertToBuffer$1) return convertToBuffer$1;
    	hasRequiredConvertToBuffer$1 = 1;
    	// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
    	// SPDX-License-Identifier: Apache-2.0
    	Object.defineProperty(convertToBuffer$1, "__esModule", { value: true });
    	convertToBuffer$1.convertToBuffer = void 0;
    	var util_utf8_browser_1 = require$$0$9;
    	// Quick polyfill
    	var fromUtf8 = typeof Buffer !== "undefined" && Buffer.from
    	    ? function (input) { return Buffer.from(input, "utf8"); }
    	    : util_utf8_browser_1.fromUtf8;
    	function convertToBuffer(data) {
    	    // Already a Uint8, do nothing
    	    if (data instanceof Uint8Array)
    	        return data;
    	    if (typeof data === "string") {
    	        return fromUtf8(data);
    	    }
    	    if (ArrayBuffer.isView(data)) {
    	        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    	    }
    	    return new Uint8Array(data);
    	}
    	convertToBuffer$1.convertToBuffer = convertToBuffer;
    	
    	return convertToBuffer$1;
    }

    var isEmptyData$2 = {};

    var hasRequiredIsEmptyData$2;

    function requireIsEmptyData$2 () {
    	if (hasRequiredIsEmptyData$2) return isEmptyData$2;
    	hasRequiredIsEmptyData$2 = 1;
    	// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
    	// SPDX-License-Identifier: Apache-2.0
    	Object.defineProperty(isEmptyData$2, "__esModule", { value: true });
    	isEmptyData$2.isEmptyData = void 0;
    	function isEmptyData(data) {
    	    if (typeof data === "string") {
    	        return data.length === 0;
    	    }
    	    return data.byteLength === 0;
    	}
    	isEmptyData$2.isEmptyData = isEmptyData;
    	
    	return isEmptyData$2;
    }

    var numToUint8$1 = {};

    var hasRequiredNumToUint8$1;

    function requireNumToUint8$1 () {
    	if (hasRequiredNumToUint8$1) return numToUint8$1;
    	hasRequiredNumToUint8$1 = 1;
    	// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
    	// SPDX-License-Identifier: Apache-2.0
    	Object.defineProperty(numToUint8$1, "__esModule", { value: true });
    	numToUint8$1.numToUint8 = void 0;
    	function numToUint8(num) {
    	    return new Uint8Array([
    	        (num & 0xff000000) >> 24,
    	        (num & 0x00ff0000) >> 16,
    	        (num & 0x0000ff00) >> 8,
    	        num & 0x000000ff,
    	    ]);
    	}
    	numToUint8$1.numToUint8 = numToUint8;
    	
    	return numToUint8$1;
    }

    var uint32ArrayFrom$1 = {};

    var hasRequiredUint32ArrayFrom$1;

    function requireUint32ArrayFrom$1 () {
    	if (hasRequiredUint32ArrayFrom$1) return uint32ArrayFrom$1;
    	hasRequiredUint32ArrayFrom$1 = 1;
    	// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
    	// SPDX-License-Identifier: Apache-2.0
    	Object.defineProperty(uint32ArrayFrom$1, "__esModule", { value: true });
    	uint32ArrayFrom$1.uint32ArrayFrom = void 0;
    	// IE 11 does not support Array.from, so we do it manually
    	function uint32ArrayFrom(a_lookUpTable) {
    	    if (!Uint32Array.from) {
    	        var return_array = new Uint32Array(a_lookUpTable.length);
    	        var a_index = 0;
    	        while (a_index < a_lookUpTable.length) {
    	            return_array[a_index] = a_lookUpTable[a_index];
    	            a_index += 1;
    	        }
    	        return return_array;
    	    }
    	    return Uint32Array.from(a_lookUpTable);
    	}
    	uint32ArrayFrom$1.uint32ArrayFrom = uint32ArrayFrom;
    	
    	return uint32ArrayFrom$1;
    }

    var hasRequiredBuild$7;

    function requireBuild$7 () {
    	if (hasRequiredBuild$7) return build$6;
    	hasRequiredBuild$7 = 1;
    	(function (exports) {
    		// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
    		// SPDX-License-Identifier: Apache-2.0
    		Object.defineProperty(exports, "__esModule", { value: true });
    		exports.uint32ArrayFrom = exports.numToUint8 = exports.isEmptyData = exports.convertToBuffer = void 0;
    		var convertToBuffer_1 = requireConvertToBuffer$1();
    		Object.defineProperty(exports, "convertToBuffer", { enumerable: true, get: function () { return convertToBuffer_1.convertToBuffer; } });
    		var isEmptyData_1 = requireIsEmptyData$2();
    		Object.defineProperty(exports, "isEmptyData", { enumerable: true, get: function () { return isEmptyData_1.isEmptyData; } });
    		var numToUint8_1 = requireNumToUint8$1();
    		Object.defineProperty(exports, "numToUint8", { enumerable: true, get: function () { return numToUint8_1.numToUint8; } });
    		var uint32ArrayFrom_1 = requireUint32ArrayFrom$1();
    		Object.defineProperty(exports, "uint32ArrayFrom", { enumerable: true, get: function () { return uint32ArrayFrom_1.uint32ArrayFrom; } });
    		
    	} (build$6));
    	return build$6;
    }

    var hasRequiredWebCryptoSha256$1;

    function requireWebCryptoSha256$1 () {
    	if (hasRequiredWebCryptoSha256$1) return webCryptoSha256$1;
    	hasRequiredWebCryptoSha256$1 = 1;
    	Object.defineProperty(webCryptoSha256$1, "__esModule", { value: true });
    	webCryptoSha256$1.Sha256 = void 0;
    	var util_1 = requireBuild$7();
    	var constants_1 = requireConstants$3();
    	var util_locate_window_1 = require$$5;
    	var Sha256 = /** @class */ (function () {
    	    function Sha256(secret) {
    	        this.toHash = new Uint8Array(0);
    	        this.secret = secret;
    	        this.reset();
    	    }
    	    Sha256.prototype.update = function (data) {
    	        if ((0, util_1.isEmptyData)(data)) {
    	            return;
    	        }
    	        var update = (0, util_1.convertToBuffer)(data);
    	        var typedArray = new Uint8Array(this.toHash.byteLength + update.byteLength);
    	        typedArray.set(this.toHash, 0);
    	        typedArray.set(update, this.toHash.byteLength);
    	        this.toHash = typedArray;
    	    };
    	    Sha256.prototype.digest = function () {
    	        var _this = this;
    	        if (this.key) {
    	            return this.key.then(function (key) {
    	                return (0, util_locate_window_1.locateWindow)()
    	                    .crypto.subtle.sign(constants_1.SHA_256_HMAC_ALGO, key, _this.toHash)
    	                    .then(function (data) { return new Uint8Array(data); });
    	            });
    	        }
    	        if ((0, util_1.isEmptyData)(this.toHash)) {
    	            return Promise.resolve(constants_1.EMPTY_DATA_SHA_256);
    	        }
    	        return Promise.resolve()
    	            .then(function () {
    	            return (0, util_locate_window_1.locateWindow)().crypto.subtle.digest(constants_1.SHA_256_HASH, _this.toHash);
    	        })
    	            .then(function (data) { return Promise.resolve(new Uint8Array(data)); });
    	    };
    	    Sha256.prototype.reset = function () {
    	        var _this = this;
    	        this.toHash = new Uint8Array(0);
    	        if (this.secret && this.secret !== void 0) {
    	            this.key = new Promise(function (resolve, reject) {
    	                (0, util_locate_window_1.locateWindow)()
    	                    .crypto.subtle.importKey("raw", (0, util_1.convertToBuffer)(_this.secret), constants_1.SHA_256_HMAC_ALGO, false, ["sign"])
    	                    .then(resolve, reject);
    	            });
    	            this.key.catch(function () { });
    	        }
    	    };
    	    return Sha256;
    	}());
    	webCryptoSha256$1.Sha256 = Sha256;
    	
    	return webCryptoSha256$1;
    }

    var build$5 = {};

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics$4 = function(d, b) {
        extendStatics$4 = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics$4(d, b);
    };

    function __extends$4(d, b) {
        extendStatics$4(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign$4 = function() {
        __assign$4 = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign$4.apply(this, arguments);
    };

    function __rest$4(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate$4(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param$4(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata$4(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter$4(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator$4(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __createBinding$4(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }

    function __exportStar$4(m, exports) {
        for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values$4(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read$4(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread$4() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read$4(arguments[i]));
        return ar;
    }

    function __spreadArrays$4() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __await$4(v) {
        return this instanceof __await$4 ? (this.v = v, this) : new __await$4(v);
    }

    function __asyncGenerator$4(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await$4 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator$4(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await$4(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues$4(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values$4 === "function" ? __values$4(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject$4(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    }
    function __importStar$4(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault$4(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    function __classPrivateFieldGet$4(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }

    function __classPrivateFieldSet$4(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    var tslib_es6$4 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        get __assign () { return __assign$4; },
        __asyncDelegator: __asyncDelegator$4,
        __asyncGenerator: __asyncGenerator$4,
        __asyncValues: __asyncValues$4,
        __await: __await$4,
        __awaiter: __awaiter$4,
        __classPrivateFieldGet: __classPrivateFieldGet$4,
        __classPrivateFieldSet: __classPrivateFieldSet$4,
        __createBinding: __createBinding$4,
        __decorate: __decorate$4,
        __exportStar: __exportStar$4,
        __extends: __extends$4,
        __generator: __generator$4,
        __importDefault: __importDefault$4,
        __importStar: __importStar$4,
        __makeTemplateObject: __makeTemplateObject$4,
        __metadata: __metadata$4,
        __param: __param$4,
        __read: __read$4,
        __rest: __rest$4,
        __spread: __spread$4,
        __spreadArrays: __spreadArrays$4,
        __values: __values$4
    });

    var require$$0$4 = /*@__PURE__*/getAugmentedNamespace(tslib_es6$4);

    var jsSha256$1 = {};

    var constants$2 = {};

    var hasRequiredConstants$2;

    function requireConstants$2 () {
    	if (hasRequiredConstants$2) return constants$2;
    	hasRequiredConstants$2 = 1;
    	Object.defineProperty(constants$2, "__esModule", { value: true });
    	constants$2.MAX_HASHABLE_LENGTH = constants$2.INIT = constants$2.KEY = constants$2.DIGEST_LENGTH = constants$2.BLOCK_SIZE = void 0;
    	/**
    	 * @internal
    	 */
    	constants$2.BLOCK_SIZE = 64;
    	/**
    	 * @internal
    	 */
    	constants$2.DIGEST_LENGTH = 32;
    	/**
    	 * @internal
    	 */
    	constants$2.KEY = new Uint32Array([
    	    0x428a2f98,
    	    0x71374491,
    	    0xb5c0fbcf,
    	    0xe9b5dba5,
    	    0x3956c25b,
    	    0x59f111f1,
    	    0x923f82a4,
    	    0xab1c5ed5,
    	    0xd807aa98,
    	    0x12835b01,
    	    0x243185be,
    	    0x550c7dc3,
    	    0x72be5d74,
    	    0x80deb1fe,
    	    0x9bdc06a7,
    	    0xc19bf174,
    	    0xe49b69c1,
    	    0xefbe4786,
    	    0x0fc19dc6,
    	    0x240ca1cc,
    	    0x2de92c6f,
    	    0x4a7484aa,
    	    0x5cb0a9dc,
    	    0x76f988da,
    	    0x983e5152,
    	    0xa831c66d,
    	    0xb00327c8,
    	    0xbf597fc7,
    	    0xc6e00bf3,
    	    0xd5a79147,
    	    0x06ca6351,
    	    0x14292967,
    	    0x27b70a85,
    	    0x2e1b2138,
    	    0x4d2c6dfc,
    	    0x53380d13,
    	    0x650a7354,
    	    0x766a0abb,
    	    0x81c2c92e,
    	    0x92722c85,
    	    0xa2bfe8a1,
    	    0xa81a664b,
    	    0xc24b8b70,
    	    0xc76c51a3,
    	    0xd192e819,
    	    0xd6990624,
    	    0xf40e3585,
    	    0x106aa070,
    	    0x19a4c116,
    	    0x1e376c08,
    	    0x2748774c,
    	    0x34b0bcb5,
    	    0x391c0cb3,
    	    0x4ed8aa4a,
    	    0x5b9cca4f,
    	    0x682e6ff3,
    	    0x748f82ee,
    	    0x78a5636f,
    	    0x84c87814,
    	    0x8cc70208,
    	    0x90befffa,
    	    0xa4506ceb,
    	    0xbef9a3f7,
    	    0xc67178f2
    	]);
    	/**
    	 * @internal
    	 */
    	constants$2.INIT = [
    	    0x6a09e667,
    	    0xbb67ae85,
    	    0x3c6ef372,
    	    0xa54ff53a,
    	    0x510e527f,
    	    0x9b05688c,
    	    0x1f83d9ab,
    	    0x5be0cd19
    	];
    	/**
    	 * @internal
    	 */
    	constants$2.MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;
    	
    	return constants$2;
    }

    var RawSha256$1 = {};

    var hasRequiredRawSha256$1;

    function requireRawSha256$1 () {
    	if (hasRequiredRawSha256$1) return RawSha256$1;
    	hasRequiredRawSha256$1 = 1;
    	Object.defineProperty(RawSha256$1, "__esModule", { value: true });
    	RawSha256$1.RawSha256 = void 0;
    	var constants_1 = requireConstants$2();
    	/**
    	 * @internal
    	 */
    	var RawSha256 = /** @class */ (function () {
    	    function RawSha256() {
    	        this.state = Int32Array.from(constants_1.INIT);
    	        this.temp = new Int32Array(64);
    	        this.buffer = new Uint8Array(64);
    	        this.bufferLength = 0;
    	        this.bytesHashed = 0;
    	        /**
    	         * @internal
    	         */
    	        this.finished = false;
    	    }
    	    RawSha256.prototype.update = function (data) {
    	        if (this.finished) {
    	            throw new Error("Attempted to update an already finished hash.");
    	        }
    	        var position = 0;
    	        var byteLength = data.byteLength;
    	        this.bytesHashed += byteLength;
    	        if (this.bytesHashed * 8 > constants_1.MAX_HASHABLE_LENGTH) {
    	            throw new Error("Cannot hash more than 2^53 - 1 bits");
    	        }
    	        while (byteLength > 0) {
    	            this.buffer[this.bufferLength++] = data[position++];
    	            byteLength--;
    	            if (this.bufferLength === constants_1.BLOCK_SIZE) {
    	                this.hashBuffer();
    	                this.bufferLength = 0;
    	            }
    	        }
    	    };
    	    RawSha256.prototype.digest = function () {
    	        if (!this.finished) {
    	            var bitsHashed = this.bytesHashed * 8;
    	            var bufferView = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);
    	            var undecoratedLength = this.bufferLength;
    	            bufferView.setUint8(this.bufferLength++, 0x80);
    	            // Ensure the final block has enough room for the hashed length
    	            if (undecoratedLength % constants_1.BLOCK_SIZE >= constants_1.BLOCK_SIZE - 8) {
    	                for (var i = this.bufferLength; i < constants_1.BLOCK_SIZE; i++) {
    	                    bufferView.setUint8(i, 0);
    	                }
    	                this.hashBuffer();
    	                this.bufferLength = 0;
    	            }
    	            for (var i = this.bufferLength; i < constants_1.BLOCK_SIZE - 8; i++) {
    	                bufferView.setUint8(i, 0);
    	            }
    	            bufferView.setUint32(constants_1.BLOCK_SIZE - 8, Math.floor(bitsHashed / 0x100000000), true);
    	            bufferView.setUint32(constants_1.BLOCK_SIZE - 4, bitsHashed);
    	            this.hashBuffer();
    	            this.finished = true;
    	        }
    	        // The value in state is little-endian rather than big-endian, so flip
    	        // each word into a new Uint8Array
    	        var out = new Uint8Array(constants_1.DIGEST_LENGTH);
    	        for (var i = 0; i < 8; i++) {
    	            out[i * 4] = (this.state[i] >>> 24) & 0xff;
    	            out[i * 4 + 1] = (this.state[i] >>> 16) & 0xff;
    	            out[i * 4 + 2] = (this.state[i] >>> 8) & 0xff;
    	            out[i * 4 + 3] = (this.state[i] >>> 0) & 0xff;
    	        }
    	        return out;
    	    };
    	    RawSha256.prototype.hashBuffer = function () {
    	        var _a = this, buffer = _a.buffer, state = _a.state;
    	        var state0 = state[0], state1 = state[1], state2 = state[2], state3 = state[3], state4 = state[4], state5 = state[5], state6 = state[6], state7 = state[7];
    	        for (var i = 0; i < constants_1.BLOCK_SIZE; i++) {
    	            if (i < 16) {
    	                this.temp[i] =
    	                    ((buffer[i * 4] & 0xff) << 24) |
    	                        ((buffer[i * 4 + 1] & 0xff) << 16) |
    	                        ((buffer[i * 4 + 2] & 0xff) << 8) |
    	                        (buffer[i * 4 + 3] & 0xff);
    	            }
    	            else {
    	                var u = this.temp[i - 2];
    	                var t1_1 = ((u >>> 17) | (u << 15)) ^ ((u >>> 19) | (u << 13)) ^ (u >>> 10);
    	                u = this.temp[i - 15];
    	                var t2_1 = ((u >>> 7) | (u << 25)) ^ ((u >>> 18) | (u << 14)) ^ (u >>> 3);
    	                this.temp[i] =
    	                    ((t1_1 + this.temp[i - 7]) | 0) + ((t2_1 + this.temp[i - 16]) | 0);
    	            }
    	            var t1 = ((((((state4 >>> 6) | (state4 << 26)) ^
    	                ((state4 >>> 11) | (state4 << 21)) ^
    	                ((state4 >>> 25) | (state4 << 7))) +
    	                ((state4 & state5) ^ (~state4 & state6))) |
    	                0) +
    	                ((state7 + ((constants_1.KEY[i] + this.temp[i]) | 0)) | 0)) |
    	                0;
    	            var t2 = ((((state0 >>> 2) | (state0 << 30)) ^
    	                ((state0 >>> 13) | (state0 << 19)) ^
    	                ((state0 >>> 22) | (state0 << 10))) +
    	                ((state0 & state1) ^ (state0 & state2) ^ (state1 & state2))) |
    	                0;
    	            state7 = state6;
    	            state6 = state5;
    	            state5 = state4;
    	            state4 = (state3 + t1) | 0;
    	            state3 = state2;
    	            state2 = state1;
    	            state1 = state0;
    	            state0 = (t1 + t2) | 0;
    	        }
    	        state[0] += state0;
    	        state[1] += state1;
    	        state[2] += state2;
    	        state[3] += state3;
    	        state[4] += state4;
    	        state[5] += state5;
    	        state[6] += state6;
    	        state[7] += state7;
    	    };
    	    return RawSha256;
    	}());
    	RawSha256$1.RawSha256 = RawSha256;
    	
    	return RawSha256$1;
    }

    var hasRequiredJsSha256$1;

    function requireJsSha256$1 () {
    	if (hasRequiredJsSha256$1) return jsSha256$1;
    	hasRequiredJsSha256$1 = 1;
    	Object.defineProperty(jsSha256$1, "__esModule", { value: true });
    	jsSha256$1.Sha256 = void 0;
    	var tslib_1 = require$$0$4;
    	var constants_1 = requireConstants$2();
    	var RawSha256_1 = requireRawSha256$1();
    	var util_1 = requireBuild$7();
    	var Sha256 = /** @class */ (function () {
    	    function Sha256(secret) {
    	        this.secret = secret;
    	        this.hash = new RawSha256_1.RawSha256();
    	        this.reset();
    	    }
    	    Sha256.prototype.update = function (toHash) {
    	        if ((0, util_1.isEmptyData)(toHash) || this.error) {
    	            return;
    	        }
    	        try {
    	            this.hash.update((0, util_1.convertToBuffer)(toHash));
    	        }
    	        catch (e) {
    	            this.error = e;
    	        }
    	    };
    	    /* This synchronous method keeps compatibility
    	     * with the v2 aws-sdk.
    	     */
    	    Sha256.prototype.digestSync = function () {
    	        if (this.error) {
    	            throw this.error;
    	        }
    	        if (this.outer) {
    	            if (!this.outer.finished) {
    	                this.outer.update(this.hash.digest());
    	            }
    	            return this.outer.digest();
    	        }
    	        return this.hash.digest();
    	    };
    	    /* The underlying digest method here is synchronous.
    	     * To keep the same interface with the other hash functions
    	     * the default is to expose this as an async method.
    	     * However, it can sometimes be useful to have a sync method.
    	     */
    	    Sha256.prototype.digest = function () {
    	        return tslib_1.__awaiter(this, void 0, void 0, function () {
    	            return tslib_1.__generator(this, function (_a) {
    	                return [2 /*return*/, this.digestSync()];
    	            });
    	        });
    	    };
    	    Sha256.prototype.reset = function () {
    	        this.hash = new RawSha256_1.RawSha256();
    	        if (this.secret) {
    	            this.outer = new RawSha256_1.RawSha256();
    	            var inner = bufferFromSecret(this.secret);
    	            var outer = new Uint8Array(constants_1.BLOCK_SIZE);
    	            outer.set(inner);
    	            for (var i = 0; i < constants_1.BLOCK_SIZE; i++) {
    	                inner[i] ^= 0x36;
    	                outer[i] ^= 0x5c;
    	            }
    	            this.hash.update(inner);
    	            this.outer.update(outer);
    	            // overwrite the copied key in memory
    	            for (var i = 0; i < inner.byteLength; i++) {
    	                inner[i] = 0;
    	            }
    	        }
    	    };
    	    return Sha256;
    	}());
    	jsSha256$1.Sha256 = Sha256;
    	function bufferFromSecret(secret) {
    	    var input = (0, util_1.convertToBuffer)(secret);
    	    if (input.byteLength > constants_1.BLOCK_SIZE) {
    	        var bufferHash = new RawSha256_1.RawSha256();
    	        bufferHash.update(input);
    	        input = bufferHash.digest();
    	    }
    	    var buffer = new Uint8Array(constants_1.BLOCK_SIZE);
    	    buffer.set(input);
    	    return buffer;
    	}
    	
    	return jsSha256$1;
    }

    var hasRequiredBuild$6;

    function requireBuild$6 () {
    	if (hasRequiredBuild$6) return build$5;
    	hasRequiredBuild$6 = 1;
    	(function (exports) {
    		Object.defineProperty(exports, "__esModule", { value: true });
    		var tslib_1 = require$$0$4;
    		tslib_1.__exportStar(requireJsSha256$1(), exports);
    		
    	} (build$5));
    	return build$5;
    }

    var build$4 = {};

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics$3 = function(d, b) {
        extendStatics$3 = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics$3(d, b);
    };

    function __extends$3(d, b) {
        extendStatics$3(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign$3 = function() {
        __assign$3 = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign$3.apply(this, arguments);
    };

    function __rest$3(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate$3(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param$3(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata$3(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter$3(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator$3(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __createBinding$3(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }

    function __exportStar$3(m, exports) {
        for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values$3(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read$3(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread$3() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read$3(arguments[i]));
        return ar;
    }

    function __spreadArrays$3() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __await$3(v) {
        return this instanceof __await$3 ? (this.v = v, this) : new __await$3(v);
    }

    function __asyncGenerator$3(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await$3 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator$3(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await$3(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues$3(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values$3 === "function" ? __values$3(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject$3(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    }
    function __importStar$3(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault$3(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    function __classPrivateFieldGet$3(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }

    function __classPrivateFieldSet$3(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    var tslib_es6$3 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        get __assign () { return __assign$3; },
        __asyncDelegator: __asyncDelegator$3,
        __asyncGenerator: __asyncGenerator$3,
        __asyncValues: __asyncValues$3,
        __await: __await$3,
        __awaiter: __awaiter$3,
        __classPrivateFieldGet: __classPrivateFieldGet$3,
        __classPrivateFieldSet: __classPrivateFieldSet$3,
        __createBinding: __createBinding$3,
        __decorate: __decorate$3,
        __exportStar: __exportStar$3,
        __extends: __extends$3,
        __generator: __generator$3,
        __importDefault: __importDefault$3,
        __importStar: __importStar$3,
        __makeTemplateObject: __makeTemplateObject$3,
        __metadata: __metadata$3,
        __param: __param$3,
        __read: __read$3,
        __rest: __rest$3,
        __spread: __spread$3,
        __spreadArrays: __spreadArrays$3,
        __values: __values$3
    });

    var require$$0$3 = /*@__PURE__*/getAugmentedNamespace(tslib_es6$3);

    var supportsWebCrypto$1 = {};

    var hasRequiredSupportsWebCrypto$1;

    function requireSupportsWebCrypto$1 () {
    	if (hasRequiredSupportsWebCrypto$1) return supportsWebCrypto$1;
    	hasRequiredSupportsWebCrypto$1 = 1;
    	Object.defineProperty(supportsWebCrypto$1, "__esModule", { value: true });
    	supportsWebCrypto$1.supportsZeroByteGCM = supportsWebCrypto$1.supportsSubtleCrypto = supportsWebCrypto$1.supportsSecureRandom = supportsWebCrypto$1.supportsWebCrypto = void 0;
    	var tslib_1 = require$$0$3;
    	var subtleCryptoMethods = [
    	    "decrypt",
    	    "digest",
    	    "encrypt",
    	    "exportKey",
    	    "generateKey",
    	    "importKey",
    	    "sign",
    	    "verify"
    	];
    	function supportsWebCrypto(window) {
    	    if (supportsSecureRandom(window) &&
    	        typeof window.crypto.subtle === "object") {
    	        var subtle = window.crypto.subtle;
    	        return supportsSubtleCrypto(subtle);
    	    }
    	    return false;
    	}
    	supportsWebCrypto$1.supportsWebCrypto = supportsWebCrypto;
    	function supportsSecureRandom(window) {
    	    if (typeof window === "object" && typeof window.crypto === "object") {
    	        var getRandomValues = window.crypto.getRandomValues;
    	        return typeof getRandomValues === "function";
    	    }
    	    return false;
    	}
    	supportsWebCrypto$1.supportsSecureRandom = supportsSecureRandom;
    	function supportsSubtleCrypto(subtle) {
    	    return (subtle &&
    	        subtleCryptoMethods.every(function (methodName) { return typeof subtle[methodName] === "function"; }));
    	}
    	supportsWebCrypto$1.supportsSubtleCrypto = supportsSubtleCrypto;
    	function supportsZeroByteGCM(subtle) {
    	    return tslib_1.__awaiter(this, void 0, void 0, function () {
    	        var key, zeroByteAuthTag;
    	        return tslib_1.__generator(this, function (_b) {
    	            switch (_b.label) {
    	                case 0:
    	                    if (!supportsSubtleCrypto(subtle))
    	                        return [2 /*return*/, false];
    	                    _b.label = 1;
    	                case 1:
    	                    _b.trys.push([1, 4, , 5]);
    	                    return [4 /*yield*/, subtle.generateKey({ name: "AES-GCM", length: 128 }, false, ["encrypt"])];
    	                case 2:
    	                    key = _b.sent();
    	                    return [4 /*yield*/, subtle.encrypt({
    	                            name: "AES-GCM",
    	                            iv: new Uint8Array(Array(12)),
    	                            additionalData: new Uint8Array(Array(16)),
    	                            tagLength: 128
    	                        }, key, new Uint8Array(0))];
    	                case 3:
    	                    zeroByteAuthTag = _b.sent();
    	                    return [2 /*return*/, zeroByteAuthTag.byteLength === 16];
    	                case 4:
    	                    _b.sent();
    	                    return [2 /*return*/, false];
    	                case 5: return [2 /*return*/];
    	            }
    	        });
    	    });
    	}
    	supportsWebCrypto$1.supportsZeroByteGCM = supportsZeroByteGCM;
    	
    	return supportsWebCrypto$1;
    }

    var hasRequiredBuild$5;

    function requireBuild$5 () {
    	if (hasRequiredBuild$5) return build$4;
    	hasRequiredBuild$5 = 1;
    	(function (exports) {
    		Object.defineProperty(exports, "__esModule", { value: true });
    		var tslib_1 = require$$0$3;
    		tslib_1.__exportStar(requireSupportsWebCrypto$1(), exports);
    		
    	} (build$4));
    	return build$4;
    }

    var hasRequiredCrossPlatformSha256$1;

    function requireCrossPlatformSha256$1 () {
    	if (hasRequiredCrossPlatformSha256$1) return crossPlatformSha256$1;
    	hasRequiredCrossPlatformSha256$1 = 1;
    	Object.defineProperty(crossPlatformSha256$1, "__esModule", { value: true });
    	crossPlatformSha256$1.Sha256 = void 0;
    	var ie11Sha256_1 = requireIe11Sha256$1();
    	var webCryptoSha256_1 = requireWebCryptoSha256$1();
    	var sha256_js_1 = requireBuild$6();
    	var supports_web_crypto_1 = requireBuild$5();
    	var ie11_detection_1 = requireBuild$9();
    	var util_locate_window_1 = require$$5;
    	var util_1 = requireBuild$7();
    	var Sha256 = /** @class */ (function () {
    	    function Sha256(secret) {
    	        if ((0, supports_web_crypto_1.supportsWebCrypto)((0, util_locate_window_1.locateWindow)())) {
    	            this.hash = new webCryptoSha256_1.Sha256(secret);
    	        }
    	        else if ((0, ie11_detection_1.isMsWindow)((0, util_locate_window_1.locateWindow)())) {
    	            this.hash = new ie11Sha256_1.Sha256(secret);
    	        }
    	        else {
    	            this.hash = new sha256_js_1.Sha256(secret);
    	        }
    	    }
    	    Sha256.prototype.update = function (data, encoding) {
    	        this.hash.update((0, util_1.convertToBuffer)(data));
    	    };
    	    Sha256.prototype.digest = function () {
    	        return this.hash.digest();
    	    };
    	    Sha256.prototype.reset = function () {
    	        this.hash.reset();
    	    };
    	    return Sha256;
    	}());
    	crossPlatformSha256$1.Sha256 = Sha256;
    	
    	return crossPlatformSha256$1;
    }

    var hasRequiredBuild$4;

    function requireBuild$4 () {
    	if (hasRequiredBuild$4) return build$7;
    	hasRequiredBuild$4 = 1;
    	(function (exports) {
    		Object.defineProperty(exports, "__esModule", { value: true });
    		exports.WebCryptoSha256 = exports.Ie11Sha256 = void 0;
    		var tslib_1 = require$$0$5;
    		tslib_1.__exportStar(requireCrossPlatformSha256$1(), exports);
    		var ie11Sha256_1 = requireIe11Sha256$1();
    		Object.defineProperty(exports, "Ie11Sha256", { enumerable: true, get: function () { return ie11Sha256_1.Sha256; } });
    		var webCryptoSha256_1 = requireWebCryptoSha256$1();
    		Object.defineProperty(exports, "WebCryptoSha256", { enumerable: true, get: function () { return webCryptoSha256_1.Sha256; } });
    		
    	} (build$7));
    	return build$7;
    }

    var buildExports$1 = requireBuild$4();

    const defaultUserAgent$1 = ({ serviceId, clientVersion }) => async () => {
        const parsedUA = typeof window !== "undefined" && window?.navigator?.userAgent
            ? bowser.parse(window.navigator.userAgent)
            : undefined;
        const sections = [
            ["aws-sdk-js", clientVersion],
            ["ua", "2.0"],
            [`os/${parsedUA?.os?.name || "other"}`, parsedUA?.os?.version],
            ["lang/js"],
            ["md/browser", `${parsedUA?.browser?.name ?? "unknown"}_${parsedUA?.browser?.version ?? "unknown"}`],
        ];
        if (serviceId) {
            sections.push([`api/${serviceId}`, clientVersion]);
        }
        return sections;
    };

    var SelectorType$1;
    (function (SelectorType) {
        SelectorType["ENV"] = "env";
        SelectorType["CONFIG"] = "shared config entry";
    })(SelectorType$1 || (SelectorType$1 = {}));

    const DEFAULT_USE_DUALSTACK_ENDPOINT$1 = false;

    const DEFAULT_USE_FIPS_ENDPOINT$1 = false;

    var HttpAuthLocation$1;
    (function (HttpAuthLocation) {
        HttpAuthLocation["HEADER"] = "header";
        HttpAuthLocation["QUERY"] = "query";
    })(HttpAuthLocation$1 || (HttpAuthLocation$1 = {}));

    var HttpApiKeyAuthLocation$1;
    (function (HttpApiKeyAuthLocation) {
        HttpApiKeyAuthLocation["HEADER"] = "header";
        HttpApiKeyAuthLocation["QUERY"] = "query";
    })(HttpApiKeyAuthLocation$1 || (HttpApiKeyAuthLocation$1 = {}));

    var EndpointURLScheme$1;
    (function (EndpointURLScheme) {
        EndpointURLScheme["HTTP"] = "http";
        EndpointURLScheme["HTTPS"] = "https";
    })(EndpointURLScheme$1 || (EndpointURLScheme$1 = {}));

    var AlgorithmId$1;
    (function (AlgorithmId) {
        AlgorithmId["MD5"] = "md5";
        AlgorithmId["CRC32"] = "crc32";
        AlgorithmId["CRC32C"] = "crc32c";
        AlgorithmId["SHA1"] = "sha1";
        AlgorithmId["SHA256"] = "sha256";
    })(AlgorithmId$1 || (AlgorithmId$1 = {}));

    var FieldPosition$1;
    (function (FieldPosition) {
        FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
        FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
    })(FieldPosition$1 || (FieldPosition$1 = {}));

    const SMITHY_CONTEXT_KEY$1 = "__smithy_context";

    var IniSectionType$1;
    (function (IniSectionType) {
        IniSectionType["PROFILE"] = "profile";
        IniSectionType["SSO_SESSION"] = "sso-session";
        IniSectionType["SERVICES"] = "services";
    })(IniSectionType$1 || (IniSectionType$1 = {}));

    var RequestHandlerProtocol$1;
    (function (RequestHandlerProtocol) {
        RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
        RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
        RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
    })(RequestHandlerProtocol$1 || (RequestHandlerProtocol$1 = {}));

    const normalizeProvider$1 = (input) => {
        if (typeof input === "function")
            return input;
        const promisified = Promise.resolve(input);
        return () => promisified;
    };

    const getEndpointFromRegion$1 = async (input) => {
        const { tls = true } = input;
        const region = await input.region();
        const dnsHostRegex = new RegExp(/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/);
        if (!dnsHostRegex.test(region)) {
            throw new Error("Invalid region in client config");
        }
        const useDualstackEndpoint = await input.useDualstackEndpoint();
        const useFipsEndpoint = await input.useFipsEndpoint();
        const { hostname } = (await input.regionInfoProvider(region, { useDualstackEndpoint, useFipsEndpoint })) ?? {};
        if (!hostname) {
            throw new Error("Cannot resolve hostname from client config");
        }
        return input.urlParser(`${tls ? "https:" : "http:"}//${hostname}`);
    };

    const resolveEndpointsConfig$1 = (input) => {
        const useDualstackEndpoint = normalizeProvider$1(input.useDualstackEndpoint ?? false);
        const { endpoint, useFipsEndpoint, urlParser } = input;
        return {
            ...input,
            tls: input.tls ?? true,
            endpoint: endpoint
                ? normalizeProvider$1(typeof endpoint === "string" ? urlParser(endpoint) : endpoint)
                : () => getEndpointFromRegion$1({ ...input, useDualstackEndpoint, useFipsEndpoint }),
            isCustomEndpoint: !!endpoint,
            useDualstackEndpoint,
        };
    };

    const isFipsRegion$1 = (region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));

    const getRealRegion$1 = (region) => isFipsRegion$1(region)
        ? ["fips-aws-global", "aws-fips"].includes(region)
            ? "us-east-1"
            : region.replace(/fips-(dkr-|prod-)?|-fips/, "")
        : region;

    const resolveRegionConfig$1 = (input) => {
        const { region, useFipsEndpoint } = input;
        if (!region) {
            throw new Error("Region is missing");
        }
        return {
            ...input,
            region: async () => {
                if (typeof region === "string") {
                    return getRealRegion$1(region);
                }
                const providedRegion = await region();
                return getRealRegion$1(providedRegion);
            },
            useFipsEndpoint: async () => {
                const providedRegion = typeof region === "string" ? region : await region();
                if (isFipsRegion$1(providedRegion)) {
                    return true;
                }
                return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
            },
        };
    };

    const getHostnameFromVariants$1 = (variants = [], { useFipsEndpoint, useDualstackEndpoint }) => variants.find(({ tags }) => useFipsEndpoint === tags.includes("fips") && useDualstackEndpoint === tags.includes("dualstack"))?.hostname;

    const getResolvedHostname$1 = (resolvedRegion, { regionHostname, partitionHostname }) => regionHostname
        ? regionHostname
        : partitionHostname
            ? partitionHostname.replace("{region}", resolvedRegion)
            : undefined;

    const getResolvedPartition$1 = (region, { partitionHash }) => Object.keys(partitionHash || {}).find((key) => partitionHash[key].regions.includes(region)) ?? "aws";

    const getResolvedSigningRegion$1 = (hostname, { signingRegion, regionRegex, useFipsEndpoint }) => {
        if (signingRegion) {
            return signingRegion;
        }
        else if (useFipsEndpoint) {
            const regionRegexJs = regionRegex.replace("\\\\", "\\").replace(/^\^/g, "\\.").replace(/\$$/g, "\\.");
            const regionRegexmatchArray = hostname.match(regionRegexJs);
            if (regionRegexmatchArray) {
                return regionRegexmatchArray[0].slice(1, -1);
            }
        }
    };

    const getRegionInfo$1 = (region, { useFipsEndpoint = false, useDualstackEndpoint = false, signingService, regionHash, partitionHash, }) => {
        const partition = getResolvedPartition$1(region, { partitionHash });
        const resolvedRegion = region in regionHash ? region : partitionHash[partition]?.endpoint ?? region;
        const hostnameOptions = { useFipsEndpoint, useDualstackEndpoint };
        const regionHostname = getHostnameFromVariants$1(regionHash[resolvedRegion]?.variants, hostnameOptions);
        const partitionHostname = getHostnameFromVariants$1(partitionHash[partition]?.variants, hostnameOptions);
        const hostname = getResolvedHostname$1(resolvedRegion, { regionHostname, partitionHostname });
        if (hostname === undefined) {
            throw new Error(`Endpoint resolution failed for: ${{ resolvedRegion, useFipsEndpoint, useDualstackEndpoint }}`);
        }
        const signingRegion = getResolvedSigningRegion$1(hostname, {
            signingRegion: regionHash[resolvedRegion]?.signingRegion,
            regionRegex: partitionHash[partition].regionRegex,
            useFipsEndpoint,
        });
        return {
            partition,
            signingService,
            hostname,
            ...(signingRegion && { signingRegion }),
            ...(regionHash[resolvedRegion]?.signingService && {
                signingService: regionHash[resolvedRegion].signingService,
            }),
        };
    };

    const getHttpHandlerExtensionConfiguration$1 = (runtimeConfig) => {
        let httpHandler = runtimeConfig.httpHandler;
        return {
            setHttpHandler(handler) {
                httpHandler = handler;
            },
            httpHandler() {
                return httpHandler;
            },
            updateHttpClientConfig(key, value) {
                httpHandler.updateHttpClientConfig(key, value);
            },
            httpHandlerConfigs() {
                return httpHandler.httpHandlerConfigs();
            },
        };
    };
    const resolveHttpHandlerRuntimeConfig$1 = (httpHandlerExtensionConfiguration) => {
        return {
            httpHandler: httpHandlerExtensionConfiguration.httpHandler(),
        };
    };

    let HttpRequest$1 = class HttpRequest {
        constructor(options) {
            this.method = options.method || "GET";
            this.hostname = options.hostname || "localhost";
            this.port = options.port;
            this.query = options.query || {};
            this.headers = options.headers || {};
            this.body = options.body;
            this.protocol = options.protocol
                ? options.protocol.slice(-1) !== ":"
                    ? `${options.protocol}:`
                    : options.protocol
                : "https:";
            this.path = options.path ? (options.path.charAt(0) !== "/" ? `/${options.path}` : options.path) : "/";
            this.username = options.username;
            this.password = options.password;
            this.fragment = options.fragment;
        }
        static isInstance(request) {
            if (!request)
                return false;
            const req = request;
            return ("method" in req &&
                "protocol" in req &&
                "hostname" in req &&
                "path" in req &&
                typeof req["query"] === "object" &&
                typeof req["headers"] === "object");
        }
        clone() {
            const cloned = new HttpRequest({
                ...this,
                headers: { ...this.headers },
            });
            if (cloned.query)
                cloned.query = cloneQuery$1(cloned.query);
            return cloned;
        }
    };
    function cloneQuery$1(query) {
        return Object.keys(query).reduce((carry, paramName) => {
            const param = query[paramName];
            return {
                ...carry,
                [paramName]: Array.isArray(param) ? [...param] : param,
            };
        }, {});
    }

    let HttpResponse$1 = class HttpResponse {
        constructor(options) {
            this.statusCode = options.statusCode;
            this.reason = options.reason;
            this.headers = options.headers || {};
            this.body = options.body;
        }
        static isInstance(response) {
            if (!response)
                return false;
            const resp = response;
            return typeof resp.statusCode === "number" && typeof resp.headers === "object";
        }
    };

    const escapeUri$1 = (uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode$1);
    const hexEncode$1 = (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`;

    function buildQueryString$1(query) {
        const parts = [];
        for (let key of Object.keys(query).sort()) {
            const value = query[key];
            key = escapeUri$1(key);
            if (Array.isArray(value)) {
                for (let i = 0, iLen = value.length; i < iLen; i++) {
                    parts.push(`${key}=${escapeUri$1(value[i])}`);
                }
            }
            else {
                let qsEntry = key;
                if (value || typeof value === "string") {
                    qsEntry += `=${escapeUri$1(value)}`;
                }
                parts.push(qsEntry);
            }
        }
        return parts.join("&");
    }

    function requestTimeout$1(timeoutInMs = 0) {
        return new Promise((resolve, reject) => {
            if (timeoutInMs) {
                setTimeout(() => {
                    const timeoutError = new Error(`Request did not complete within ${timeoutInMs} ms`);
                    timeoutError.name = "TimeoutError";
                    reject(timeoutError);
                }, timeoutInMs);
            }
        });
    }

    const keepAliveSupport$1 = {
        supported: Boolean(typeof Request !== "undefined" && "keepalive" in new Request("https://[::1]")),
    };
    let FetchHttpHandler$1 = class FetchHttpHandler {
        static create(instanceOrOptions) {
            if (typeof instanceOrOptions?.handle === "function") {
                return instanceOrOptions;
            }
            return new FetchHttpHandler(instanceOrOptions);
        }
        constructor(options) {
            if (typeof options === "function") {
                this.configProvider = options().then((opts) => opts || {});
            }
            else {
                this.config = options ?? {};
                this.configProvider = Promise.resolve(this.config);
            }
        }
        destroy() {
        }
        async handle(request, { abortSignal } = {}) {
            if (!this.config) {
                this.config = await this.configProvider;
            }
            const requestTimeoutInMs = this.config.requestTimeout;
            const keepAlive = this.config.keepAlive === true;
            if (abortSignal?.aborted) {
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                return Promise.reject(abortError);
            }
            let path = request.path;
            const queryString = buildQueryString$1(request.query || {});
            if (queryString) {
                path += `?${queryString}`;
            }
            if (request.fragment) {
                path += `#${request.fragment}`;
            }
            let auth = "";
            if (request.username != null || request.password != null) {
                const username = request.username ?? "";
                const password = request.password ?? "";
                auth = `${username}:${password}@`;
            }
            const { port, method } = request;
            const url = `${request.protocol}//${auth}${request.hostname}${port ? `:${port}` : ""}${path}`;
            const body = method === "GET" || method === "HEAD" ? undefined : request.body;
            const requestOptions = { body, headers: new Headers(request.headers), method: method };
            if (typeof AbortController !== "undefined") {
                requestOptions["signal"] = abortSignal;
            }
            if (keepAliveSupport$1.supported) {
                requestOptions["keepalive"] = keepAlive;
            }
            const fetchRequest = new Request(url, requestOptions);
            const raceOfPromises = [
                fetch(fetchRequest).then((response) => {
                    const fetchHeaders = response.headers;
                    const transformedHeaders = {};
                    for (const pair of fetchHeaders.entries()) {
                        transformedHeaders[pair[0]] = pair[1];
                    }
                    const hasReadableStream = response.body != undefined;
                    if (!hasReadableStream) {
                        return response.blob().then((body) => ({
                            response: new HttpResponse$1({
                                headers: transformedHeaders,
                                reason: response.statusText,
                                statusCode: response.status,
                                body,
                            }),
                        }));
                    }
                    return {
                        response: new HttpResponse$1({
                            headers: transformedHeaders,
                            reason: response.statusText,
                            statusCode: response.status,
                            body: response.body,
                        }),
                    };
                }),
                requestTimeout$1(requestTimeoutInMs),
            ];
            if (abortSignal) {
                raceOfPromises.push(new Promise((resolve, reject) => {
                    abortSignal.onabort = () => {
                        const abortError = new Error("Request aborted");
                        abortError.name = "AbortError";
                        reject(abortError);
                    };
                }));
            }
            return Promise.race(raceOfPromises);
        }
        updateHttpClientConfig(key, value) {
            this.config = undefined;
            this.configProvider = this.configProvider.then((config) => {
                config[key] = value;
                return config;
            });
        }
        httpHandlerConfigs() {
            return this.config ?? {};
        }
    };

    const alphabetByEncoding$1 = {};
    const alphabetByValue$1 = new Array(64);
    for (let i = 0, start = "A".charCodeAt(0), limit = "Z".charCodeAt(0); i + start <= limit; i++) {
        const char = String.fromCharCode(i + start);
        alphabetByEncoding$1[char] = i;
        alphabetByValue$1[i] = char;
    }
    for (let i = 0, start = "a".charCodeAt(0), limit = "z".charCodeAt(0); i + start <= limit; i++) {
        const char = String.fromCharCode(i + start);
        const index = i + 26;
        alphabetByEncoding$1[char] = index;
        alphabetByValue$1[index] = char;
    }
    for (let i = 0; i < 10; i++) {
        alphabetByEncoding$1[i.toString(10)] = i + 52;
        const char = i.toString(10);
        const index = i + 52;
        alphabetByEncoding$1[char] = index;
        alphabetByValue$1[index] = char;
    }
    alphabetByEncoding$1["+"] = 62;
    alphabetByValue$1[62] = "+";
    alphabetByEncoding$1["/"] = 63;
    alphabetByValue$1[63] = "/";
    const bitsPerLetter$1 = 6;
    const bitsPerByte$1 = 8;
    const maxLetterValue$1 = 0b111111;

    const fromBase64$1 = (input) => {
        let totalByteLength = (input.length / 4) * 3;
        if (input.slice(-2) === "==") {
            totalByteLength -= 2;
        }
        else if (input.slice(-1) === "=") {
            totalByteLength--;
        }
        const out = new ArrayBuffer(totalByteLength);
        const dataView = new DataView(out);
        for (let i = 0; i < input.length; i += 4) {
            let bits = 0;
            let bitLength = 0;
            for (let j = i, limit = i + 3; j <= limit; j++) {
                if (input[j] !== "=") {
                    if (!(input[j] in alphabetByEncoding$1)) {
                        throw new TypeError(`Invalid character ${input[j]} in base64 string.`);
                    }
                    bits |= alphabetByEncoding$1[input[j]] << ((limit - j) * bitsPerLetter$1);
                    bitLength += bitsPerLetter$1;
                }
                else {
                    bits >>= bitsPerLetter$1;
                }
            }
            const chunkOffset = (i / 4) * 3;
            bits >>= bitLength % bitsPerByte$1;
            const byteLength = Math.floor(bitLength / bitsPerByte$1);
            for (let k = 0; k < byteLength; k++) {
                const offset = (byteLength - k - 1) * bitsPerByte$1;
                dataView.setUint8(chunkOffset + k, (bits & (255 << offset)) >> offset);
            }
        }
        return new Uint8Array(out);
    };

    const fromUtf8$1 = (input) => new TextEncoder().encode(input);

    const toUtf8$1 = (input) => {
        if (typeof input === "string") {
            return input;
        }
        if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
            throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
        }
        return new TextDecoder("utf-8").decode(input);
    };

    function toBase64$1(_input) {
        let input;
        if (typeof _input === "string") {
            input = fromUtf8$1(_input);
        }
        else {
            input = _input;
        }
        const isArrayLike = typeof input === "object" && typeof input.length === "number";
        const isUint8Array = typeof input === "object" &&
            typeof input.byteOffset === "number" &&
            typeof input.byteLength === "number";
        if (!isArrayLike && !isUint8Array) {
            throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
        }
        let str = "";
        for (let i = 0; i < input.length; i += 3) {
            let bits = 0;
            let bitLength = 0;
            for (let j = i, limit = Math.min(i + 3, input.length); j < limit; j++) {
                bits |= input[j] << ((limit - j - 1) * bitsPerByte$1);
                bitLength += bitsPerByte$1;
            }
            const bitClusterCount = Math.ceil(bitLength / bitsPerLetter$1);
            bits <<= bitClusterCount * bitsPerLetter$1 - bitLength;
            for (let k = 1; k <= bitClusterCount; k++) {
                const offset = (bitClusterCount - k) * bitsPerLetter$1;
                str += alphabetByValue$1[(bits & (maxLetterValue$1 << offset)) >> offset];
            }
            str += "==".slice(0, 4 - bitClusterCount);
        }
        return str;
    }

    const streamCollector$1 = (stream) => {
        if (typeof Blob === "function" && stream instanceof Blob) {
            return collectBlob$1(stream);
        }
        return collectStream$1(stream);
    };
    async function collectBlob$1(blob) {
        const base64 = await readToBase64$1(blob);
        const arrayBuffer = fromBase64$1(base64);
        return new Uint8Array(arrayBuffer);
    }
    async function collectStream$1(stream) {
        let res = new Uint8Array(0);
        const reader = stream.getReader();
        let isDone = false;
        while (!isDone) {
            const { done, value } = await reader.read();
            if (value) {
                const prior = res;
                res = new Uint8Array(prior.length + value.length);
                res.set(prior);
                res.set(value, prior.length);
            }
            isDone = done;
        }
        return res;
    }
    function readToBase64$1(blob) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => {
                if (reader.readyState !== 2) {
                    return reject(new Error("Reader aborted too early"));
                }
                const result = (reader.result ?? "");
                const commaIndex = result.indexOf(",");
                const dataOffset = commaIndex > -1 ? commaIndex + 1 : result.length;
                resolve(result.substring(dataOffset));
            };
            reader.onabort = () => reject(new Error("Read aborted"));
            reader.onerror = () => reject(reader.error);
            reader.readAsDataURL(blob);
        });
    }

    const invalidProvider$1 = (message) => () => Promise.reject(message);

    const TEXT_ENCODER$1 = typeof TextEncoder == "function" ? new TextEncoder() : null;
    const calculateBodyLength$1 = (body) => {
        if (typeof body === "string") {
            if (TEXT_ENCODER$1) {
                return TEXT_ENCODER$1.encode(body).byteLength;
            }
            let len = body.length;
            for (let i = len - 1; i >= 0; i--) {
                const code = body.charCodeAt(i);
                if (code > 0x7f && code <= 0x7ff)
                    len++;
                else if (code > 0x7ff && code <= 0xffff)
                    len += 2;
                if (code >= 0xdc00 && code <= 0xdfff)
                    i--;
            }
            return len;
        }
        else if (typeof body.byteLength === "number") {
            return body.byteLength;
        }
        else if (typeof body.size === "number") {
            return body.size;
        }
        throw new Error(`Body Length computation failed for ${body}`);
    };

    var RETRY_MODES$1;
    (function (RETRY_MODES) {
        RETRY_MODES["STANDARD"] = "standard";
        RETRY_MODES["ADAPTIVE"] = "adaptive";
    })(RETRY_MODES$1 || (RETRY_MODES$1 = {}));
    const DEFAULT_MAX_ATTEMPTS$1 = 3;
    const DEFAULT_RETRY_MODE$1 = RETRY_MODES$1.STANDARD;

    const THROTTLING_ERROR_CODES$1 = [
        "BandwidthLimitExceeded",
        "EC2ThrottledException",
        "LimitExceededException",
        "PriorRequestNotComplete",
        "ProvisionedThroughputExceededException",
        "RequestLimitExceeded",
        "RequestThrottled",
        "RequestThrottledException",
        "SlowDown",
        "ThrottledException",
        "Throttling",
        "ThrottlingException",
        "TooManyRequestsException",
        "TransactionInProgressException",
    ];
    const TRANSIENT_ERROR_CODES$1 = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"];
    const TRANSIENT_ERROR_STATUS_CODES$1 = [500, 502, 503, 504];
    const NODEJS_TIMEOUT_ERROR_CODES$1 = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"];

    const isClockSkewCorrectedError$1 = (error) => error.$metadata?.clockSkewCorrected;
    const isThrottlingError$1 = (error) => error.$metadata?.httpStatusCode === 429 ||
        THROTTLING_ERROR_CODES$1.includes(error.name) ||
        error.$retryable?.throttling == true;
    const isTransientError$1 = (error) => isClockSkewCorrectedError$1(error) ||
        TRANSIENT_ERROR_CODES$1.includes(error.name) ||
        NODEJS_TIMEOUT_ERROR_CODES$1.includes(error?.code || "") ||
        TRANSIENT_ERROR_STATUS_CODES$1.includes(error.$metadata?.httpStatusCode || 0);
    const isServerError$1 = (error) => {
        if (error.$metadata?.httpStatusCode !== undefined) {
            const statusCode = error.$metadata.httpStatusCode;
            if (500 <= statusCode && statusCode <= 599 && !isTransientError$1(error)) {
                return true;
            }
            return false;
        }
        return false;
    };

    let DefaultRateLimiter$1 = class DefaultRateLimiter {
        constructor(options) {
            this.currentCapacity = 0;
            this.enabled = false;
            this.lastMaxRate = 0;
            this.measuredTxRate = 0;
            this.requestCount = 0;
            this.lastTimestamp = 0;
            this.timeWindow = 0;
            this.beta = options?.beta ?? 0.7;
            this.minCapacity = options?.minCapacity ?? 1;
            this.minFillRate = options?.minFillRate ?? 0.5;
            this.scaleConstant = options?.scaleConstant ?? 0.4;
            this.smooth = options?.smooth ?? 0.8;
            const currentTimeInSeconds = this.getCurrentTimeInSeconds();
            this.lastThrottleTime = currentTimeInSeconds;
            this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());
            this.fillRate = this.minFillRate;
            this.maxCapacity = this.minCapacity;
        }
        getCurrentTimeInSeconds() {
            return Date.now() / 1000;
        }
        async getSendToken() {
            return this.acquireTokenBucket(1);
        }
        async acquireTokenBucket(amount) {
            if (!this.enabled) {
                return;
            }
            this.refillTokenBucket();
            if (amount > this.currentCapacity) {
                const delay = ((amount - this.currentCapacity) / this.fillRate) * 1000;
                await new Promise((resolve) => setTimeout(resolve, delay));
            }
            this.currentCapacity = this.currentCapacity - amount;
        }
        refillTokenBucket() {
            const timestamp = this.getCurrentTimeInSeconds();
            if (!this.lastTimestamp) {
                this.lastTimestamp = timestamp;
                return;
            }
            const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;
            this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);
            this.lastTimestamp = timestamp;
        }
        updateClientSendingRate(response) {
            let calculatedRate;
            this.updateMeasuredRate();
            if (isThrottlingError$1(response)) {
                const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);
                this.lastMaxRate = rateToUse;
                this.calculateTimeWindow();
                this.lastThrottleTime = this.getCurrentTimeInSeconds();
                calculatedRate = this.cubicThrottle(rateToUse);
                this.enableTokenBucket();
            }
            else {
                this.calculateTimeWindow();
                calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());
            }
            const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);
            this.updateTokenBucketRate(newRate);
        }
        calculateTimeWindow() {
            this.timeWindow = this.getPrecise(Math.pow((this.lastMaxRate * (1 - this.beta)) / this.scaleConstant, 1 / 3));
        }
        cubicThrottle(rateToUse) {
            return this.getPrecise(rateToUse * this.beta);
        }
        cubicSuccess(timestamp) {
            return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
        }
        enableTokenBucket() {
            this.enabled = true;
        }
        updateTokenBucketRate(newRate) {
            this.refillTokenBucket();
            this.fillRate = Math.max(newRate, this.minFillRate);
            this.maxCapacity = Math.max(newRate, this.minCapacity);
            this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
        }
        updateMeasuredRate() {
            const t = this.getCurrentTimeInSeconds();
            const timeBucket = Math.floor(t * 2) / 2;
            this.requestCount++;
            if (timeBucket > this.lastTxRateBucket) {
                const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);
                this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));
                this.requestCount = 0;
                this.lastTxRateBucket = timeBucket;
            }
        }
        getPrecise(num) {
            return parseFloat(num.toFixed(8));
        }
    };

    const DEFAULT_RETRY_DELAY_BASE$1 = 100;
    const MAXIMUM_RETRY_DELAY$1 = 20 * 1000;
    const THROTTLING_RETRY_DELAY_BASE$1 = 500;
    const INITIAL_RETRY_TOKENS$1 = 500;
    const RETRY_COST$1 = 5;
    const TIMEOUT_RETRY_COST$1 = 10;
    const NO_RETRY_INCREMENT$1 = 1;
    const INVOCATION_ID_HEADER$1 = "amz-sdk-invocation-id";
    const REQUEST_HEADER$1 = "amz-sdk-request";

    const getDefaultRetryBackoffStrategy$1 = () => {
        let delayBase = DEFAULT_RETRY_DELAY_BASE$1;
        const computeNextBackoffDelay = (attempts) => {
            return Math.floor(Math.min(MAXIMUM_RETRY_DELAY$1, Math.random() * 2 ** attempts * delayBase));
        };
        const setDelayBase = (delay) => {
            delayBase = delay;
        };
        return {
            computeNextBackoffDelay,
            setDelayBase,
        };
    };

    const createDefaultRetryToken$1 = ({ retryDelay, retryCount, retryCost, }) => {
        const getRetryCount = () => retryCount;
        const getRetryDelay = () => Math.min(MAXIMUM_RETRY_DELAY$1, retryDelay);
        const getRetryCost = () => retryCost;
        return {
            getRetryCount,
            getRetryDelay,
            getRetryCost,
        };
    };

    let StandardRetryStrategy$1 = class StandardRetryStrategy {
        constructor(maxAttempts) {
            this.maxAttempts = maxAttempts;
            this.mode = RETRY_MODES$1.STANDARD;
            this.capacity = INITIAL_RETRY_TOKENS$1;
            this.retryBackoffStrategy = getDefaultRetryBackoffStrategy$1();
            this.maxAttemptsProvider = typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts;
        }
        async acquireInitialRetryToken(retryTokenScope) {
            return createDefaultRetryToken$1({
                retryDelay: DEFAULT_RETRY_DELAY_BASE$1,
                retryCount: 0,
            });
        }
        async refreshRetryTokenForRetry(token, errorInfo) {
            const maxAttempts = await this.getMaxAttempts();
            if (this.shouldRetry(token, errorInfo, maxAttempts)) {
                const errorType = errorInfo.errorType;
                this.retryBackoffStrategy.setDelayBase(errorType === "THROTTLING" ? THROTTLING_RETRY_DELAY_BASE$1 : DEFAULT_RETRY_DELAY_BASE$1);
                const delayFromErrorType = this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());
                const retryDelay = errorInfo.retryAfterHint
                    ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType)
                    : delayFromErrorType;
                const capacityCost = this.getCapacityCost(errorType);
                this.capacity -= capacityCost;
                return createDefaultRetryToken$1({
                    retryDelay,
                    retryCount: token.getRetryCount() + 1,
                    retryCost: capacityCost,
                });
            }
            throw new Error("No retry token available");
        }
        recordSuccess(token) {
            this.capacity = Math.max(INITIAL_RETRY_TOKENS$1, this.capacity + (token.getRetryCost() ?? NO_RETRY_INCREMENT$1));
        }
        getCapacity() {
            return this.capacity;
        }
        async getMaxAttempts() {
            try {
                return await this.maxAttemptsProvider();
            }
            catch (error) {
                console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS$1}`);
                return DEFAULT_MAX_ATTEMPTS$1;
            }
        }
        shouldRetry(tokenToRenew, errorInfo, maxAttempts) {
            const attempts = tokenToRenew.getRetryCount() + 1;
            return (attempts < maxAttempts &&
                this.capacity >= this.getCapacityCost(errorInfo.errorType) &&
                this.isRetryableError(errorInfo.errorType));
        }
        getCapacityCost(errorType) {
            return errorType === "TRANSIENT" ? TIMEOUT_RETRY_COST$1 : RETRY_COST$1;
        }
        isRetryableError(errorType) {
            return errorType === "THROTTLING" || errorType === "TRANSIENT";
        }
    };

    let AdaptiveRetryStrategy$1 = class AdaptiveRetryStrategy {
        constructor(maxAttemptsProvider, options) {
            this.maxAttemptsProvider = maxAttemptsProvider;
            this.mode = RETRY_MODES$1.ADAPTIVE;
            const { rateLimiter } = options ?? {};
            this.rateLimiter = rateLimiter ?? new DefaultRateLimiter$1();
            this.standardRetryStrategy = new StandardRetryStrategy$1(maxAttemptsProvider);
        }
        async acquireInitialRetryToken(retryTokenScope) {
            await this.rateLimiter.getSendToken();
            return this.standardRetryStrategy.acquireInitialRetryToken(retryTokenScope);
        }
        async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
            this.rateLimiter.updateClientSendingRate(errorInfo);
            return this.standardRetryStrategy.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
        }
        recordSuccess(token) {
            this.rateLimiter.updateClientSendingRate({});
            this.standardRetryStrategy.recordSuccess(token);
        }
    };

    const regionHash$1 = {};
    const partitionHash$1 = {
        "aws": {
            regions: [
                "af-south-1",
                "ap-east-1",
                "ap-northeast-1",
                "ap-northeast-2",
                "ap-northeast-3",
                "ap-south-1",
                "ap-south-2",
                "ap-southeast-1",
                "ap-southeast-2",
                "ap-southeast-3",
                "ap-southeast-4",
                "ca-central-1",
                "eu-central-1",
                "eu-central-2",
                "eu-north-1",
                "eu-south-1",
                "eu-south-2",
                "eu-west-1",
                "eu-west-2",
                "eu-west-3",
                "il-central-1",
                "me-central-1",
                "me-south-1",
                "sa-east-1",
                "us-east-1",
                "us-east-2",
                "us-west-1",
                "us-west-2",
            ],
            regionRegex: "^(us|eu|ap|sa|ca|me|af|il)\\-\\w+\\-\\d+$",
            variants: [
                {
                    "hostname": "geo-places.{region}.amazonaws.com",
                    "tags": []
                },
                {
                    "hostname": "geo-places-fips.{region}.amazonaws.com",
                    "tags": [
                        "fips"
                    ]
                },
                {
                    "hostname": "geo-places-fips.{region}.api.aws",
                    "tags": [
                        "dualstack",
                        "fips"
                    ]
                },
                {
                    "hostname": "geo-places.{region}.api.aws",
                    "tags": [
                        "dualstack"
                    ]
                }
            ],
        },
        "aws-cn": {
            regions: [
                "cn-north-1",
                "cn-northwest-1",
            ],
            regionRegex: "^cn\\-\\w+\\-\\d+$",
            variants: [
                {
                    "hostname": "geo-places.{region}.amazonaws.com.cn",
                    "tags": []
                },
                {
                    "hostname": "geo-places-fips.{region}.amazonaws.com.cn",
                    "tags": [
                        "fips"
                    ]
                },
                {
                    "hostname": "geo-places-fips.{region}.api.amazonwebservices.com.cn",
                    "tags": [
                        "dualstack",
                        "fips"
                    ]
                },
                {
                    "hostname": "geo-places.{region}.api.amazonwebservices.com.cn",
                    "tags": [
                        "dualstack"
                    ]
                }
            ],
        },
        "aws-iso": {
            regions: [
                "us-iso-east-1",
                "us-iso-west-1",
            ],
            regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
            variants: [
                {
                    "hostname": "geo-places.{region}.c2s.ic.gov",
                    "tags": []
                },
                {
                    "hostname": "geo-places-fips.{region}.c2s.ic.gov",
                    "tags": [
                        "fips"
                    ]
                }
            ],
        },
        "aws-iso-b": {
            regions: [
                "us-isob-east-1",
            ],
            regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
            variants: [
                {
                    "hostname": "geo-places.{region}.sc2s.sgov.gov",
                    "tags": []
                },
                {
                    "hostname": "geo-places-fips.{region}.sc2s.sgov.gov",
                    "tags": [
                        "fips"
                    ]
                }
            ],
        },
        "aws-iso-e": {
            regions: [],
            regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
            variants: [
                {
                    "hostname": "geo-places.{region}.cloud.adc-e.uk",
                    "tags": []
                },
                {
                    "hostname": "geo-places-fips.{region}.cloud.adc-e.uk",
                    "tags": [
                        "fips"
                    ]
                }
            ],
        },
        "aws-iso-f": {
            regions: [],
            regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
            variants: [
                {
                    "hostname": "geo-places.{region}.csp.hci.ic.gov",
                    "tags": []
                },
                {
                    "hostname": "geo-places-fips.{region}.csp.hci.ic.gov",
                    "tags": [
                        "fips"
                    ]
                }
            ],
        },
        "aws-us-gov": {
            regions: [
                "us-gov-east-1",
                "us-gov-west-1",
            ],
            regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
            variants: [
                {
                    "hostname": "geo-places.{region}.amazonaws.com",
                    "tags": []
                },
                {
                    "hostname": "geo-places-fips.{region}.amazonaws.com",
                    "tags": [
                        "fips"
                    ]
                },
                {
                    "hostname": "geo-places-fips.{region}.api.aws",
                    "tags": [
                        "dualstack",
                        "fips"
                    ]
                },
                {
                    "hostname": "geo-places.{region}.api.aws",
                    "tags": [
                        "dualstack"
                    ]
                }
            ],
        },
    };
    const defaultRegionInfoProvider$1 = async (region, options) => getRegionInfo$1(region, {
        ...options,
        signingService: "geo-places",
        regionHash: regionHash$1,
        partitionHash: partitionHash$1,
    });

    let NoOpLogger$1 = class NoOpLogger {
        trace() { }
        debug() { }
        info() { }
        warn() { }
        error() { }
    };

    const getAllAliases$1 = (name, aliases) => {
        const _aliases = [];
        if (name) {
            _aliases.push(name);
        }
        if (aliases) {
            for (const alias of aliases) {
                _aliases.push(alias);
            }
        }
        return _aliases;
    };
    const getMiddlewareNameWithAliases$1 = (name, aliases) => {
        return `${name || "anonymous"}${aliases && aliases.length > 0 ? ` (a.k.a. ${aliases.join(",")})` : ""}`;
    };
    const constructStack$1 = () => {
        let absoluteEntries = [];
        let relativeEntries = [];
        let identifyOnResolve = false;
        const entriesNameSet = new Set();
        const sort = (entries) => entries.sort((a, b) => stepWeights$1[b.step] - stepWeights$1[a.step] ||
            priorityWeights$1[b.priority || "normal"] - priorityWeights$1[a.priority || "normal"]);
        const removeByName = (toRemove) => {
            let isRemoved = false;
            const filterCb = (entry) => {
                const aliases = getAllAliases$1(entry.name, entry.aliases);
                if (aliases.includes(toRemove)) {
                    isRemoved = true;
                    for (const alias of aliases) {
                        entriesNameSet.delete(alias);
                    }
                    return false;
                }
                return true;
            };
            absoluteEntries = absoluteEntries.filter(filterCb);
            relativeEntries = relativeEntries.filter(filterCb);
            return isRemoved;
        };
        const removeByReference = (toRemove) => {
            let isRemoved = false;
            const filterCb = (entry) => {
                if (entry.middleware === toRemove) {
                    isRemoved = true;
                    for (const alias of getAllAliases$1(entry.name, entry.aliases)) {
                        entriesNameSet.delete(alias);
                    }
                    return false;
                }
                return true;
            };
            absoluteEntries = absoluteEntries.filter(filterCb);
            relativeEntries = relativeEntries.filter(filterCb);
            return isRemoved;
        };
        const cloneTo = (toStack) => {
            absoluteEntries.forEach((entry) => {
                toStack.add(entry.middleware, { ...entry });
            });
            relativeEntries.forEach((entry) => {
                toStack.addRelativeTo(entry.middleware, { ...entry });
            });
            toStack.identifyOnResolve?.(stack.identifyOnResolve());
            return toStack;
        };
        const expandRelativeMiddlewareList = (from) => {
            const expandedMiddlewareList = [];
            from.before.forEach((entry) => {
                if (entry.before.length === 0 && entry.after.length === 0) {
                    expandedMiddlewareList.push(entry);
                }
                else {
                    expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
                }
            });
            expandedMiddlewareList.push(from);
            from.after.reverse().forEach((entry) => {
                if (entry.before.length === 0 && entry.after.length === 0) {
                    expandedMiddlewareList.push(entry);
                }
                else {
                    expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
                }
            });
            return expandedMiddlewareList;
        };
        const getMiddlewareList = (debug = false) => {
            const normalizedAbsoluteEntries = [];
            const normalizedRelativeEntries = [];
            const normalizedEntriesNameMap = {};
            absoluteEntries.forEach((entry) => {
                const normalizedEntry = {
                    ...entry,
                    before: [],
                    after: [],
                };
                for (const alias of getAllAliases$1(normalizedEntry.name, normalizedEntry.aliases)) {
                    normalizedEntriesNameMap[alias] = normalizedEntry;
                }
                normalizedAbsoluteEntries.push(normalizedEntry);
            });
            relativeEntries.forEach((entry) => {
                const normalizedEntry = {
                    ...entry,
                    before: [],
                    after: [],
                };
                for (const alias of getAllAliases$1(normalizedEntry.name, normalizedEntry.aliases)) {
                    normalizedEntriesNameMap[alias] = normalizedEntry;
                }
                normalizedRelativeEntries.push(normalizedEntry);
            });
            normalizedRelativeEntries.forEach((entry) => {
                if (entry.toMiddleware) {
                    const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
                    if (toMiddleware === undefined) {
                        if (debug) {
                            return;
                        }
                        throw new Error(`${entry.toMiddleware} is not found when adding ` +
                            `${getMiddlewareNameWithAliases$1(entry.name, entry.aliases)} ` +
                            `middleware ${entry.relation} ${entry.toMiddleware}`);
                    }
                    if (entry.relation === "after") {
                        toMiddleware.after.push(entry);
                    }
                    if (entry.relation === "before") {
                        toMiddleware.before.push(entry);
                    }
                }
            });
            const mainChain = sort(normalizedAbsoluteEntries)
                .map(expandRelativeMiddlewareList)
                .reduce((wholeList, expandedMiddlewareList) => {
                wholeList.push(...expandedMiddlewareList);
                return wholeList;
            }, []);
            return mainChain;
        };
        const stack = {
            add: (middleware, options = {}) => {
                const { name, override, aliases: _aliases } = options;
                const entry = {
                    step: "initialize",
                    priority: "normal",
                    middleware,
                    ...options,
                };
                const aliases = getAllAliases$1(name, _aliases);
                if (aliases.length > 0) {
                    if (aliases.some((alias) => entriesNameSet.has(alias))) {
                        if (!override)
                            throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases$1(name, _aliases)}'`);
                        for (const alias of aliases) {
                            const toOverrideIndex = absoluteEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));
                            if (toOverrideIndex === -1) {
                                continue;
                            }
                            const toOverride = absoluteEntries[toOverrideIndex];
                            if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {
                                throw new Error(`"${getMiddlewareNameWithAliases$1(toOverride.name, toOverride.aliases)}" middleware with ` +
                                    `${toOverride.priority} priority in ${toOverride.step} step cannot ` +
                                    `be overridden by "${getMiddlewareNameWithAliases$1(name, _aliases)}" middleware with ` +
                                    `${entry.priority} priority in ${entry.step} step.`);
                            }
                            absoluteEntries.splice(toOverrideIndex, 1);
                        }
                    }
                    for (const alias of aliases) {
                        entriesNameSet.add(alias);
                    }
                }
                absoluteEntries.push(entry);
            },
            addRelativeTo: (middleware, options) => {
                const { name, override, aliases: _aliases } = options;
                const entry = {
                    middleware,
                    ...options,
                };
                const aliases = getAllAliases$1(name, _aliases);
                if (aliases.length > 0) {
                    if (aliases.some((alias) => entriesNameSet.has(alias))) {
                        if (!override)
                            throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases$1(name, _aliases)}'`);
                        for (const alias of aliases) {
                            const toOverrideIndex = relativeEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));
                            if (toOverrideIndex === -1) {
                                continue;
                            }
                            const toOverride = relativeEntries[toOverrideIndex];
                            if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
                                throw new Error(`"${getMiddlewareNameWithAliases$1(toOverride.name, toOverride.aliases)}" middleware ` +
                                    `${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden ` +
                                    `by "${getMiddlewareNameWithAliases$1(name, _aliases)}" middleware ${entry.relation} ` +
                                    `"${entry.toMiddleware}" middleware.`);
                            }
                            relativeEntries.splice(toOverrideIndex, 1);
                        }
                    }
                    for (const alias of aliases) {
                        entriesNameSet.add(alias);
                    }
                }
                relativeEntries.push(entry);
            },
            clone: () => cloneTo(constructStack$1()),
            use: (plugin) => {
                plugin.applyToStack(stack);
            },
            remove: (toRemove) => {
                if (typeof toRemove === "string")
                    return removeByName(toRemove);
                else
                    return removeByReference(toRemove);
            },
            removeByTag: (toRemove) => {
                let isRemoved = false;
                const filterCb = (entry) => {
                    const { tags, name, aliases: _aliases } = entry;
                    if (tags && tags.includes(toRemove)) {
                        const aliases = getAllAliases$1(name, _aliases);
                        for (const alias of aliases) {
                            entriesNameSet.delete(alias);
                        }
                        isRemoved = true;
                        return false;
                    }
                    return true;
                };
                absoluteEntries = absoluteEntries.filter(filterCb);
                relativeEntries = relativeEntries.filter(filterCb);
                return isRemoved;
            },
            concat: (from) => {
                const cloned = cloneTo(constructStack$1());
                cloned.use(from);
                cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || (from.identifyOnResolve?.() ?? false));
                return cloned;
            },
            applyToStack: cloneTo,
            identify: () => {
                return getMiddlewareList(true).map((mw) => {
                    const step = mw.step ??
                        mw.relation +
                            " " +
                            mw.toMiddleware;
                    return getMiddlewareNameWithAliases$1(mw.name, mw.aliases) + " - " + step;
                });
            },
            identifyOnResolve(toggle) {
                if (typeof toggle === "boolean")
                    identifyOnResolve = toggle;
                return identifyOnResolve;
            },
            resolve: (handler, context) => {
                for (const middleware of getMiddlewareList()
                    .map((entry) => entry.middleware)
                    .reverse()) {
                    handler = middleware(handler, context);
                }
                if (identifyOnResolve) {
                    console.log(stack.identify());
                }
                return handler;
            },
        };
        return stack;
    };
    const stepWeights$1 = {
        initialize: 5,
        serialize: 4,
        build: 3,
        finalizeRequest: 2,
        deserialize: 1,
    };
    const priorityWeights$1 = {
        high: 3,
        normal: 2,
        low: 1,
    };

    let Client$1 = class Client {
        constructor(config) {
            this.middlewareStack = constructStack$1();
            this.config = config;
        }
        send(command, optionsOrCb, cb) {
            const options = typeof optionsOrCb !== "function" ? optionsOrCb : undefined;
            const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
            const handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
            if (callback) {
                handler(command)
                    .then((result) => callback(null, result.output), (err) => callback(err))
                    .catch(() => { });
            }
            else {
                return handler(command).then((result) => result.output);
            }
        }
        destroy() {
            if (this.config.requestHandler.destroy)
                this.config.requestHandler.destroy();
        }
    };

    function transformToString$1(payload, encoding = "utf-8") {
        if (encoding === "base64") {
            return toBase64$1(payload);
        }
        return toUtf8$1(payload);
    }
    function transformFromString$1(str, encoding) {
        if (encoding === "base64") {
            return Uint8ArrayBlobAdapter$1.mutate(fromBase64$1(str));
        }
        return Uint8ArrayBlobAdapter$1.mutate(fromUtf8$1(str));
    }

    let Uint8ArrayBlobAdapter$1 = class Uint8ArrayBlobAdapter extends Uint8Array {
        static fromString(source, encoding = "utf-8") {
            switch (typeof source) {
                case "string":
                    return transformFromString$1(source, encoding);
                default:
                    throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
            }
        }
        static mutate(source) {
            Object.setPrototypeOf(source, Uint8ArrayBlobAdapter.prototype);
            return source;
        }
        transformToString(encoding = "utf-8") {
            return transformToString$1(this, encoding);
        }
    };

    for (let i = 0; i < 256; i++) {
        let encodedByte = i.toString(16).toLowerCase();
        if (encodedByte.length === 1) {
            encodedByte = `0${encodedByte}`;
        }
    }

    const collectBody$1 = async (streamBody = new Uint8Array(), context) => {
        if (streamBody instanceof Uint8Array) {
            return Uint8ArrayBlobAdapter$1.mutate(streamBody);
        }
        if (!streamBody) {
            return Uint8ArrayBlobAdapter$1.mutate(new Uint8Array());
        }
        const fromContext = context.streamCollector(streamBody);
        return Uint8ArrayBlobAdapter$1.mutate(await fromContext);
    };

    let Command$1 = class Command {
        constructor() {
            this.middlewareStack = constructStack$1();
        }
        static classBuilder() {
            return new ClassBuilder$1();
        }
        resolveMiddlewareWithContext(clientStack, configuration, options, { middlewareFn, clientName, commandName, inputFilterSensitiveLog, outputFilterSensitiveLog, smithyContext, additionalContext, CommandCtor, }) {
            for (const mw of middlewareFn.bind(this)(CommandCtor, clientStack, configuration, options)) {
                this.middlewareStack.use(mw);
            }
            const stack = clientStack.concat(this.middlewareStack);
            const { logger } = configuration;
            const handlerExecutionContext = {
                logger,
                clientName,
                commandName,
                inputFilterSensitiveLog,
                outputFilterSensitiveLog,
                [SMITHY_CONTEXT_KEY$1]: {
                    ...smithyContext,
                },
                ...additionalContext,
            };
            const { requestHandler } = configuration;
            return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
    };
    let ClassBuilder$1 = class ClassBuilder {
        constructor() {
            this._init = () => { };
            this._ep = {};
            this._middlewareFn = () => [];
            this._commandName = "";
            this._clientName = "";
            this._additionalContext = {};
            this._smithyContext = {};
            this._inputFilterSensitiveLog = (_) => _;
            this._outputFilterSensitiveLog = (_) => _;
            this._serializer = null;
            this._deserializer = null;
        }
        init(cb) {
            this._init = cb;
        }
        ep(endpointParameterInstructions) {
            this._ep = endpointParameterInstructions;
            return this;
        }
        m(middlewareSupplier) {
            this._middlewareFn = middlewareSupplier;
            return this;
        }
        s(service, operation, smithyContext = {}) {
            this._smithyContext = {
                service,
                operation,
                ...smithyContext,
            };
            return this;
        }
        c(additionalContext = {}) {
            this._additionalContext = additionalContext;
            return this;
        }
        n(clientName, commandName) {
            this._clientName = clientName;
            this._commandName = commandName;
            return this;
        }
        f(inputFilter = (_) => _, outputFilter = (_) => _) {
            this._inputFilterSensitiveLog = inputFilter;
            this._outputFilterSensitiveLog = outputFilter;
            return this;
        }
        ser(serializer) {
            this._serializer = serializer;
            return this;
        }
        de(deserializer) {
            this._deserializer = deserializer;
            return this;
        }
        build() {
            const closure = this;
            let CommandRef;
            return (CommandRef = class extends Command$1 {
                static getEndpointParameterInstructions() {
                    return closure._ep;
                }
                constructor(...[input]) {
                    super();
                    this.serialize = closure._serializer;
                    this.deserialize = closure._deserializer;
                    this.input = input ?? {};
                    closure._init(this);
                }
                resolveMiddleware(stack, configuration, options) {
                    return this.resolveMiddlewareWithContext(stack, configuration, options, {
                        CommandCtor: CommandRef,
                        middlewareFn: closure._middlewareFn,
                        clientName: closure._clientName,
                        commandName: closure._commandName,
                        inputFilterSensitiveLog: closure._inputFilterSensitiveLog,
                        outputFilterSensitiveLog: closure._outputFilterSensitiveLog,
                        smithyContext: closure._smithyContext,
                        additionalContext: closure._additionalContext,
                    });
                }
            });
        }
    };

    const SENSITIVE_STRING$1 = "***SensitiveInformation***";

    const createAggregatedClient$1 = (commands, Client) => {
        for (const command of Object.keys(commands)) {
            const CommandCtor = commands[command];
            const methodImpl = async function (args, optionsOrCb, cb) {
                const command = new CommandCtor(args);
                if (typeof optionsOrCb === "function") {
                    this.send(command, optionsOrCb);
                }
                else if (typeof cb === "function") {
                    if (typeof optionsOrCb !== "object")
                        throw new Error(`Expected http options but got ${typeof optionsOrCb}`);
                    this.send(command, optionsOrCb || {}, cb);
                }
                else {
                    return this.send(command, optionsOrCb);
                }
            };
            const methodName = (command[0].toLowerCase() + command.slice(1)).replace(/Command$/, "");
            Client.prototype[methodName] = methodImpl;
        }
    };

    const expectBoolean$1 = (value) => {
        if (value === null || value === undefined) {
            return undefined;
        }
        if (typeof value === "number") {
            if (value === 0 || value === 1) {
                logger$1.warn(stackTraceWarning$1(`Expected boolean, got ${typeof value}: ${value}`));
            }
            if (value === 0) {
                return false;
            }
            if (value === 1) {
                return true;
            }
        }
        if (typeof value === "string") {
            const lower = value.toLowerCase();
            if (lower === "false" || lower === "true") {
                logger$1.warn(stackTraceWarning$1(`Expected boolean, got ${typeof value}: ${value}`));
            }
            if (lower === "false") {
                return false;
            }
            if (lower === "true") {
                return true;
            }
        }
        if (typeof value === "boolean") {
            return value;
        }
        throw new TypeError(`Expected boolean, got ${typeof value}: ${value}`);
    };
    const expectNumber$1 = (value) => {
        if (value === null || value === undefined) {
            return undefined;
        }
        if (typeof value === "string") {
            const parsed = parseFloat(value);
            if (!Number.isNaN(parsed)) {
                if (String(parsed) !== String(value)) {
                    logger$1.warn(stackTraceWarning$1(`Expected number but observed string: ${value}`));
                }
                return parsed;
            }
        }
        if (typeof value === "number") {
            return value;
        }
        throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
    };
    const expectLong$1 = (value) => {
        if (value === null || value === undefined) {
            return undefined;
        }
        if (Number.isInteger(value) && !Number.isNaN(value)) {
            return value;
        }
        throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
    };
    const expectNonNull$1 = (value, location) => {
        if (value === null || value === undefined) {
            {
                throw new TypeError(`Expected a non-null value for ${location}`);
            }
        }
        return value;
    };
    const expectObject$1 = (value) => {
        if (value === null || value === undefined) {
            return undefined;
        }
        if (typeof value === "object" && !Array.isArray(value)) {
            return value;
        }
        const receivedType = Array.isArray(value) ? "array" : typeof value;
        throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
    };
    const expectString$1 = (value) => {
        if (value === null || value === undefined) {
            return undefined;
        }
        if (typeof value === "string") {
            return value;
        }
        if (["boolean", "number", "bigint"].includes(typeof value)) {
            logger$1.warn(stackTraceWarning$1(`Expected string, got ${typeof value}: ${value}`));
            return String(value);
        }
        throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
    };
    const limitedParseDouble$1 = (value) => {
        if (typeof value == "string") {
            return parseFloatString$1(value);
        }
        return expectNumber$1(value);
    };
    const parseFloatString$1 = (value) => {
        switch (value) {
            case "NaN":
                return NaN;
            case "Infinity":
                return Infinity;
            case "-Infinity":
                return -Infinity;
            default:
                throw new Error(`Unable to parse float value: ${value}`);
        }
    };
    const stackTraceWarning$1 = (message) => {
        return String(new TypeError(message).stack || message)
            .split("\n")
            .slice(0, 5)
            .filter((s) => !s.includes("stackTraceWarning"))
            .join("\n");
    };
    const logger$1 = {
        warn: console.warn,
    };

    let ServiceException$1 = class ServiceException extends Error {
        constructor(options) {
            super(options.message);
            Object.setPrototypeOf(this, ServiceException.prototype);
            this.name = options.name;
            this.$fault = options.$fault;
            this.$metadata = options.$metadata;
        }
    };
    const decorateServiceException$1 = (exception, additions = {}) => {
        Object.entries(additions)
            .filter(([, v]) => v !== undefined)
            .forEach(([k, v]) => {
            if (exception[k] == undefined || exception[k] === "") {
                exception[k] = v;
            }
        });
        const message = exception.message || exception.Message || "UnknownError";
        exception.message = message;
        delete exception.Message;
        return exception;
    };

    const throwDefaultError$5 = ({ output, parsedBody, exceptionCtor, errorCode }) => {
        const $metadata = deserializeMetadata$5(output);
        const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
        const response = new exceptionCtor({
            name: parsedBody?.code || parsedBody?.Code || errorCode || statusCode || "UnknownError",
            $fault: "client",
            $metadata,
        });
        throw decorateServiceException$1(response, parsedBody);
    };
    const withBaseException$1 = (ExceptionCtor) => {
        return ({ output, parsedBody, errorCode }) => {
            throwDefaultError$5({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
        };
    };
    const deserializeMetadata$5 = (output) => ({
        httpStatusCode: output.statusCode,
        requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
        extendedRequestId: output.headers["x-amz-id-2"],
        cfId: output.headers["x-amz-cf-id"],
    });

    const loadConfigsForDefaultMode$1 = (mode) => {
        switch (mode) {
            case "standard":
                return {
                    retryMode: "standard",
                    connectionTimeout: 3100,
                };
            case "in-region":
                return {
                    retryMode: "standard",
                    connectionTimeout: 1100,
                };
            case "cross-region":
                return {
                    retryMode: "standard",
                    connectionTimeout: 3100,
                };
            case "mobile":
                return {
                    retryMode: "standard",
                    connectionTimeout: 30000,
                };
            default:
                return {};
        }
    };

    const getChecksumConfiguration$1 = (runtimeConfig) => {
        const checksumAlgorithms = [];
        for (const id in AlgorithmId$1) {
            const algorithmId = AlgorithmId$1[id];
            if (runtimeConfig[algorithmId] === undefined) {
                continue;
            }
            checksumAlgorithms.push({
                algorithmId: () => algorithmId,
                checksumConstructor: () => runtimeConfig[algorithmId],
            });
        }
        return {
            _checksumAlgorithms: checksumAlgorithms,
            addChecksumAlgorithm(algo) {
                this._checksumAlgorithms.push(algo);
            },
            checksumAlgorithms() {
                return this._checksumAlgorithms;
            },
        };
    };
    const resolveChecksumRuntimeConfig$1 = (clientConfig) => {
        const runtimeConfig = {};
        clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
            runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
        });
        return runtimeConfig;
    };

    const getRetryConfiguration$1 = (runtimeConfig) => {
        let _retryStrategy = runtimeConfig.retryStrategy;
        return {
            setRetryStrategy(retryStrategy) {
                _retryStrategy = retryStrategy;
            },
            retryStrategy() {
                return _retryStrategy;
            },
        };
    };
    const resolveRetryRuntimeConfig$1 = (retryStrategyConfiguration) => {
        const runtimeConfig = {};
        runtimeConfig.retryStrategy = retryStrategyConfiguration.retryStrategy();
        return runtimeConfig;
    };

    const getDefaultExtensionConfiguration$1 = (runtimeConfig) => {
        return {
            ...getChecksumConfiguration$1(runtimeConfig),
            ...getRetryConfiguration$1(runtimeConfig),
        };
    };
    const resolveDefaultRuntimeConfig$1 = (config) => {
        return {
            ...resolveChecksumRuntimeConfig$1(config),
            ...resolveRetryRuntimeConfig$1(config),
        };
    };

    function extendedEncodeURIComponent(str) {
        return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
            return "%" + c.charCodeAt(0).toString(16).toUpperCase();
        });
    }

    const StringWrapper$1 = function () {
        const Class = Object.getPrototypeOf(this).constructor;
        const Constructor = Function.bind.apply(String, [null, ...arguments]);
        const instance = new Constructor();
        Object.setPrototypeOf(instance, Class.prototype);
        return instance;
    };
    StringWrapper$1.prototype = Object.create(String.prototype, {
        constructor: {
            value: StringWrapper$1,
            enumerable: false,
            writable: true,
            configurable: true,
        },
    });
    Object.setPrototypeOf(StringWrapper$1, String);

    function map$1(arg0, arg1, arg2) {
        let target;
        let filter;
        let instructions;
        if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
            target = {};
            instructions = arg0;
        }
        else {
            target = arg0;
            if (typeof arg1 === "function") {
                filter = arg1;
                instructions = arg2;
                return mapWithFilter$1(target, filter, instructions);
            }
            else {
                instructions = arg1;
            }
        }
        for (const key of Object.keys(instructions)) {
            if (!Array.isArray(instructions[key])) {
                target[key] = instructions[key];
                continue;
            }
            applyInstruction$1(target, null, instructions, key);
        }
        return target;
    }
    const take$1 = (source, instructions) => {
        const out = {};
        for (const key in instructions) {
            applyInstruction$1(out, source, instructions, key);
        }
        return out;
    };
    const mapWithFilter$1 = (target, filter, instructions) => {
        return map$1(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {
            if (Array.isArray(value)) {
                _instructions[key] = value;
            }
            else {
                if (typeof value === "function") {
                    _instructions[key] = [filter, value()];
                }
                else {
                    _instructions[key] = [filter, value];
                }
            }
            return _instructions;
        }, {}));
    };
    const applyInstruction$1 = (target, source, instructions, targetKey) => {
        if (source !== null) {
            let instruction = instructions[targetKey];
            if (typeof instruction === "function") {
                instruction = [, instruction];
            }
            const [filter = nonNullish$1, valueFn = pass$1, sourceKey = targetKey] = instruction;
            if ((typeof filter === "function" && filter(source[sourceKey])) || (typeof filter !== "function" && !!filter)) {
                target[targetKey] = valueFn(source[sourceKey]);
            }
            return;
        }
        let [filter, value] = instructions[targetKey];
        if (typeof value === "function") {
            let _value;
            const defaultFilterPassed = filter === undefined && (_value = value()) != null;
            const customFilterPassed = (typeof filter === "function" && !!filter(void 0)) || (typeof filter !== "function" && !!filter);
            if (defaultFilterPassed) {
                target[targetKey] = _value;
            }
            else if (customFilterPassed) {
                target[targetKey] = value();
            }
        }
        else {
            const defaultFilterPassed = filter === undefined && value != null;
            const customFilterPassed = (typeof filter === "function" && !!filter(value)) || (typeof filter !== "function" && !!filter);
            if (defaultFilterPassed || customFilterPassed) {
                target[targetKey] = value;
            }
        }
    };
    const nonNullish$1 = (_) => _ != null;
    const pass$1 = (_) => _;

    const resolvedPath = (resolvedPath, input, memberName, labelValueProvider, uriLabel, isGreedyLabel) => {
        if (input != null && input[memberName] !== undefined) {
            const labelValue = labelValueProvider();
            if (labelValue.length <= 0) {
                throw new Error("Empty value provided for input HTTP label: " + memberName + ".");
            }
            resolvedPath = resolvedPath.replace(uriLabel, extendedEncodeURIComponent(labelValue));
        }
        else {
            throw new Error("No value provided for input HTTP label: " + memberName + ".");
        }
        return resolvedPath;
    };

    const serializeFloat$1 = (value) => {
        if (value !== value) {
            return "NaN";
        }
        switch (value) {
            case Infinity:
                return "Infinity";
            case -Infinity:
                return "-Infinity";
            default:
                return value;
        }
    };

    const _json$1 = (obj) => {
        if (obj == null) {
            return {};
        }
        if (Array.isArray(obj)) {
            return obj.filter((_) => _ != null).map(_json$1);
        }
        if (typeof obj === "object") {
            const target = {};
            for (const key of Object.keys(obj)) {
                if (obj[key] == null) {
                    continue;
                }
                target[key] = _json$1(obj[key]);
            }
            return target;
        }
        return obj;
    };

    function parseQueryString$1(querystring) {
        const query = {};
        querystring = querystring.replace(/^\?/, "");
        if (querystring) {
            for (const pair of querystring.split("&")) {
                let [key, value = null] = pair.split("=");
                key = decodeURIComponent(key);
                if (value) {
                    value = decodeURIComponent(value);
                }
                if (!(key in query)) {
                    query[key] = value;
                }
                else if (Array.isArray(query[key])) {
                    query[key].push(value);
                }
                else {
                    query[key] = [query[key], value];
                }
            }
        }
        return query;
    }

    const parseUrl$1 = (url) => {
        if (typeof url === "string") {
            return parseUrl$1(new URL(url));
        }
        const { hostname, pathname, port, protocol, search } = url;
        let query;
        if (search) {
            query = parseQueryString$1(search);
        }
        return {
            hostname,
            port: port ? parseInt(port) : undefined,
            protocol,
            path: pathname,
            query,
        };
    };

    const getRuntimeConfig$7 = (config) => {
        return {
            apiVersion: "2020-11-19",
            base64Decoder: config?.base64Decoder ?? fromBase64$1,
            base64Encoder: config?.base64Encoder ?? toBase64$1,
            disableHostPrefix: config?.disableHostPrefix ?? false,
            extensions: config?.extensions ?? [],
            logger: config?.logger ?? new NoOpLogger$1(),
            regionInfoProvider: config?.regionInfoProvider ?? defaultRegionInfoProvider$1,
            serviceId: config?.serviceId ?? "GeoPlaces",
            urlParser: config?.urlParser ?? parseUrl$1,
            utf8Decoder: config?.utf8Decoder ?? fromUtf8$1,
            utf8Encoder: config?.utf8Encoder ?? toUtf8$1,
        };
    };

    const memoize$1 = (provider, isExpired, requiresRefresh) => {
        let resolved;
        let pending;
        let hasResult;
        let isConstant = false;
        const coalesceProvider = async () => {
            if (!pending) {
                pending = provider();
            }
            try {
                resolved = await pending;
                hasResult = true;
                isConstant = false;
            }
            finally {
                pending = undefined;
            }
            return resolved;
        };
        {
            return async (options) => {
                if (!hasResult || options?.forceRefresh) {
                    resolved = await coalesceProvider();
                }
                return resolved;
            };
        }
    };

    const DEFAULTS_MODE_OPTIONS$1 = ["in-region", "cross-region", "mobile", "standard", "legacy"];

    const resolveDefaultsModeConfig$1 = ({ defaultsMode, } = {}) => memoize$1(async () => {
        const mode = typeof defaultsMode === "function" ? await defaultsMode() : defaultsMode;
        switch (mode?.toLowerCase()) {
            case "auto":
                return Promise.resolve(isMobileBrowser$1() ? "mobile" : "standard");
            case "mobile":
            case "in-region":
            case "cross-region":
            case "standard":
            case "legacy":
                return Promise.resolve(mode?.toLocaleLowerCase());
            case undefined:
                return Promise.resolve("legacy");
            default:
                throw new Error(`Invalid parameter for "defaultsMode", expect ${DEFAULTS_MODE_OPTIONS$1.join(", ")}, got ${mode}`);
        }
    });
    const isMobileBrowser$1 = () => {
        const parsedUA = typeof window !== "undefined" && window?.navigator?.userAgent
            ? bowser.parse(window.navigator.userAgent)
            : undefined;
        const platform = parsedUA?.platform?.type;
        return platform === "tablet" || platform === "mobile";
    };

    const getRuntimeConfig$6 = (config) => {
        const defaultsMode = resolveDefaultsModeConfig$1(config);
        const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode$1);
        const clientSharedValues = getRuntimeConfig$7(config);
        return {
            ...clientSharedValues,
            ...config,
            runtime: "browser",
            defaultsMode,
            bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength$1,
            credentialDefaultProvider: config?.credentialDefaultProvider ?? ((_) => () => Promise.reject(new Error("Credential is missing"))),
            defaultUserAgentProvider: config?.defaultUserAgentProvider ?? defaultUserAgent$1({ serviceId: clientSharedValues.serviceId, clientVersion: packageInfo$3.version }),
            maxAttempts: config?.maxAttempts ?? DEFAULT_MAX_ATTEMPTS$1,
            region: config?.region ?? invalidProvider$1("Region is missing"),
            requestHandler: config?.requestHandler ?? new FetchHttpHandler$1(defaultConfigProvider),
            retryMode: config?.retryMode ?? (async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE$1),
            sha256: config?.sha256 ?? buildExports$1.Sha256,
            streamCollector: config?.streamCollector ?? streamCollector$1,
            useDualstackEndpoint: config?.useDualstackEndpoint ?? (() => Promise.resolve(DEFAULT_USE_DUALSTACK_ENDPOINT$1)),
            useFipsEndpoint: config?.useFipsEndpoint ?? (() => Promise.resolve(DEFAULT_USE_FIPS_ENDPOINT$1)),
        };
    };

    const getAwsRegionExtensionConfiguration$1 = (runtimeConfig) => {
        let runtimeConfigRegion = async () => {
            if (runtimeConfig.region === undefined) {
                throw new Error("Region is missing from runtimeConfig");
            }
            const region = runtimeConfig.region;
            if (typeof region === "string") {
                return region;
            }
            return region();
        };
        return {
            setRegion(region) {
                runtimeConfigRegion = region;
            },
            region() {
                return runtimeConfigRegion;
            },
        };
    };
    const resolveAwsRegionExtensionConfiguration$1 = (awsRegionExtensionConfiguration) => {
        return {
            region: awsRegionExtensionConfiguration.region(),
        };
    };

    const asPartial$3 = (t) => t;
    const resolveRuntimeExtensions$3 = (runtimeConfig, extensions) => {
        const extensionConfiguration = {
            ...asPartial$3(getAwsRegionExtensionConfiguration$1(runtimeConfig)),
            ...asPartial$3(getDefaultExtensionConfiguration$1(runtimeConfig)),
            ...asPartial$3(getHttpHandlerExtensionConfiguration$1(runtimeConfig)),
        };
        extensions.forEach(extension => extension.configure(extensionConfiguration));
        return {
            ...runtimeConfig,
            ...resolveAwsRegionExtensionConfiguration$1(extensionConfiguration),
            ...resolveDefaultRuntimeConfig$1(extensionConfiguration),
            ...resolveHttpHandlerRuntimeConfig$1(extensionConfiguration),
        };
    };

    function resolveHostHeaderConfig$1(input) {
        return input;
    }
    const hostHeaderMiddleware$1 = (options) => (next) => async (args) => {
        if (!HttpRequest$1.isInstance(args.request))
            return next(args);
        const { request } = args;
        const { handlerProtocol = "" } = options.requestHandler.metadata || {};
        if (handlerProtocol.indexOf("h2") >= 0 && !request.headers[":authority"]) {
            delete request.headers["host"];
            request.headers[":authority"] = request.hostname + (request.port ? ":" + request.port : "");
        }
        else if (!request.headers["host"]) {
            let host = request.hostname;
            if (request.port != null)
                host += `:${request.port}`;
            request.headers["host"] = host;
        }
        return next(args);
    };
    const hostHeaderMiddlewareOptions$1 = {
        name: "hostHeaderMiddleware",
        step: "build",
        priority: "low",
        tags: ["HOST"],
        override: true,
    };
    const getHostHeaderPlugin$1 = (options) => ({
        applyToStack: (clientStack) => {
            clientStack.add(hostHeaderMiddleware$1(options), hostHeaderMiddlewareOptions$1);
        },
    });

    const loggerMiddleware$1 = () => (next, context) => async (args) => {
        try {
            const response = await next(args);
            const { clientName, commandName, logger, dynamoDbDocumentClientOptions = {} } = context;
            const { overrideInputFilterSensitiveLog, overrideOutputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
            const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
            const outputFilterSensitiveLog = overrideOutputFilterSensitiveLog ?? context.outputFilterSensitiveLog;
            const { $metadata, ...outputWithoutMetadata } = response.output;
            logger?.info?.({
                clientName,
                commandName,
                input: inputFilterSensitiveLog(args.input),
                output: outputFilterSensitiveLog(outputWithoutMetadata),
                metadata: $metadata,
            });
            return response;
        }
        catch (error) {
            const { clientName, commandName, logger, dynamoDbDocumentClientOptions = {} } = context;
            const { overrideInputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
            const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
            logger?.error?.({
                clientName,
                commandName,
                input: inputFilterSensitiveLog(args.input),
                error,
                metadata: error.$metadata,
            });
            throw error;
        }
    };
    const loggerMiddlewareOptions$1 = {
        name: "loggerMiddleware",
        tags: ["LOGGER"],
        step: "initialize",
        override: true,
    };
    const getLoggerPlugin$1 = (options) => ({
        applyToStack: (clientStack) => {
            clientStack.add(loggerMiddleware$1(), loggerMiddlewareOptions$1);
        },
    });

    const TRACE_ID_HEADER_NAME$1 = "X-Amzn-Trace-Id";
    const ENV_LAMBDA_FUNCTION_NAME$1 = "AWS_LAMBDA_FUNCTION_NAME";
    const ENV_TRACE_ID$1 = "_X_AMZN_TRACE_ID";
    const recursionDetectionMiddleware$1 = (options) => (next) => async (args) => {
        const { request } = args;
        if (!HttpRequest$1.isInstance(request) ||
            options.runtime !== "node" ||
            request.headers.hasOwnProperty(TRACE_ID_HEADER_NAME$1)) {
            return next(args);
        }
        const functionName = process.env[ENV_LAMBDA_FUNCTION_NAME$1];
        const traceId = process.env[ENV_TRACE_ID$1];
        const nonEmptyString = (str) => typeof str === "string" && str.length > 0;
        if (nonEmptyString(functionName) && nonEmptyString(traceId)) {
            request.headers[TRACE_ID_HEADER_NAME$1] = traceId;
        }
        return next({
            ...args,
            request,
        });
    };
    const addRecursionDetectionMiddlewareOptions$1 = {
        step: "build",
        tags: ["RECURSION_DETECTION"],
        name: "recursionDetectionMiddleware",
        override: true,
        priority: "low",
    };
    const getRecursionDetectionPlugin$1 = (options) => ({
        applyToStack: (clientStack) => {
            clientStack.add(recursionDetectionMiddleware$1(options), addRecursionDetectionMiddlewareOptions$1);
        },
    });

    function resolveUserAgentConfig$1(input) {
        return {
            ...input,
            customUserAgent: typeof input.customUserAgent === "string" ? [[input.customUserAgent]] : input.customUserAgent,
        };
    }

    ({
        [EndpointURLScheme$1.HTTP]: 80,
        [EndpointURLScheme$1.HTTPS]: 443,
    });

    const USER_AGENT$1 = "user-agent";
    const X_AMZ_USER_AGENT$1 = "x-amz-user-agent";
    const SPACE$1 = " ";
    const UA_NAME_SEPARATOR$1 = "/";
    const UA_NAME_ESCAPE_REGEX$1 = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g;
    const UA_VALUE_ESCAPE_REGEX$1 = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g;
    const UA_ESCAPE_CHAR$1 = "-";

    const userAgentMiddleware$1 = (options) => (next, context) => async (args) => {
        const { request } = args;
        if (!HttpRequest$1.isInstance(request))
            return next(args);
        const { headers } = request;
        const userAgent = context?.userAgent?.map(escapeUserAgent$1) || [];
        const defaultUserAgent = (await options.defaultUserAgentProvider()).map(escapeUserAgent$1);
        const customUserAgent = options?.customUserAgent?.map(escapeUserAgent$1) || [];
        const sdkUserAgentValue = ([])
            .concat([...defaultUserAgent, ...userAgent, ...customUserAgent])
            .join(SPACE$1);
        const normalUAValue = [
            ...defaultUserAgent.filter((section) => section.startsWith("aws-sdk-")),
            ...customUserAgent,
        ].join(SPACE$1);
        if (options.runtime !== "browser") {
            if (normalUAValue) {
                headers[X_AMZ_USER_AGENT$1] = headers[X_AMZ_USER_AGENT$1]
                    ? `${headers[USER_AGENT$1]} ${normalUAValue}`
                    : normalUAValue;
            }
            headers[USER_AGENT$1] = sdkUserAgentValue;
        }
        else {
            headers[X_AMZ_USER_AGENT$1] = sdkUserAgentValue;
        }
        return next({
            ...args,
            request,
        });
    };
    const escapeUserAgent$1 = (userAgentPair) => {
        const name = userAgentPair[0]
            .split(UA_NAME_SEPARATOR$1)
            .map((part) => part.replace(UA_NAME_ESCAPE_REGEX$1, UA_ESCAPE_CHAR$1))
            .join(UA_NAME_SEPARATOR$1);
        const version = userAgentPair[1]?.replace(UA_VALUE_ESCAPE_REGEX$1, UA_ESCAPE_CHAR$1);
        const prefixSeparatorIndex = name.indexOf(UA_NAME_SEPARATOR$1);
        const prefix = name.substring(0, prefixSeparatorIndex);
        let uaName = name.substring(prefixSeparatorIndex + 1);
        if (prefix === "api") {
            uaName = uaName.toLowerCase();
        }
        return [prefix, uaName, version]
            .filter((item) => item && item.length > 0)
            .reduce((acc, item, index) => {
            switch (index) {
                case 0:
                    return item;
                case 1:
                    return `${acc}/${item}`;
                default:
                    return `${acc}#${item}`;
            }
        }, "");
    };
    const getUserAgentMiddlewareOptions$1 = {
        name: "getUserAgentMiddleware",
        step: "build",
        priority: "low",
        tags: ["SET_USER_AGENT", "USER_AGENT"],
        override: true,
    };
    const getUserAgentPlugin$1 = (config) => ({
        applyToStack: (clientStack) => {
            clientStack.add(userAgentMiddleware$1(config), getUserAgentMiddlewareOptions$1);
        },
    });

    const CONTENT_LENGTH_HEADER$1 = "content-length";
    function contentLengthMiddleware$1(bodyLengthChecker) {
        return (next) => async (args) => {
            const request = args.request;
            if (HttpRequest$1.isInstance(request)) {
                const { body, headers } = request;
                if (body &&
                    Object.keys(headers)
                        .map((str) => str.toLowerCase())
                        .indexOf(CONTENT_LENGTH_HEADER$1) === -1) {
                    try {
                        const length = bodyLengthChecker(body);
                        request.headers = {
                            ...request.headers,
                            [CONTENT_LENGTH_HEADER$1]: String(length),
                        };
                    }
                    catch (error) {
                    }
                }
            }
            return next({
                ...args,
                request,
            });
        };
    }
    const contentLengthMiddlewareOptions$1 = {
        step: "build",
        tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
        name: "contentLengthMiddleware",
        override: true,
    };
    const getContentLengthPlugin$1 = (options) => ({
        applyToStack: (clientStack) => {
            clientStack.add(contentLengthMiddleware$1(options.bodyLengthChecker), contentLengthMiddlewareOptions$1);
        },
    });

    const asSdkError$1 = (error) => {
        if (error instanceof Error)
            return error;
        if (error instanceof Object)
            return Object.assign(new Error(), error);
        if (typeof error === "string")
            return new Error(error);
        return new Error(`AWS SDK error wrapper for ${error}`);
    };

    const resolveRetryConfig$1 = (input) => {
        const { retryStrategy } = input;
        const maxAttempts = normalizeProvider$1(input.maxAttempts ?? DEFAULT_MAX_ATTEMPTS$1);
        return {
            ...input,
            maxAttempts,
            retryStrategy: async () => {
                if (retryStrategy) {
                    return retryStrategy;
                }
                const retryMode = await normalizeProvider$1(input.retryMode)();
                if (retryMode === RETRY_MODES$1.ADAPTIVE) {
                    return new AdaptiveRetryStrategy$1(maxAttempts);
                }
                return new StandardRetryStrategy$1(maxAttempts);
            },
        };
    };

    const isStreamingPayload$1 = (request) => request?.body instanceof ReadableStream;

    const retryMiddleware$1 = (options) => (next, context) => async (args) => {
        let retryStrategy = await options.retryStrategy();
        const maxAttempts = await options.maxAttempts();
        if (isRetryStrategyV2$1(retryStrategy)) {
            retryStrategy = retryStrategy;
            let retryToken = await retryStrategy.acquireInitialRetryToken(context["partition_id"]);
            let lastError = new Error();
            let attempts = 0;
            let totalRetryDelay = 0;
            const { request } = args;
            const isRequest = HttpRequest$1.isInstance(request);
            if (isRequest) {
                request.headers[INVOCATION_ID_HEADER$1] = v4();
            }
            while (true) {
                try {
                    if (isRequest) {
                        request.headers[REQUEST_HEADER$1] = `attempt=${attempts + 1}; max=${maxAttempts}`;
                    }
                    const { response, output } = await next(args);
                    retryStrategy.recordSuccess(retryToken);
                    output.$metadata.attempts = attempts + 1;
                    output.$metadata.totalRetryDelay = totalRetryDelay;
                    return { response, output };
                }
                catch (e) {
                    const retryErrorInfo = getRetryErrorInfo$1(e);
                    lastError = asSdkError$1(e);
                    if (isRequest && isStreamingPayload$1(request)) {
                        (context.logger instanceof NoOpLogger$1 ? console : context.logger)?.warn("An error was encountered in a non-retryable streaming request.");
                        throw lastError;
                    }
                    try {
                        retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);
                    }
                    catch (refreshError) {
                        if (!lastError.$metadata) {
                            lastError.$metadata = {};
                        }
                        lastError.$metadata.attempts = attempts + 1;
                        lastError.$metadata.totalRetryDelay = totalRetryDelay;
                        throw lastError;
                    }
                    attempts = retryToken.getRetryCount();
                    const delay = retryToken.getRetryDelay();
                    totalRetryDelay += delay;
                    await new Promise((resolve) => setTimeout(resolve, delay));
                }
            }
        }
        else {
            retryStrategy = retryStrategy;
            if (retryStrategy?.mode)
                context.userAgent = [...(context.userAgent || []), ["cfg/retry-mode", retryStrategy.mode]];
            return retryStrategy.retry(next, args);
        }
    };
    const isRetryStrategyV2$1 = (retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== "undefined" &&
        typeof retryStrategy.refreshRetryTokenForRetry !== "undefined" &&
        typeof retryStrategy.recordSuccess !== "undefined";
    const getRetryErrorInfo$1 = (error) => {
        const errorInfo = {
            error,
            errorType: getRetryErrorType$1(error),
        };
        const retryAfterHint = getRetryAfterHint$1(error.$response);
        if (retryAfterHint) {
            errorInfo.retryAfterHint = retryAfterHint;
        }
        return errorInfo;
    };
    const getRetryErrorType$1 = (error) => {
        if (isThrottlingError$1(error))
            return "THROTTLING";
        if (isTransientError$1(error))
            return "TRANSIENT";
        if (isServerError$1(error))
            return "SERVER_ERROR";
        return "CLIENT_ERROR";
    };
    const retryMiddlewareOptions$1 = {
        name: "retryMiddleware",
        tags: ["RETRY"],
        step: "finalizeRequest",
        priority: "high",
        override: true,
    };
    const getRetryPlugin$1 = (options) => ({
        applyToStack: (clientStack) => {
            clientStack.add(retryMiddleware$1(options), retryMiddlewareOptions$1);
        },
    });
    const getRetryAfterHint$1 = (response) => {
        if (!HttpResponse$1.isInstance(response))
            return;
        const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
        if (!retryAfterHeaderName)
            return;
        const retryAfter = response.headers[retryAfterHeaderName];
        const retryAfterSeconds = Number(retryAfter);
        if (!Number.isNaN(retryAfterSeconds))
            return new Date(retryAfterSeconds * 1000);
        const retryAfterDate = new Date(retryAfter);
        return retryAfterDate;
    };

    class GeoPlacesClient extends Client$1 {
        constructor(...[configuration]) {
            let _config_0 = getRuntimeConfig$6(configuration || {});
            let _config_1 = resolveRegionConfig$1(_config_0);
            let _config_2 = resolveEndpointsConfig$1(_config_1);
            let _config_3 = resolveRetryConfig$1(_config_2);
            let _config_4 = resolveHostHeaderConfig$1(_config_3);
            let _config_5 = resolveAwsAuthConfig(_config_4);
            let _config_6 = resolveUserAgentConfig$1(_config_5);
            let _config_7 = resolveRuntimeExtensions$3(_config_6, configuration?.extensions || []);
            super(_config_7);
            this.config = _config_7;
            this.middlewareStack.use(getRetryPlugin$1(this.config));
            this.middlewareStack.use(getContentLengthPlugin$1(this.config));
            this.middlewareStack.use(getHostHeaderPlugin$1(this.config));
            this.middlewareStack.use(getLoggerPlugin$1(this.config));
            this.middlewareStack.use(getRecursionDetectionPlugin$1(this.config));
            this.middlewareStack.use(getAwsAuthPlugin(this.config));
            this.middlewareStack.use(getUserAgentPlugin$1(this.config));
        }
        destroy() {
            super.destroy();
        }
    }

    class GeoPlacesServiceException extends ServiceException$1 {
        constructor(options) {
            super(options);
            Object.setPrototypeOf(this, GeoPlacesServiceException.prototype);
        }
    }

    let AccessDeniedException$1 = class AccessDeniedException extends GeoPlacesServiceException {
        constructor(opts) {
            super({
                name: "AccessDeniedException",
                $fault: "client",
                ...opts
            });
            this.name = "AccessDeniedException";
            this.$fault = "client";
            Object.setPrototypeOf(this, AccessDeniedException.prototype);
            this.Message = opts.Message;
        }
    };
    let InternalServerException$1 = class InternalServerException extends GeoPlacesServiceException {
        constructor(opts) {
            super({
                name: "InternalServerException",
                $fault: "server",
                ...opts
            });
            this.name = "InternalServerException";
            this.$fault = "server";
            this.$retryable = {};
            Object.setPrototypeOf(this, InternalServerException.prototype);
            this.Message = opts.Message;
        }
    };
    let ThrottlingException$1 = class ThrottlingException extends GeoPlacesServiceException {
        constructor(opts) {
            super({
                name: "ThrottlingException",
                $fault: "client",
                ...opts
            });
            this.name = "ThrottlingException";
            this.$fault = "client";
            this.$retryable = {};
            Object.setPrototypeOf(this, ThrottlingException.prototype);
            this.Message = opts.Message;
        }
    };
    let ValidationException$1 = class ValidationException extends GeoPlacesServiceException {
        constructor(opts) {
            super({
                name: "ValidationException",
                $fault: "client",
                ...opts
            });
            this.name = "ValidationException";
            this.$fault = "client";
            Object.setPrototypeOf(this, ValidationException.prototype);
            this.Message = opts.Message;
            this.Reason = opts.Reason;
            this.FieldList = opts.FieldList;
        }
    };
    const AccessPointFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Position && { Position: SENSITIVE_STRING$1
        }),
    });
    const TypePlacement = {
        AFTER_BASE_NAME: "AfterBaseName",
        BEFORE_BASE_NAME: "BeforeBaseName",
    };
    const AutocompleteAdditionalFeature = {
        PLACEHOLDER: "PLACEHOLDER",
    };
    const FilterCircleFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Center && { Center: SENSITIVE_STRING$1
        }),
    });
    const AutocompleteFilterPlaceType = {
        COUNTRY: "Country",
        DISTRICT: "District",
        INTERPOLATED_ADDRESS: "InterpolatedAddress",
        INTERSECTION: "Intersection",
        LOCALITY: "Locality",
        POINT_ADDRESS: "PointAddress",
        POSTAL_CODE_AREA: "PostalCodeArea",
        POSTAL_CODE_POINT: "PostalCodePoint",
        REGION: "Region",
        STREET: "Street",
        SUB_DISTRICT: "SubDistrict",
        SUB_REGION: "SubRegion",
    };
    const AutocompleteFilterFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.BoundingBox && { BoundingBox: SENSITIVE_STRING$1
        }),
        ...(obj.Circle && { Circle: SENSITIVE_STRING$1
        }),
    });
    const IntendedUse = {
        SINGLE_USE: "SingleUse",
        STORAGE: "Storage",
    };
    const PostalCodeMode = {
        ENUMERATE_SPANNED_LOCALITIES: "EnumerateSpannedLocalities",
        MERGE_ALL_SPANNED_LOCALITIES: "MergeAllSpannedLocalities",
    };
    const AutocompleteRequestFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.QueryText && { QueryText: SENSITIVE_STRING$1
        }),
        ...(obj.BiasPosition && { BiasPosition: SENSITIVE_STRING$1
        }),
        ...(obj.Filter && { Filter: AutocompleteFilterFilterSensitiveLog(obj.Filter)
        }),
        ...(obj.Key && { Key: SENSITIVE_STRING$1
        }),
        ...(obj.KeyHeader && { KeyHeader: SENSITIVE_STRING$1
        }),
    });
    const PlaceType = {
        BLOCK: "Block",
        COUNTRY: "Country",
        DISTRICT: "District",
        INTERPOLATED_ADDRESS: "InterpolatedAddress",
        INTERSECTION: "Intersection",
        LOCALITY: "Locality",
        POINT_ADDRESS: "PointAddress",
        POINT_OF_INTEREST: "PointOfInterest",
        POSTAL_CODE_AREA: "PostalCodeArea",
        POSTAL_CODE_POINT: "PostalCodePoint",
        REGION: "Region",
        STREET: "Street",
        SUB_BLOCK: "SubBlock",
        SUB_DISTRICT: "SubDistrict",
        SUB_REGION: "SubRegion",
    };
    const GeocodeAdditionalFeature = {
        PARSED_QUERY: "ParsedQuery",
        TIME_ZONE: "TimeZone",
    };
    const GeocodeFilterPlaceType = {
        BLOCK: "Block",
        COUNTRY: "Country",
        DISTRICT: "District",
        INTERPOLATED_ADDRESS: "InterpolatedAddress",
        INTERSECTION: "Intersection",
        LOCALITY: "Locality",
        POINT_ADDRESS: "PointAddress",
        POINT_OF_INTEREST: "PointOfInterest",
        POSTAL_CODE_AREA: "PostalCodeArea",
        POSTAL_CODE_POINT: "PostalCodePoint",
        REGION: "Region",
        STREET: "Street",
        SUB_BLOCK: "SubBlock",
        SUB_DISTRICT: "SubDistrict",
        SUB_REGION: "SubRegion",
    };
    const GeocodeQueryComponentsFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Country && { Country: SENSITIVE_STRING$1
        }),
        ...(obj.Region && { Region: SENSITIVE_STRING$1
        }),
        ...(obj.SubRegion && { SubRegion: SENSITIVE_STRING$1
        }),
        ...(obj.Locality && { Locality: SENSITIVE_STRING$1
        }),
        ...(obj.District && { District: SENSITIVE_STRING$1
        }),
        ...(obj.Street && { Street: SENSITIVE_STRING$1
        }),
        ...(obj.AddressNumber && { AddressNumber: SENSITIVE_STRING$1
        }),
        ...(obj.PostalCode && { PostalCode: SENSITIVE_STRING$1
        }),
    });
    const GeocodeRequestFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.QueryText && { QueryText: SENSITIVE_STRING$1
        }),
        ...(obj.QueryComponents && { QueryComponents: GeocodeQueryComponentsFilterSensitiveLog(obj.QueryComponents)
        }),
        ...(obj.BiasPosition && { BiasPosition: SENSITIVE_STRING$1
        }),
        ...(obj.Key && { Key: SENSITIVE_STRING$1
        }),
        ...(obj.KeyHeader && { KeyHeader: SENSITIVE_STRING$1
        }),
    });
    const PostalAuthority = {
        USPS: "Usps",
    };
    const PostalCodeType = {
        USPS_ZIP: "UspsZip",
        USPS_ZIP_PLUS_4: "UspsZipPlus4",
    };
    const ZipClassificationCode = {
        MILITARY: "Military",
        POST_OFFICE_BOXES: "PostOfficeBoxes",
        UNIQUE: "Unique",
    };
    const RecordTypeCode = {
        FIRM: "Firm",
        GENERAL: "General",
        HIGH_RISE: "HighRise",
        POST_OFFICE_BOX: "PostOfficeBox",
        RURAL: "Rural",
        STREET: "Street",
    };
    const GeocodeResultItemFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Position && { Position: SENSITIVE_STRING$1
        }),
        ...(obj.MapView && { MapView: SENSITIVE_STRING$1
        }),
        ...(obj.AccessPoints && { AccessPoints: obj.AccessPoints.map(item => AccessPointFilterSensitiveLog(item))
        }),
    });
    const GeocodeResponseFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.ResultItems && { ResultItems: obj.ResultItems.map(item => GeocodeResultItemFilterSensitiveLog(item))
        }),
    });
    const GetPlaceAdditionalFeature = {
        PHONEMES: "Phonemes",
        TIME_ZONE: "TimeZone",
    };
    const GetPlaceRequestFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.PlaceId && { PlaceId: SENSITIVE_STRING$1
        }),
        ...(obj.Key && { Key: SENSITIVE_STRING$1
        }),
        ...(obj.KeyHeader && { KeyHeader: SENSITIVE_STRING$1
        }),
    });
    const GetPlaceResponseFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Position && { Position: SENSITIVE_STRING$1
        }),
        ...(obj.MapView && { MapView: SENSITIVE_STRING$1
        }),
        ...(obj.AccessPoints && { AccessPoints: obj.AccessPoints.map(item => AccessPointFilterSensitiveLog(item))
        }),
    });
    const ReverseGeocodeAdditionalFeature = {
        TIME_ZONE: "TimeZone",
    };
    const ReverseGeocodeFilterPlaceType = {
        BLOCK: "Block",
        COUNTRY: "Country",
        DISTRICT: "District",
        INTERPOLATED_ADDRESS: "InterpolatedAddress",
        LOCALITY: "Locality",
        POINT_ADDRESS: "PointAddress",
        POINT_OF_INTEREST: "PointOfInterest",
        POSTAL_CODE_AREA: "PostalCodeArea",
        POSTAL_CODE_POINT: "PostalCodePoint",
        REGION: "Region",
        STREET: "Street",
        SUB_BLOCK: "SubBlock",
        SUB_DISTRICT: "SubDistrict",
        SUB_REGION: "SubRegion",
    };
    const ReverseGeocodeRequestFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.QueryPosition && { QueryPosition: SENSITIVE_STRING$1
        }),
        ...(obj.Key && { Key: SENSITIVE_STRING$1
        }),
        ...(obj.KeyHeader && { KeyHeader: SENSITIVE_STRING$1
        }),
    });
    const ReverseGeocodeResultItemFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Position && { Position: SENSITIVE_STRING$1
        }),
        ...(obj.MapView && { MapView: SENSITIVE_STRING$1
        }),
        ...(obj.AccessPoints && { AccessPoints: obj.AccessPoints.map(item => AccessPointFilterSensitiveLog(item))
        }),
    });
    const ReverseGeocodeResponseFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.ResultItems && { ResultItems: obj.ResultItems.map(item => ReverseGeocodeResultItemFilterSensitiveLog(item))
        }),
    });
    const SearchNearbyAdditionalFeature = {
        PHONEMES: "Phonemes",
        TIME_ZONE: "TimeZone",
    };
    const SearchNearbyFilterFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.BoundingBox && { BoundingBox: SENSITIVE_STRING$1
        }),
    });
    const SearchNearbyRequestFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.QueryPosition && { QueryPosition: SENSITIVE_STRING$1
        }),
        ...(obj.Filter && { Filter: SearchNearbyFilterFilterSensitiveLog(obj.Filter)
        }),
        ...(obj.Key && { Key: SENSITIVE_STRING$1
        }),
        ...(obj.KeyHeader && { KeyHeader: SENSITIVE_STRING$1
        }),
    });
    const SearchNearbyResultItemFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Position && { Position: SENSITIVE_STRING$1
        }),
        ...(obj.MapView && { MapView: SENSITIVE_STRING$1
        }),
        ...(obj.AccessPoints && { AccessPoints: obj.AccessPoints.map(item => AccessPointFilterSensitiveLog(item))
        }),
    });
    const SearchNearbyResponseFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.ResultItems && { ResultItems: obj.ResultItems.map(item => SearchNearbyResultItemFilterSensitiveLog(item))
        }),
    });
    const SearchTextAdditionalFeature = {
        PHONEMES: "Phonemes",
        TIME_ZONE: "TimeZone",
    };
    const SearchTextFilterFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.BoundingBox && { BoundingBox: SENSITIVE_STRING$1
        }),
        ...(obj.Circle && { Circle: SENSITIVE_STRING$1
        }),
    });
    const SearchTextRequestFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.QueryText && { QueryText: SENSITIVE_STRING$1
        }),
        ...(obj.QueryId && { QueryId: SENSITIVE_STRING$1
        }),
        ...(obj.BiasPosition && { BiasPosition: SENSITIVE_STRING$1
        }),
        ...(obj.Filter && { Filter: SearchTextFilterFilterSensitiveLog(obj.Filter)
        }),
        ...(obj.Key && { Key: SENSITIVE_STRING$1
        }),
        ...(obj.KeyHeader && { KeyHeader: SENSITIVE_STRING$1
        }),
    });
    const SearchTextResultItemFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Position && { Position: SENSITIVE_STRING$1
        }),
        ...(obj.MapView && { MapView: SENSITIVE_STRING$1
        }),
        ...(obj.AccessPoints && { AccessPoints: obj.AccessPoints.map(item => AccessPointFilterSensitiveLog(item))
        }),
    });
    const SearchTextResponseFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.ResultItems && { ResultItems: obj.ResultItems.map(item => SearchTextResultItemFilterSensitiveLog(item))
        }),
    });
    const SuggestAdditionalFeature = {
        PHONEMES: "Phonemes",
        TIME_ZONE: "TimeZone",
    };
    const SuggestFilterFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.BoundingBox && { BoundingBox: SENSITIVE_STRING$1
        }),
        ...(obj.Circle && { Circle: SENSITIVE_STRING$1
        }),
    });
    const SuggestRequestFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.QueryText && { QueryText: SENSITIVE_STRING$1
        }),
        ...(obj.BiasPosition && { BiasPosition: SENSITIVE_STRING$1
        }),
        ...(obj.Filter && { Filter: SuggestFilterFilterSensitiveLog(obj.Filter)
        }),
        ...(obj.Key && { Key: SENSITIVE_STRING$1
        }),
        ...(obj.KeyHeader && { KeyHeader: SENSITIVE_STRING$1
        }),
    });
    const SuggestPlaceResultFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Position && { Position: SENSITIVE_STRING$1
        }),
        ...(obj.MapView && { MapView: SENSITIVE_STRING$1
        }),
        ...(obj.AccessPoints && { AccessPoints: obj.AccessPoints.map(item => AccessPointFilterSensitiveLog(item))
        }),
    });
    const QueryType = {
        BUSINESS_CHAIN: "BusinessChain",
        CATEGORY: "Category",
    };
    const SuggestResultItemType = {
        PLACE: "Place",
        QUERY: "Query",
    };
    const SuggestResultItemFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Place && { Place: SuggestPlaceResultFilterSensitiveLog(obj.Place)
        }),
    });
    const SuggestResponseFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.ResultItems && { ResultItems: obj.ResultItems.map(item => SuggestResultItemFilterSensitiveLog(item))
        }),
    });

    const se_AutocompleteCommand = async (input, context) => {
        const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
        const headers = map$1({}, isSerializableHeaderValue$1, {
            'content-type': 'application/json',
            'api-key': input.KeyHeader,
        });
        let resolvedPath = `${basePath?.endsWith('/') ? basePath.slice(0, -1) : (basePath || '')}` + "/autocomplete";
        const query = map$1({
            "key": [, input.Key],
        });
        let body;
        body = JSON.stringify(take$1(input, {
            'AdditionalFeatures': _ => _json$1(_),
            'BiasPosition': _ => se_Position$1(_),
            'Filter': _ => se_AutocompleteFilter(_),
            'IntendedUse': [],
            'Language': [],
            'MaxResults': [],
            'PoliticalView': [],
            'PostalCodeMode': [],
            'QueryText': [],
        }));
        return new HttpRequest$1({
            protocol,
            hostname,
            port,
            method: "POST",
            headers,
            path: resolvedPath,
            query,
            body,
        });
    };
    const se_GeocodeCommand = async (input, context) => {
        const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
        const headers = map$1({}, isSerializableHeaderValue$1, {
            'content-type': 'application/json',
            'api-key': input.KeyHeader,
        });
        let resolvedPath = `${basePath?.endsWith('/') ? basePath.slice(0, -1) : (basePath || '')}` + "/geocode";
        const query = map$1({
            "key": [, input.Key],
        });
        let body;
        body = JSON.stringify(take$1(input, {
            'AdditionalFeatures': _ => _json$1(_),
            'BiasPosition': _ => se_Position$1(_),
            'Filter': _ => _json$1(_),
            'IntendedUse': [],
            'Language': [],
            'MaxResults': [],
            'PoliticalView': [],
            'QueryComponents': _ => _json$1(_),
            'QueryText': [],
        }));
        return new HttpRequest$1({
            protocol,
            hostname,
            port,
            method: "POST",
            headers,
            path: resolvedPath,
            query,
            body,
        });
    };
    const se_GetPlaceCommand = async (input, context) => {
        const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
        const headers = map$1({}, isSerializableHeaderValue$1, {
            'api-key': input.KeyHeader,
        });
        let resolvedPath$1 = `${basePath?.endsWith('/') ? basePath.slice(0, -1) : (basePath || '')}` + "/place/{PlaceId}";
        resolvedPath$1 = resolvedPath(resolvedPath$1, input, 'PlaceId', () => input.PlaceId, '{PlaceId}');
        const query = map$1({
            "additional-features": [() => input.AdditionalFeatures !== void 0, () => ((input.AdditionalFeatures || []).map(_entry => _entry))],
            "language": [, input.Language],
            "political-view": [, input.PoliticalView],
            "intended-use": [, input.IntendedUse],
            "key": [, input.Key],
        });
        let body;
        return new HttpRequest$1({
            protocol,
            hostname,
            port,
            method: "GET",
            headers,
            path: resolvedPath$1,
            query,
            body,
        });
    };
    const se_ReverseGeocodeCommand = async (input, context) => {
        const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
        const headers = map$1({}, isSerializableHeaderValue$1, {
            'content-type': 'application/json',
            'api-key': input.KeyHeader,
        });
        let resolvedPath = `${basePath?.endsWith('/') ? basePath.slice(0, -1) : (basePath || '')}` + "/reverse-geocode";
        const query = map$1({
            "key": [, input.Key],
        });
        let body;
        body = JSON.stringify(take$1(input, {
            'AdditionalFeatures': _ => _json$1(_),
            'Filter': _ => _json$1(_),
            'IntendedUse': [],
            'Language': [],
            'MaxResults': [],
            'PoliticalView': [],
            'QueryPosition': _ => se_Position$1(_),
            'QueryRadius': [],
        }));
        return new HttpRequest$1({
            protocol,
            hostname,
            port,
            method: "POST",
            headers,
            path: resolvedPath,
            query,
            body,
        });
    };
    const se_SearchNearbyCommand = async (input, context) => {
        const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
        const headers = map$1({}, isSerializableHeaderValue$1, {
            'content-type': 'application/json',
            'api-key': input.KeyHeader,
        });
        let resolvedPath = `${basePath?.endsWith('/') ? basePath.slice(0, -1) : (basePath || '')}` + "/search-nearby";
        const query = map$1({
            "key": [, input.Key],
        });
        let body;
        body = JSON.stringify(take$1(input, {
            'AdditionalFeatures': _ => _json$1(_),
            'Filter': _ => se_SearchNearbyFilter(_),
            'IntendedUse': [],
            'Language': [],
            'MaxResults': [],
            'PoliticalView': [],
            'QueryPosition': _ => se_Position$1(_),
            'QueryRadius': [],
        }));
        return new HttpRequest$1({
            protocol,
            hostname,
            port,
            method: "POST",
            headers,
            path: resolvedPath,
            query,
            body,
        });
    };
    const se_SearchTextCommand = async (input, context) => {
        const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
        const headers = map$1({}, isSerializableHeaderValue$1, {
            'content-type': 'application/json',
            'api-key': input.KeyHeader,
        });
        let resolvedPath = `${basePath?.endsWith('/') ? basePath.slice(0, -1) : (basePath || '')}` + "/search-text";
        const query = map$1({
            "key": [, input.Key],
        });
        let body;
        body = JSON.stringify(take$1(input, {
            'AdditionalFeatures': _ => _json$1(_),
            'BiasPosition': _ => se_Position$1(_),
            'Filter': _ => se_SearchTextFilter(_),
            'IntendedUse': [],
            'Language': [],
            'MaxResults': [],
            'PoliticalView': [],
            'QueryId': [],
            'QueryText': [],
        }));
        return new HttpRequest$1({
            protocol,
            hostname,
            port,
            method: "POST",
            headers,
            path: resolvedPath,
            query,
            body,
        });
    };
    const se_SuggestCommand = async (input, context) => {
        const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
        const headers = map$1({}, isSerializableHeaderValue$1, {
            'content-type': 'application/json',
            'api-key': input.KeyHeader,
        });
        let resolvedPath = `${basePath?.endsWith('/') ? basePath.slice(0, -1) : (basePath || '')}` + "/suggest";
        const query = map$1({
            "key": [, input.Key],
        });
        let body;
        body = JSON.stringify(take$1(input, {
            'AdditionalFeatures': _ => _json$1(_),
            'BiasPosition': _ => se_Position$1(_),
            'Filter': _ => se_SuggestFilter(_),
            'IntendedUse': [],
            'Language': [],
            'MaxQueryRefinements': [],
            'MaxResults': [],
            'PoliticalView': [],
            'QueryText': [],
        }));
        return new HttpRequest$1({
            protocol,
            hostname,
            port,
            method: "POST",
            headers,
            path: resolvedPath,
            query,
            body,
        });
    };
    const de_AutocompleteCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_AutocompleteCommandError(output, context);
        }
        const contents = map$1({
            $metadata: deserializeMetadata$4(output),
            PricingBucket: [, output.headers['x-amz-geo-pricing-bucket']],
        });
        const data = expectNonNull$1((expectObject$1(await parseBody$1(output.body, context))), "body");
        const doc = take$1(data, {
            'ResultItems': _json$1,
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_AutocompleteCommandError = async (output, context) => {
        const parsedOutput = {
            ...output,
            body: await parseErrorBody$1(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode$1(output, parsedOutput.body);
        switch (errorCode) {
            case "AccessDeniedException":
            case "com.amazonaws.services.waypoint.exceptions#AccessDeniedException":
                throw await de_AccessDeniedExceptionRes$1(parsedOutput);
            case "InternalServerException":
            case "com.amazonaws.services.waypoint.exceptions#InternalServerException":
                throw await de_InternalServerExceptionRes$1(parsedOutput);
            case "ThrottlingException":
            case "com.amazonaws.services.waypoint.exceptions#ThrottlingException":
                throw await de_ThrottlingExceptionRes$1(parsedOutput);
            case "ValidationException":
            case "com.amazonaws.services.waypoint.exceptions#ValidationException":
                throw await de_ValidationExceptionRes$1(parsedOutput);
            default:
                const parsedBody = parsedOutput.body;
                return throwDefaultError$4({
                    output,
                    parsedBody,
                    errorCode
                });
        }
    };
    const de_GeocodeCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_GeocodeCommandError(output, context);
        }
        const contents = map$1({
            $metadata: deserializeMetadata$4(output),
            PricingBucket: [, output.headers['x-amz-geo-pricing-bucket']],
        });
        const data = expectNonNull$1((expectObject$1(await parseBody$1(output.body, context))), "body");
        const doc = take$1(data, {
            'ResultItems': _ => de_GeocodeResultItemList(_),
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_GeocodeCommandError = async (output, context) => {
        const parsedOutput = {
            ...output,
            body: await parseErrorBody$1(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode$1(output, parsedOutput.body);
        switch (errorCode) {
            case "AccessDeniedException":
            case "com.amazonaws.services.waypoint.exceptions#AccessDeniedException":
                throw await de_AccessDeniedExceptionRes$1(parsedOutput);
            case "InternalServerException":
            case "com.amazonaws.services.waypoint.exceptions#InternalServerException":
                throw await de_InternalServerExceptionRes$1(parsedOutput);
            case "ThrottlingException":
            case "com.amazonaws.services.waypoint.exceptions#ThrottlingException":
                throw await de_ThrottlingExceptionRes$1(parsedOutput);
            case "ValidationException":
            case "com.amazonaws.services.waypoint.exceptions#ValidationException":
                throw await de_ValidationExceptionRes$1(parsedOutput);
            default:
                const parsedBody = parsedOutput.body;
                return throwDefaultError$4({
                    output,
                    parsedBody,
                    errorCode
                });
        }
    };
    const de_GetPlaceCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_GetPlaceCommandError(output, context);
        }
        const contents = map$1({
            $metadata: deserializeMetadata$4(output),
            PricingBucket: [, output.headers['x-amz-geo-pricing-bucket']],
        });
        const data = expectNonNull$1((expectObject$1(await parseBody$1(output.body, context))), "body");
        const doc = take$1(data, {
            'AccessPoints': _ => de_AccessPointList(_),
            'AccessRestrictions': _json$1,
            'Address': _json$1,
            'AddressNumberCorrected': expectBoolean$1,
            'BusinessChains': _json$1,
            'Categories': _json$1,
            'Contacts': _json$1,
            'FoodTypes': _json$1,
            'MapView': _ => de_BoundingBox$1(_),
            'OpeningHours': _json$1,
            'Phonemes': _json$1,
            'PlaceId': expectString$1,
            'PlaceType': expectString$1,
            'PoliticalView': expectString$1,
            'Position': _ => de_Position$1(_),
            'PostalCodeDetails': _json$1,
            'TimeZone': _json$1,
            'Title': expectString$1,
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_GetPlaceCommandError = async (output, context) => {
        const parsedOutput = {
            ...output,
            body: await parseErrorBody$1(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode$1(output, parsedOutput.body);
        switch (errorCode) {
            case "AccessDeniedException":
            case "com.amazonaws.services.waypoint.exceptions#AccessDeniedException":
                throw await de_AccessDeniedExceptionRes$1(parsedOutput);
            case "InternalServerException":
            case "com.amazonaws.services.waypoint.exceptions#InternalServerException":
                throw await de_InternalServerExceptionRes$1(parsedOutput);
            case "ThrottlingException":
            case "com.amazonaws.services.waypoint.exceptions#ThrottlingException":
                throw await de_ThrottlingExceptionRes$1(parsedOutput);
            case "ValidationException":
            case "com.amazonaws.services.waypoint.exceptions#ValidationException":
                throw await de_ValidationExceptionRes$1(parsedOutput);
            default:
                const parsedBody = parsedOutput.body;
                return throwDefaultError$4({
                    output,
                    parsedBody,
                    errorCode
                });
        }
    };
    const de_ReverseGeocodeCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_ReverseGeocodeCommandError(output, context);
        }
        const contents = map$1({
            $metadata: deserializeMetadata$4(output),
            PricingBucket: [, output.headers['x-amz-geo-pricing-bucket']],
        });
        const data = expectNonNull$1((expectObject$1(await parseBody$1(output.body, context))), "body");
        const doc = take$1(data, {
            'ResultItems': _ => de_ReverseGeocodeResultItemList(_),
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_ReverseGeocodeCommandError = async (output, context) => {
        const parsedOutput = {
            ...output,
            body: await parseErrorBody$1(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode$1(output, parsedOutput.body);
        switch (errorCode) {
            case "AccessDeniedException":
            case "com.amazonaws.services.waypoint.exceptions#AccessDeniedException":
                throw await de_AccessDeniedExceptionRes$1(parsedOutput);
            case "InternalServerException":
            case "com.amazonaws.services.waypoint.exceptions#InternalServerException":
                throw await de_InternalServerExceptionRes$1(parsedOutput);
            case "ThrottlingException":
            case "com.amazonaws.services.waypoint.exceptions#ThrottlingException":
                throw await de_ThrottlingExceptionRes$1(parsedOutput);
            case "ValidationException":
            case "com.amazonaws.services.waypoint.exceptions#ValidationException":
                throw await de_ValidationExceptionRes$1(parsedOutput);
            default:
                const parsedBody = parsedOutput.body;
                return throwDefaultError$4({
                    output,
                    parsedBody,
                    errorCode
                });
        }
    };
    const de_SearchNearbyCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_SearchNearbyCommandError(output, context);
        }
        const contents = map$1({
            $metadata: deserializeMetadata$4(output),
            PricingBucket: [, output.headers['x-amz-geo-pricing-bucket']],
        });
        const data = expectNonNull$1((expectObject$1(await parseBody$1(output.body, context))), "body");
        const doc = take$1(data, {
            'ResultItems': _ => de_SearchNearbyResultItemList(_),
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_SearchNearbyCommandError = async (output, context) => {
        const parsedOutput = {
            ...output,
            body: await parseErrorBody$1(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode$1(output, parsedOutput.body);
        switch (errorCode) {
            case "AccessDeniedException":
            case "com.amazonaws.services.waypoint.exceptions#AccessDeniedException":
                throw await de_AccessDeniedExceptionRes$1(parsedOutput);
            case "InternalServerException":
            case "com.amazonaws.services.waypoint.exceptions#InternalServerException":
                throw await de_InternalServerExceptionRes$1(parsedOutput);
            case "ThrottlingException":
            case "com.amazonaws.services.waypoint.exceptions#ThrottlingException":
                throw await de_ThrottlingExceptionRes$1(parsedOutput);
            case "ValidationException":
            case "com.amazonaws.services.waypoint.exceptions#ValidationException":
                throw await de_ValidationExceptionRes$1(parsedOutput);
            default:
                const parsedBody = parsedOutput.body;
                return throwDefaultError$4({
                    output,
                    parsedBody,
                    errorCode
                });
        }
    };
    const de_SearchTextCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_SearchTextCommandError(output, context);
        }
        const contents = map$1({
            $metadata: deserializeMetadata$4(output),
            PricingBucket: [, output.headers['x-amz-geo-pricing-bucket']],
        });
        const data = expectNonNull$1((expectObject$1(await parseBody$1(output.body, context))), "body");
        const doc = take$1(data, {
            'ResultItems': _ => de_SearchTextResultItemList(_),
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_SearchTextCommandError = async (output, context) => {
        const parsedOutput = {
            ...output,
            body: await parseErrorBody$1(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode$1(output, parsedOutput.body);
        switch (errorCode) {
            case "AccessDeniedException":
            case "com.amazonaws.services.waypoint.exceptions#AccessDeniedException":
                throw await de_AccessDeniedExceptionRes$1(parsedOutput);
            case "InternalServerException":
            case "com.amazonaws.services.waypoint.exceptions#InternalServerException":
                throw await de_InternalServerExceptionRes$1(parsedOutput);
            case "ThrottlingException":
            case "com.amazonaws.services.waypoint.exceptions#ThrottlingException":
                throw await de_ThrottlingExceptionRes$1(parsedOutput);
            case "ValidationException":
            case "com.amazonaws.services.waypoint.exceptions#ValidationException":
                throw await de_ValidationExceptionRes$1(parsedOutput);
            default:
                const parsedBody = parsedOutput.body;
                return throwDefaultError$4({
                    output,
                    parsedBody,
                    errorCode
                });
        }
    };
    const de_SuggestCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_SuggestCommandError(output, context);
        }
        const contents = map$1({
            $metadata: deserializeMetadata$4(output),
            PricingBucket: [, output.headers['x-amz-geo-pricing-bucket']],
        });
        const data = expectNonNull$1((expectObject$1(await parseBody$1(output.body, context))), "body");
        const doc = take$1(data, {
            'QueryRefinements': _json$1,
            'ResultItems': _ => de_SuggestResultItemList(_),
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_SuggestCommandError = async (output, context) => {
        const parsedOutput = {
            ...output,
            body: await parseErrorBody$1(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode$1(output, parsedOutput.body);
        switch (errorCode) {
            case "AccessDeniedException":
            case "com.amazonaws.services.waypoint.exceptions#AccessDeniedException":
                throw await de_AccessDeniedExceptionRes$1(parsedOutput);
            case "InternalServerException":
            case "com.amazonaws.services.waypoint.exceptions#InternalServerException":
                throw await de_InternalServerExceptionRes$1(parsedOutput);
            case "ThrottlingException":
            case "com.amazonaws.services.waypoint.exceptions#ThrottlingException":
                throw await de_ThrottlingExceptionRes$1(parsedOutput);
            case "ValidationException":
            case "com.amazonaws.services.waypoint.exceptions#ValidationException":
                throw await de_ValidationExceptionRes$1(parsedOutput);
            default:
                const parsedBody = parsedOutput.body;
                return throwDefaultError$4({
                    output,
                    parsedBody,
                    errorCode
                });
        }
    };
    const throwDefaultError$4 = withBaseException$1(GeoPlacesServiceException);
    const de_AccessDeniedExceptionRes$1 = async (parsedOutput, context) => {
        const contents = map$1({});
        const data = parsedOutput.body;
        const doc = take$1(data, {
            'Message': [, expectString$1, `message`],
        });
        Object.assign(contents, doc);
        const exception = new AccessDeniedException$1({
            $metadata: deserializeMetadata$4(parsedOutput),
            ...contents
        });
        return decorateServiceException$1(exception, parsedOutput.body);
    };
    const de_InternalServerExceptionRes$1 = async (parsedOutput, context) => {
        const contents = map$1({});
        const data = parsedOutput.body;
        const doc = take$1(data, {
            'Message': [, expectString$1, `message`],
        });
        Object.assign(contents, doc);
        const exception = new InternalServerException$1({
            $metadata: deserializeMetadata$4(parsedOutput),
            ...contents
        });
        return decorateServiceException$1(exception, parsedOutput.body);
    };
    const de_ThrottlingExceptionRes$1 = async (parsedOutput, context) => {
        const contents = map$1({});
        const data = parsedOutput.body;
        const doc = take$1(data, {
            'Message': [, expectString$1, `message`],
        });
        Object.assign(contents, doc);
        const exception = new ThrottlingException$1({
            $metadata: deserializeMetadata$4(parsedOutput),
            ...contents
        });
        return decorateServiceException$1(exception, parsedOutput.body);
    };
    const de_ValidationExceptionRes$1 = async (parsedOutput, context) => {
        const contents = map$1({});
        const data = parsedOutput.body;
        const doc = take$1(data, {
            'FieldList': [, _ => de_ValidationExceptionFieldList$1(_), `fieldList`],
            'Message': [, expectString$1, `message`],
            'Reason': [, expectString$1, `reason`],
        });
        Object.assign(contents, doc);
        const exception = new ValidationException$1({
            $metadata: deserializeMetadata$4(parsedOutput),
            ...contents
        });
        return decorateServiceException$1(exception, parsedOutput.body);
    };
    const se_AutocompleteFilter = (input, context) => {
        return take$1(input, {
            'BoundingBox': _ => se_BoundingBox$1(_),
            'Circle': _ => se_FilterCircle(_),
            'IncludeCountries': _json$1,
            'IncludePlaceTypes': _json$1,
        });
    };
    const se_FilterCircle = (input, context) => {
        return take$1(input, {
            'Center': _ => se_Position$1(_),
            'Radius': [],
        });
    };
    const se_SearchNearbyFilter = (input, context) => {
        return take$1(input, {
            'BoundingBox': _ => se_BoundingBox$1(_),
            'ExcludeBusinessChains': _json$1,
            'ExcludeCategories': _json$1,
            'ExcludeFoodTypes': _json$1,
            'IncludeBusinessChains': _json$1,
            'IncludeCategories': _json$1,
            'IncludeCountries': _json$1,
            'IncludeFoodTypes': _json$1,
        });
    };
    const se_SearchTextFilter = (input, context) => {
        return take$1(input, {
            'BoundingBox': _ => se_BoundingBox$1(_),
            'Circle': _ => se_FilterCircle(_),
            'IncludeCountries': _json$1,
        });
    };
    const se_SuggestFilter = (input, context) => {
        return take$1(input, {
            'BoundingBox': _ => se_BoundingBox$1(_),
            'Circle': _ => se_FilterCircle(_),
            'IncludeCountries': _json$1,
        });
    };
    const se_BoundingBox$1 = (input, context) => {
        return input.filter((e) => e != null).map(entry => {
            return serializeFloat$1(entry);
        });
    };
    const se_Position$1 = (input, context) => {
        return input.filter((e) => e != null).map(entry => {
            return serializeFloat$1(entry);
        });
    };
    const de_ValidationExceptionField$1 = (output, context) => {
        return take$1(output, {
            'Message': [, expectString$1, `message`],
            'Name': [, expectString$1, `name`],
        });
    };
    const de_ValidationExceptionFieldList$1 = (output, context) => {
        const retVal = (output || []).filter((e) => e != null).map((entry) => {
            return de_ValidationExceptionField$1(entry);
        });
        return retVal;
    };
    const de_AccessPoint = (output, context) => {
        return take$1(output, {
            'Position': (_) => de_Position$1(_),
        });
    };
    const de_AccessPointList = (output, context) => {
        const retVal = (output || []).filter((e) => e != null).map((entry) => {
            return de_AccessPoint(entry);
        });
        return retVal;
    };
    const de_AddressComponentMatchScores = (output, context) => {
        return take$1(output, {
            'AddressNumber': limitedParseDouble$1,
            'Block': limitedParseDouble$1,
            'Building': limitedParseDouble$1,
            'Country': limitedParseDouble$1,
            'District': limitedParseDouble$1,
            'Intersection': (_) => de_MatchScoreList(_),
            'Locality': limitedParseDouble$1,
            'PostalCode': limitedParseDouble$1,
            'Region': limitedParseDouble$1,
            'SubBlock': limitedParseDouble$1,
            'SubDistrict': limitedParseDouble$1,
            'SubRegion': limitedParseDouble$1,
        });
    };
    const de_ComponentMatchScores = (output, context) => {
        return take$1(output, {
            'Address': (_) => de_AddressComponentMatchScores(_),
            'Title': limitedParseDouble$1,
        });
    };
    const de_GeocodeResultItem = (output, context) => {
        return take$1(output, {
            'AccessPoints': (_) => de_AccessPointList(_),
            'Address': _json$1,
            'AddressNumberCorrected': expectBoolean$1,
            'Categories': _json$1,
            'Distance': expectLong$1,
            'FoodTypes': _json$1,
            'MapView': (_) => de_BoundingBox$1(_),
            'MatchScores': (_) => de_MatchScoreDetails(_),
            'ParsedQuery': _json$1,
            'PlaceId': expectString$1,
            'PlaceType': expectString$1,
            'PoliticalView': expectString$1,
            'Position': (_) => de_Position$1(_),
            'PostalCodeDetails': _json$1,
            'TimeZone': _json$1,
            'Title': expectString$1,
        });
    };
    const de_GeocodeResultItemList = (output, context) => {
        const retVal = (output || []).filter((e) => e != null).map((entry) => {
            return de_GeocodeResultItem(entry);
        });
        return retVal;
    };
    const de_MatchScoreDetails = (output, context) => {
        return take$1(output, {
            'Components': (_) => de_ComponentMatchScores(_),
            'Overall': limitedParseDouble$1,
        });
    };
    const de_MatchScoreList = (output, context) => {
        const retVal = (output || []).filter((e) => e != null).map((entry) => {
            return limitedParseDouble$1(entry);
        });
        return retVal;
    };
    const de_ReverseGeocodeResultItem = (output, context) => {
        return take$1(output, {
            'AccessPoints': (_) => de_AccessPointList(_),
            'Address': _json$1,
            'AddressNumberCorrected': expectBoolean$1,
            'Categories': _json$1,
            'Distance': expectLong$1,
            'FoodTypes': _json$1,
            'MapView': (_) => de_BoundingBox$1(_),
            'PlaceId': expectString$1,
            'PlaceType': expectString$1,
            'PoliticalView': expectString$1,
            'Position': (_) => de_Position$1(_),
            'PostalCodeDetails': _json$1,
            'TimeZone': _json$1,
            'Title': expectString$1,
        });
    };
    const de_ReverseGeocodeResultItemList = (output, context) => {
        const retVal = (output || []).filter((e) => e != null).map((entry) => {
            return de_ReverseGeocodeResultItem(entry);
        });
        return retVal;
    };
    const de_SearchNearbyResultItem = (output, context) => {
        return take$1(output, {
            'AccessPoints': (_) => de_AccessPointList(_),
            'AccessRestrictions': _json$1,
            'Address': _json$1,
            'AddressNumberCorrected': expectBoolean$1,
            'BusinessChains': _json$1,
            'Categories': _json$1,
            'Contacts': _json$1,
            'Distance': expectLong$1,
            'FoodTypes': _json$1,
            'MapView': (_) => de_BoundingBox$1(_),
            'OpeningHours': _json$1,
            'Phonemes': _json$1,
            'PlaceId': expectString$1,
            'PlaceType': expectString$1,
            'PoliticalView': expectString$1,
            'Position': (_) => de_Position$1(_),
            'TimeZone': _json$1,
            'Title': expectString$1,
        });
    };
    const de_SearchNearbyResultItemList = (output, context) => {
        const retVal = (output || []).filter((e) => e != null).map((entry) => {
            return de_SearchNearbyResultItem(entry);
        });
        return retVal;
    };
    const de_SearchTextResultItem = (output, context) => {
        return take$1(output, {
            'AccessPoints': (_) => de_AccessPointList(_),
            'AccessRestrictions': _json$1,
            'Address': _json$1,
            'AddressNumberCorrected': expectBoolean$1,
            'BusinessChains': _json$1,
            'Categories': _json$1,
            'Contacts': _json$1,
            'Distance': expectLong$1,
            'FoodTypes': _json$1,
            'MapView': (_) => de_BoundingBox$1(_),
            'OpeningHours': _json$1,
            'Phonemes': _json$1,
            'PlaceId': expectString$1,
            'PlaceType': expectString$1,
            'PoliticalView': expectString$1,
            'Position': (_) => de_Position$1(_),
            'TimeZone': _json$1,
            'Title': expectString$1,
        });
    };
    const de_SearchTextResultItemList = (output, context) => {
        const retVal = (output || []).filter((e) => e != null).map((entry) => {
            return de_SearchTextResultItem(entry);
        });
        return retVal;
    };
    const de_SuggestPlaceResult = (output, context) => {
        return take$1(output, {
            'AccessPoints': (_) => de_AccessPointList(_),
            'AccessRestrictions': _json$1,
            'Address': _json$1,
            'BusinessChains': _json$1,
            'Categories': _json$1,
            'Distance': expectLong$1,
            'FoodTypes': _json$1,
            'MapView': (_) => de_BoundingBox$1(_),
            'Phonemes': _json$1,
            'PlaceId': expectString$1,
            'PlaceType': expectString$1,
            'PoliticalView': expectString$1,
            'Position': (_) => de_Position$1(_),
            'TimeZone': _json$1,
        });
    };
    const de_SuggestResultItem = (output, context) => {
        return take$1(output, {
            'Highlights': _json$1,
            'Place': (_) => de_SuggestPlaceResult(_),
            'Query': _json$1,
            'SuggestResultItemType': expectString$1,
            'Title': expectString$1,
        });
    };
    const de_SuggestResultItemList = (output, context) => {
        const retVal = (output || []).filter((e) => e != null).map((entry) => {
            return de_SuggestResultItem(entry);
        });
        return retVal;
    };
    const de_BoundingBox$1 = (output, context) => {
        const retVal = (output || []).filter((e) => e != null).map((entry) => {
            return limitedParseDouble$1(entry);
        });
        return retVal;
    };
    const de_Position$1 = (output, context) => {
        const retVal = (output || []).filter((e) => e != null).map((entry) => {
            return limitedParseDouble$1(entry);
        });
        return retVal;
    };
    const deserializeMetadata$4 = (output) => ({
        httpStatusCode: output.statusCode,
        requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
        extendedRequestId: output.headers["x-amz-id-2"],
        cfId: output.headers["x-amz-cf-id"],
    });
    const collectBodyString$1 = (streamBody, context) => collectBody$1(streamBody, context).then(body => context.utf8Encoder(body));
    const isSerializableHeaderValue$1 = (value) => value !== undefined &&
        value !== null &&
        value !== "" &&
        (!Object.getOwnPropertyNames(value).includes("length") ||
            value.length != 0) &&
        (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
    const parseBody$1 = (streamBody, context) => collectBodyString$1(streamBody, context).then(encoded => {
        if (encoded.length) {
            return JSON.parse(encoded);
        }
        return {};
    });
    const parseErrorBody$1 = async (errorBody, context) => {
        const value = await parseBody$1(errorBody, context);
        value.message = value.message ?? value.Message;
        return value;
    };
    const loadRestJsonErrorCode$1 = (output, data) => {
        const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
        const sanitizeErrorCode = (rawValue) => {
            let cleanValue = rawValue;
            if (typeof cleanValue === "number") {
                cleanValue = cleanValue.toString();
            }
            if (cleanValue.indexOf(",") >= 0) {
                cleanValue = cleanValue.split(",")[0];
            }
            if (cleanValue.indexOf(":") >= 0) {
                cleanValue = cleanValue.split(":")[0];
            }
            if (cleanValue.indexOf("#") >= 0) {
                cleanValue = cleanValue.split("#")[1];
            }
            return cleanValue;
        };
        const headerKey = findKey(output.headers, "x-amzn-errortype");
        if (headerKey !== undefined) {
            return sanitizeErrorCode(output.headers[headerKey]);
        }
        if (data.code !== undefined) {
            return sanitizeErrorCode(data.code);
        }
        if (data["__type"] !== undefined) {
            return sanitizeErrorCode(data["__type"]);
        }
    };

    const deserializerMiddleware$1 = (options, deserializer) => (next, context) => async (args) => {
        const { response } = await next(args);
        try {
            const parsed = await deserializer(response, options);
            return {
                response,
                output: parsed,
            };
        }
        catch (error) {
            Object.defineProperty(error, "$response", {
                value: response,
            });
            if (!("$metadata" in error)) {
                const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
                error.message += "\n  " + hint;
                if (typeof error.$responseBodyText !== "undefined") {
                    if (error.$response) {
                        error.$response.body = error.$responseBodyText;
                    }
                }
            }
            throw error;
        }
    };

    const serializerMiddleware$1 = (options, serializer) => (next, context) => async (args) => {
        const endpoint = context.endpointV2?.url && options.urlParser
            ? async () => options.urlParser(context.endpointV2.url)
            : options.endpoint;
        if (!endpoint) {
            throw new Error("No valid endpoint provider available.");
        }
        const request = await serializer(args.input, { ...options, endpoint });
        return next({
            ...args,
            request,
        });
    };

    const deserializerMiddlewareOption$1 = {
        name: "deserializerMiddleware",
        step: "deserialize",
        tags: ["DESERIALIZER"],
        override: true,
    };
    const serializerMiddlewareOption$1 = {
        name: "serializerMiddleware",
        step: "serialize",
        tags: ["SERIALIZER"],
        override: true,
    };
    function getSerdePlugin$1(config, serializer, deserializer) {
        return {
            applyToStack: (commandStack) => {
                commandStack.add(deserializerMiddleware$1(config, deserializer), deserializerMiddlewareOption$1);
                commandStack.add(serializerMiddleware$1(config, serializer), serializerMiddlewareOption$1);
            },
        };
    }

    class AutocompleteCommand extends Command$1 {
        constructor(input) {
            super();
            this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
            this.middlewareStack.use(getSerdePlugin$1(configuration, this.serialize, this.deserialize));
            const stack = clientStack.concat(this.middlewareStack);
            const { logger } = configuration;
            const clientName = "GeoPlacesClient";
            const commandName = "AutocompleteCommand";
            const handlerExecutionContext = {
                logger,
                clientName,
                commandName,
                inputFilterSensitiveLog: AutocompleteRequestFilterSensitiveLog,
                outputFilterSensitiveLog: (_) => _,
                [SMITHY_CONTEXT_KEY$1]: {
                    service: "PlacesService",
                    operation: "Autocomplete",
                },
            };
            const { requestHandler } = configuration;
            return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
            return se_AutocompleteCommand(input, context);
        }
        deserialize(output, context) {
            return de_AutocompleteCommand(output, context);
        }
    }

    class GeocodeCommand extends Command$1 {
        constructor(input) {
            super();
            this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
            this.middlewareStack.use(getSerdePlugin$1(configuration, this.serialize, this.deserialize));
            const stack = clientStack.concat(this.middlewareStack);
            const { logger } = configuration;
            const clientName = "GeoPlacesClient";
            const commandName = "GeocodeCommand";
            const handlerExecutionContext = {
                logger,
                clientName,
                commandName,
                inputFilterSensitiveLog: GeocodeRequestFilterSensitiveLog,
                outputFilterSensitiveLog: GeocodeResponseFilterSensitiveLog,
                [SMITHY_CONTEXT_KEY$1]: {
                    service: "PlacesService",
                    operation: "Geocode",
                },
            };
            const { requestHandler } = configuration;
            return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
            return se_GeocodeCommand(input, context);
        }
        deserialize(output, context) {
            return de_GeocodeCommand(output, context);
        }
    }

    class GetPlaceCommand extends Command$1 {
        constructor(input) {
            super();
            this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
            this.middlewareStack.use(getSerdePlugin$1(configuration, this.serialize, this.deserialize));
            const stack = clientStack.concat(this.middlewareStack);
            const { logger } = configuration;
            const clientName = "GeoPlacesClient";
            const commandName = "GetPlaceCommand";
            const handlerExecutionContext = {
                logger,
                clientName,
                commandName,
                inputFilterSensitiveLog: GetPlaceRequestFilterSensitiveLog,
                outputFilterSensitiveLog: GetPlaceResponseFilterSensitiveLog,
                [SMITHY_CONTEXT_KEY$1]: {
                    service: "PlacesService",
                    operation: "GetPlace",
                },
            };
            const { requestHandler } = configuration;
            return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
            return se_GetPlaceCommand(input, context);
        }
        deserialize(output, context) {
            return de_GetPlaceCommand(output, context);
        }
    }

    class ReverseGeocodeCommand extends Command$1 {
        constructor(input) {
            super();
            this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
            this.middlewareStack.use(getSerdePlugin$1(configuration, this.serialize, this.deserialize));
            const stack = clientStack.concat(this.middlewareStack);
            const { logger } = configuration;
            const clientName = "GeoPlacesClient";
            const commandName = "ReverseGeocodeCommand";
            const handlerExecutionContext = {
                logger,
                clientName,
                commandName,
                inputFilterSensitiveLog: ReverseGeocodeRequestFilterSensitiveLog,
                outputFilterSensitiveLog: ReverseGeocodeResponseFilterSensitiveLog,
                [SMITHY_CONTEXT_KEY$1]: {
                    service: "PlacesService",
                    operation: "ReverseGeocode",
                },
            };
            const { requestHandler } = configuration;
            return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
            return se_ReverseGeocodeCommand(input, context);
        }
        deserialize(output, context) {
            return de_ReverseGeocodeCommand(output, context);
        }
    }

    class SearchNearbyCommand extends Command$1 {
        constructor(input) {
            super();
            this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
            this.middlewareStack.use(getSerdePlugin$1(configuration, this.serialize, this.deserialize));
            const stack = clientStack.concat(this.middlewareStack);
            const { logger } = configuration;
            const clientName = "GeoPlacesClient";
            const commandName = "SearchNearbyCommand";
            const handlerExecutionContext = {
                logger,
                clientName,
                commandName,
                inputFilterSensitiveLog: SearchNearbyRequestFilterSensitiveLog,
                outputFilterSensitiveLog: SearchNearbyResponseFilterSensitiveLog,
                [SMITHY_CONTEXT_KEY$1]: {
                    service: "PlacesService",
                    operation: "SearchNearby",
                },
            };
            const { requestHandler } = configuration;
            return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
            return se_SearchNearbyCommand(input, context);
        }
        deserialize(output, context) {
            return de_SearchNearbyCommand(output, context);
        }
    }

    class SearchTextCommand extends Command$1 {
        constructor(input) {
            super();
            this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
            this.middlewareStack.use(getSerdePlugin$1(configuration, this.serialize, this.deserialize));
            const stack = clientStack.concat(this.middlewareStack);
            const { logger } = configuration;
            const clientName = "GeoPlacesClient";
            const commandName = "SearchTextCommand";
            const handlerExecutionContext = {
                logger,
                clientName,
                commandName,
                inputFilterSensitiveLog: SearchTextRequestFilterSensitiveLog,
                outputFilterSensitiveLog: SearchTextResponseFilterSensitiveLog,
                [SMITHY_CONTEXT_KEY$1]: {
                    service: "PlacesService",
                    operation: "SearchText",
                },
            };
            const { requestHandler } = configuration;
            return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
            return se_SearchTextCommand(input, context);
        }
        deserialize(output, context) {
            return de_SearchTextCommand(output, context);
        }
    }

    class SuggestCommand extends Command$1 {
        constructor(input) {
            super();
            this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
            this.middlewareStack.use(getSerdePlugin$1(configuration, this.serialize, this.deserialize));
            const stack = clientStack.concat(this.middlewareStack);
            const { logger } = configuration;
            const clientName = "GeoPlacesClient";
            const commandName = "SuggestCommand";
            const handlerExecutionContext = {
                logger,
                clientName,
                commandName,
                inputFilterSensitiveLog: SuggestRequestFilterSensitiveLog,
                outputFilterSensitiveLog: SuggestResponseFilterSensitiveLog,
                [SMITHY_CONTEXT_KEY$1]: {
                    service: "PlacesService",
                    operation: "Suggest",
                },
            };
            const { requestHandler } = configuration;
            return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
            return se_SuggestCommand(input, context);
        }
        deserialize(output, context) {
            return de_SuggestCommand(output, context);
        }
    }

    const commands$1 = {
        AutocompleteCommand,
        GeocodeCommand,
        GetPlaceCommand,
        ReverseGeocodeCommand,
        SearchNearbyCommand,
        SearchTextCommand,
        SuggestCommand,
    };
    class GeoPlaces extends GeoPlacesClient {
    }
    createAggregatedClient$1(commands$1, GeoPlaces);

    var index$2 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        $Command: Command$1,
        AccessDeniedException: AccessDeniedException$1,
        AccessPointFilterSensitiveLog: AccessPointFilterSensitiveLog,
        AutocompleteAdditionalFeature: AutocompleteAdditionalFeature,
        AutocompleteCommand: AutocompleteCommand,
        AutocompleteFilterFilterSensitiveLog: AutocompleteFilterFilterSensitiveLog,
        AutocompleteFilterPlaceType: AutocompleteFilterPlaceType,
        AutocompleteRequestFilterSensitiveLog: AutocompleteRequestFilterSensitiveLog,
        FilterCircleFilterSensitiveLog: FilterCircleFilterSensitiveLog,
        GeoPlaces: GeoPlaces,
        GeoPlacesClient: GeoPlacesClient,
        GeoPlacesServiceException: GeoPlacesServiceException,
        GeocodeAdditionalFeature: GeocodeAdditionalFeature,
        GeocodeCommand: GeocodeCommand,
        GeocodeFilterPlaceType: GeocodeFilterPlaceType,
        GeocodeQueryComponentsFilterSensitiveLog: GeocodeQueryComponentsFilterSensitiveLog,
        GeocodeRequestFilterSensitiveLog: GeocodeRequestFilterSensitiveLog,
        GeocodeResponseFilterSensitiveLog: GeocodeResponseFilterSensitiveLog,
        GeocodeResultItemFilterSensitiveLog: GeocodeResultItemFilterSensitiveLog,
        GetPlaceAdditionalFeature: GetPlaceAdditionalFeature,
        GetPlaceCommand: GetPlaceCommand,
        GetPlaceRequestFilterSensitiveLog: GetPlaceRequestFilterSensitiveLog,
        GetPlaceResponseFilterSensitiveLog: GetPlaceResponseFilterSensitiveLog,
        IntendedUse: IntendedUse,
        InternalServerException: InternalServerException$1,
        PlaceType: PlaceType,
        PostalAuthority: PostalAuthority,
        PostalCodeMode: PostalCodeMode,
        PostalCodeType: PostalCodeType,
        QueryType: QueryType,
        RecordTypeCode: RecordTypeCode,
        ReverseGeocodeAdditionalFeature: ReverseGeocodeAdditionalFeature,
        ReverseGeocodeCommand: ReverseGeocodeCommand,
        ReverseGeocodeFilterPlaceType: ReverseGeocodeFilterPlaceType,
        ReverseGeocodeRequestFilterSensitiveLog: ReverseGeocodeRequestFilterSensitiveLog,
        ReverseGeocodeResponseFilterSensitiveLog: ReverseGeocodeResponseFilterSensitiveLog,
        ReverseGeocodeResultItemFilterSensitiveLog: ReverseGeocodeResultItemFilterSensitiveLog,
        SearchNearbyAdditionalFeature: SearchNearbyAdditionalFeature,
        SearchNearbyCommand: SearchNearbyCommand,
        SearchNearbyFilterFilterSensitiveLog: SearchNearbyFilterFilterSensitiveLog,
        SearchNearbyRequestFilterSensitiveLog: SearchNearbyRequestFilterSensitiveLog,
        SearchNearbyResponseFilterSensitiveLog: SearchNearbyResponseFilterSensitiveLog,
        SearchNearbyResultItemFilterSensitiveLog: SearchNearbyResultItemFilterSensitiveLog,
        SearchTextAdditionalFeature: SearchTextAdditionalFeature,
        SearchTextCommand: SearchTextCommand,
        SearchTextFilterFilterSensitiveLog: SearchTextFilterFilterSensitiveLog,
        SearchTextRequestFilterSensitiveLog: SearchTextRequestFilterSensitiveLog,
        SearchTextResponseFilterSensitiveLog: SearchTextResponseFilterSensitiveLog,
        SearchTextResultItemFilterSensitiveLog: SearchTextResultItemFilterSensitiveLog,
        SuggestAdditionalFeature: SuggestAdditionalFeature,
        SuggestCommand: SuggestCommand,
        SuggestFilterFilterSensitiveLog: SuggestFilterFilterSensitiveLog,
        SuggestPlaceResultFilterSensitiveLog: SuggestPlaceResultFilterSensitiveLog,
        SuggestRequestFilterSensitiveLog: SuggestRequestFilterSensitiveLog,
        SuggestResponseFilterSensitiveLog: SuggestResponseFilterSensitiveLog,
        SuggestResultItemFilterSensitiveLog: SuggestResultItemFilterSensitiveLog,
        SuggestResultItemType: SuggestResultItemType,
        ThrottlingException: ThrottlingException$1,
        TypePlacement: TypePlacement,
        ValidationException: ValidationException$1,
        ZipClassificationCode: ZipClassificationCode,
        __Client: Client$1
    });

    var name$2 = "@amzn/georoutes-client";
    var description$2 = "@amzn/georoutes-client client";
    var version$2 = "0.0.1";
    var scripts$2 = {
    	build: "concurrently 'npm:build:cjs' 'npm:build:es' 'npm:build:types'",
    	"build:cjs": "tsc -p tsconfig.cjs.json",
    	"build:docs": "typedoc",
    	"build:es": "tsc -p tsconfig.es.json",
    	"build:types": "tsc -p tsconfig.types.json",
    	"build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    	clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    	prepack: "npm run clean && npm run build"
    };
    var main$2 = "./dist-cjs/index.js";
    var types$2 = "./dist-types/index.d.ts";
    var module$2 = "./dist-es/index.js";
    var sideEffects$2 = false;
    var dependencies$2 = {
    	tslib: "^2.5.0",
    	"@aws-crypto/sha256-browser": "3.0.0",
    	"@aws-crypto/sha256-js": "3.0.0",
    	"@aws-sdk/client-sts": "3.441.0",
    	"@aws-sdk/core": "3.441.0",
    	"@aws-sdk/credential-provider-node": "3.441.0",
    	"@aws-sdk/middleware-host-header": "3.433.0",
    	"@aws-sdk/middleware-logger": "3.433.0",
    	"@aws-sdk/middleware-recursion-detection": "3.433.0",
    	"@aws-sdk/middleware-signing": "3.433.0",
    	"@aws-sdk/middleware-user-agent": "3.438.0",
    	"@aws-sdk/region-config-resolver": "3.433.0",
    	"@aws-sdk/types": "3.433.0",
    	"@aws-sdk/util-user-agent-browser": "3.433.0",
    	"@aws-sdk/util-user-agent-node": "3.437.0",
    	"@smithy/config-resolver": "^2.0.16",
    	"@smithy/fetch-http-handler": "^2.2.4",
    	"@smithy/hash-node": "^2.0.12",
    	"@smithy/invalid-dependency": "^2.0.12",
    	"@smithy/middleware-content-length": "^2.0.14",
    	"@smithy/middleware-retry": "^2.0.18",
    	"@smithy/middleware-serde": "^2.0.12",
    	"@smithy/middleware-stack": "^2.0.6",
    	"@smithy/node-config-provider": "^2.1.3",
    	"@smithy/node-http-handler": "^2.1.8",
    	"@smithy/protocol-http": "^3.0.8",
    	"@smithy/smithy-client": "^2.1.12",
    	"@smithy/types": "^2.4.0",
    	"@smithy/url-parser": "^2.0.12",
    	"@smithy/util-base64": "^2.0.0",
    	"@smithy/util-body-length-browser": "^2.0.0",
    	"@smithy/util-body-length-node": "^2.1.0",
    	"@smithy/util-defaults-mode-browser": "^2.0.16",
    	"@smithy/util-defaults-mode-node": "^2.0.21",
    	"@smithy/util-retry": "^2.0.5",
    	"@smithy/util-utf8": "^2.0.0"
    };
    var devDependencies$2 = {
    	"@tsconfig/node14": "1.0.3",
    	concurrently: "7.0.0",
    	"downlevel-dts": "0.10.1",
    	rimraf: "^3.0.0",
    	typedoc: "0.23.23",
    	typescript: "~4.9.5",
    	"@smithy/service-client-documentation-generator": "^2.0.0",
    	"@types/node": "^14.14.31"
    };
    var engines$2 = {
    	node: ">=14.0.0"
    };
    var typesVersions$2 = {
    	"<4.0": {
    		"dist-types/*": [
    			"dist-types/ts3.4/*"
    		]
    	}
    };
    var files$2 = [
    	"dist-*/**"
    ];
    var browser$2 = {
    	"./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
    };
    var packageInfo$2 = {
    	name: name$2,
    	description: description$2,
    	version: version$2,
    	scripts: scripts$2,
    	main: main$2,
    	types: types$2,
    	module: module$2,
    	sideEffects: sideEffects$2,
    	dependencies: dependencies$2,
    	devDependencies: devDependencies$2,
    	engines: engines$2,
    	typesVersions: typesVersions$2,
    	files: files$2,
    	browser: browser$2,
    	"react-native": {
    	"./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
    }
    };

    var build$3 = {};

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics$2 = function(d, b) {
        extendStatics$2 = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics$2(d, b);
    };

    function __extends$2(d, b) {
        extendStatics$2(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign$2 = function() {
        __assign$2 = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign$2.apply(this, arguments);
    };

    function __rest$2(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate$2(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param$2(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata$2(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter$2(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator$2(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __createBinding$2(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }

    function __exportStar$2(m, exports) {
        for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values$2(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read$2(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread$2() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read$2(arguments[i]));
        return ar;
    }

    function __spreadArrays$2() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __await$2(v) {
        return this instanceof __await$2 ? (this.v = v, this) : new __await$2(v);
    }

    function __asyncGenerator$2(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await$2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator$2(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await$2(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues$2(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values$2 === "function" ? __values$2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject$2(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    }
    function __importStar$2(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault$2(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    function __classPrivateFieldGet$2(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }

    function __classPrivateFieldSet$2(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    var tslib_es6$2 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        get __assign () { return __assign$2; },
        __asyncDelegator: __asyncDelegator$2,
        __asyncGenerator: __asyncGenerator$2,
        __asyncValues: __asyncValues$2,
        __await: __await$2,
        __awaiter: __awaiter$2,
        __classPrivateFieldGet: __classPrivateFieldGet$2,
        __classPrivateFieldSet: __classPrivateFieldSet$2,
        __createBinding: __createBinding$2,
        __decorate: __decorate$2,
        __exportStar: __exportStar$2,
        __extends: __extends$2,
        __generator: __generator$2,
        __importDefault: __importDefault$2,
        __importStar: __importStar$2,
        __makeTemplateObject: __makeTemplateObject$2,
        __metadata: __metadata$2,
        __param: __param$2,
        __read: __read$2,
        __rest: __rest$2,
        __spread: __spread$2,
        __spreadArrays: __spreadArrays$2,
        __values: __values$2
    });

    var require$$0$2 = /*@__PURE__*/getAugmentedNamespace(tslib_es6$2);

    var crossPlatformSha256 = {};

    var ie11Sha256 = {};

    var isEmptyData$1 = {};

    var hasRequiredIsEmptyData$1;

    function requireIsEmptyData$1 () {
    	if (hasRequiredIsEmptyData$1) return isEmptyData$1;
    	hasRequiredIsEmptyData$1 = 1;
    	Object.defineProperty(isEmptyData$1, "__esModule", { value: true });
    	isEmptyData$1.isEmptyData = void 0;
    	function isEmptyData(data) {
    	    if (typeof data === "string") {
    	        return data.length === 0;
    	    }
    	    return data.byteLength === 0;
    	}
    	isEmptyData$1.isEmptyData = isEmptyData;
    	
    	return isEmptyData$1;
    }

    var constants$1 = {};

    var hasRequiredConstants$1;

    function requireConstants$1 () {
    	if (hasRequiredConstants$1) return constants$1;
    	hasRequiredConstants$1 = 1;
    	(function (exports) {
    		Object.defineProperty(exports, "__esModule", { value: true });
    		exports.EMPTY_DATA_SHA_256 = exports.SHA_256_HMAC_ALGO = exports.SHA_256_HASH = void 0;
    		exports.SHA_256_HASH = { name: "SHA-256" };
    		exports.SHA_256_HMAC_ALGO = {
    		    name: "HMAC",
    		    hash: exports.SHA_256_HASH
    		};
    		exports.EMPTY_DATA_SHA_256 = new Uint8Array([
    		    227,
    		    176,
    		    196,
    		    66,
    		    152,
    		    252,
    		    28,
    		    20,
    		    154,
    		    251,
    		    244,
    		    200,
    		    153,
    		    111,
    		    185,
    		    36,
    		    39,
    		    174,
    		    65,
    		    228,
    		    100,
    		    155,
    		    147,
    		    76,
    		    164,
    		    149,
    		    153,
    		    27,
    		    120,
    		    82,
    		    184,
    		    85
    		]);
    		
    	} (constants$1));
    	return constants$1;
    }

    var hasRequiredIe11Sha256;

    function requireIe11Sha256 () {
    	if (hasRequiredIe11Sha256) return ie11Sha256;
    	hasRequiredIe11Sha256 = 1;
    	Object.defineProperty(ie11Sha256, "__esModule", { value: true });
    	ie11Sha256.Sha256 = void 0;
    	var isEmptyData_1 = requireIsEmptyData$1();
    	var constants_1 = requireConstants$1();
    	var util_utf8_browser_1 = require$$0$9;
    	var util_locate_window_1 = require$$5;
    	var Sha256 = /** @class */ (function () {
    	    function Sha256(secret) {
    	        this.secret = secret;
    	        this.reset();
    	    }
    	    Sha256.prototype.update = function (toHash) {
    	        var _this = this;
    	        if ((0, isEmptyData_1.isEmptyData)(toHash)) {
    	            return;
    	        }
    	        this.operation = this.operation.then(function (operation) {
    	            operation.onerror = function () {
    	                _this.operation = Promise.reject(new Error("Error encountered updating hash"));
    	            };
    	            operation.process(toArrayBufferView(toHash));
    	            return operation;
    	        });
    	        this.operation.catch(function () { });
    	    };
    	    Sha256.prototype.digest = function () {
    	        return this.operation.then(function (operation) {
    	            return new Promise(function (resolve, reject) {
    	                operation.onerror = function () {
    	                    reject(new Error("Error encountered finalizing hash"));
    	                };
    	                operation.oncomplete = function () {
    	                    if (operation.result) {
    	                        resolve(new Uint8Array(operation.result));
    	                    }
    	                    reject(new Error("Error encountered finalizing hash"));
    	                };
    	                operation.finish();
    	            });
    	        });
    	    };
    	    Sha256.prototype.reset = function () {
    	        if (this.secret) {
    	            this.operation = getKeyPromise(this.secret).then(function (keyData) {
    	                return (0, util_locate_window_1.locateWindow)().msCrypto.subtle.sign(constants_1.SHA_256_HMAC_ALGO, keyData);
    	            });
    	            this.operation.catch(function () { });
    	        }
    	        else {
    	            this.operation = Promise.resolve((0, util_locate_window_1.locateWindow)().msCrypto.subtle.digest("SHA-256"));
    	        }
    	    };
    	    return Sha256;
    	}());
    	ie11Sha256.Sha256 = Sha256;
    	function getKeyPromise(secret) {
    	    return new Promise(function (resolve, reject) {
    	        var keyOperation = (0, util_locate_window_1.locateWindow)().msCrypto.subtle.importKey("raw", toArrayBufferView(secret), constants_1.SHA_256_HMAC_ALGO, false, ["sign"]);
    	        keyOperation.oncomplete = function () {
    	            if (keyOperation.result) {
    	                resolve(keyOperation.result);
    	            }
    	            reject(new Error("ImportKey completed without importing key."));
    	        };
    	        keyOperation.onerror = function () {
    	            reject(new Error("ImportKey failed to import key."));
    	        };
    	    });
    	}
    	function toArrayBufferView(data) {
    	    if (typeof data === "string") {
    	        return (0, util_utf8_browser_1.fromUtf8)(data);
    	    }
    	    if (ArrayBuffer.isView(data)) {
    	        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    	    }
    	    return new Uint8Array(data);
    	}
    	
    	return ie11Sha256;
    }

    var webCryptoSha256 = {};

    var build$2 = {};

    var convertToBuffer = {};

    var hasRequiredConvertToBuffer;

    function requireConvertToBuffer () {
    	if (hasRequiredConvertToBuffer) return convertToBuffer;
    	hasRequiredConvertToBuffer = 1;
    	// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
    	// SPDX-License-Identifier: Apache-2.0
    	Object.defineProperty(convertToBuffer, "__esModule", { value: true });
    	convertToBuffer.convertToBuffer = void 0;
    	var util_utf8_browser_1 = require$$0$9;
    	// Quick polyfill
    	var fromUtf8 = typeof Buffer !== "undefined" && Buffer.from
    	    ? function (input) { return Buffer.from(input, "utf8"); }
    	    : util_utf8_browser_1.fromUtf8;
    	function convertToBuffer$1(data) {
    	    // Already a Uint8, do nothing
    	    if (data instanceof Uint8Array)
    	        return data;
    	    if (typeof data === "string") {
    	        return fromUtf8(data);
    	    }
    	    if (ArrayBuffer.isView(data)) {
    	        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    	    }
    	    return new Uint8Array(data);
    	}
    	convertToBuffer.convertToBuffer = convertToBuffer$1;
    	
    	return convertToBuffer;
    }

    var isEmptyData = {};

    var hasRequiredIsEmptyData;

    function requireIsEmptyData () {
    	if (hasRequiredIsEmptyData) return isEmptyData;
    	hasRequiredIsEmptyData = 1;
    	// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
    	// SPDX-License-Identifier: Apache-2.0
    	Object.defineProperty(isEmptyData, "__esModule", { value: true });
    	isEmptyData.isEmptyData = void 0;
    	function isEmptyData$1(data) {
    	    if (typeof data === "string") {
    	        return data.length === 0;
    	    }
    	    return data.byteLength === 0;
    	}
    	isEmptyData.isEmptyData = isEmptyData$1;
    	
    	return isEmptyData;
    }

    var numToUint8 = {};

    var hasRequiredNumToUint8;

    function requireNumToUint8 () {
    	if (hasRequiredNumToUint8) return numToUint8;
    	hasRequiredNumToUint8 = 1;
    	// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
    	// SPDX-License-Identifier: Apache-2.0
    	Object.defineProperty(numToUint8, "__esModule", { value: true });
    	numToUint8.numToUint8 = void 0;
    	function numToUint8$1(num) {
    	    return new Uint8Array([
    	        (num & 0xff000000) >> 24,
    	        (num & 0x00ff0000) >> 16,
    	        (num & 0x0000ff00) >> 8,
    	        num & 0x000000ff,
    	    ]);
    	}
    	numToUint8.numToUint8 = numToUint8$1;
    	
    	return numToUint8;
    }

    var uint32ArrayFrom = {};

    var hasRequiredUint32ArrayFrom;

    function requireUint32ArrayFrom () {
    	if (hasRequiredUint32ArrayFrom) return uint32ArrayFrom;
    	hasRequiredUint32ArrayFrom = 1;
    	// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
    	// SPDX-License-Identifier: Apache-2.0
    	Object.defineProperty(uint32ArrayFrom, "__esModule", { value: true });
    	uint32ArrayFrom.uint32ArrayFrom = void 0;
    	// IE 11 does not support Array.from, so we do it manually
    	function uint32ArrayFrom$1(a_lookUpTable) {
    	    if (!Uint32Array.from) {
    	        var return_array = new Uint32Array(a_lookUpTable.length);
    	        var a_index = 0;
    	        while (a_index < a_lookUpTable.length) {
    	            return_array[a_index] = a_lookUpTable[a_index];
    	            a_index += 1;
    	        }
    	        return return_array;
    	    }
    	    return Uint32Array.from(a_lookUpTable);
    	}
    	uint32ArrayFrom.uint32ArrayFrom = uint32ArrayFrom$1;
    	
    	return uint32ArrayFrom;
    }

    var hasRequiredBuild$3;

    function requireBuild$3 () {
    	if (hasRequiredBuild$3) return build$2;
    	hasRequiredBuild$3 = 1;
    	(function (exports) {
    		// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
    		// SPDX-License-Identifier: Apache-2.0
    		Object.defineProperty(exports, "__esModule", { value: true });
    		exports.uint32ArrayFrom = exports.numToUint8 = exports.isEmptyData = exports.convertToBuffer = void 0;
    		var convertToBuffer_1 = requireConvertToBuffer();
    		Object.defineProperty(exports, "convertToBuffer", { enumerable: true, get: function () { return convertToBuffer_1.convertToBuffer; } });
    		var isEmptyData_1 = requireIsEmptyData();
    		Object.defineProperty(exports, "isEmptyData", { enumerable: true, get: function () { return isEmptyData_1.isEmptyData; } });
    		var numToUint8_1 = requireNumToUint8();
    		Object.defineProperty(exports, "numToUint8", { enumerable: true, get: function () { return numToUint8_1.numToUint8; } });
    		var uint32ArrayFrom_1 = requireUint32ArrayFrom();
    		Object.defineProperty(exports, "uint32ArrayFrom", { enumerable: true, get: function () { return uint32ArrayFrom_1.uint32ArrayFrom; } });
    		
    	} (build$2));
    	return build$2;
    }

    var hasRequiredWebCryptoSha256;

    function requireWebCryptoSha256 () {
    	if (hasRequiredWebCryptoSha256) return webCryptoSha256;
    	hasRequiredWebCryptoSha256 = 1;
    	Object.defineProperty(webCryptoSha256, "__esModule", { value: true });
    	webCryptoSha256.Sha256 = void 0;
    	var util_1 = requireBuild$3();
    	var constants_1 = requireConstants$1();
    	var util_locate_window_1 = require$$5;
    	var Sha256 = /** @class */ (function () {
    	    function Sha256(secret) {
    	        this.toHash = new Uint8Array(0);
    	        this.secret = secret;
    	        this.reset();
    	    }
    	    Sha256.prototype.update = function (data) {
    	        if ((0, util_1.isEmptyData)(data)) {
    	            return;
    	        }
    	        var update = (0, util_1.convertToBuffer)(data);
    	        var typedArray = new Uint8Array(this.toHash.byteLength + update.byteLength);
    	        typedArray.set(this.toHash, 0);
    	        typedArray.set(update, this.toHash.byteLength);
    	        this.toHash = typedArray;
    	    };
    	    Sha256.prototype.digest = function () {
    	        var _this = this;
    	        if (this.key) {
    	            return this.key.then(function (key) {
    	                return (0, util_locate_window_1.locateWindow)()
    	                    .crypto.subtle.sign(constants_1.SHA_256_HMAC_ALGO, key, _this.toHash)
    	                    .then(function (data) { return new Uint8Array(data); });
    	            });
    	        }
    	        if ((0, util_1.isEmptyData)(this.toHash)) {
    	            return Promise.resolve(constants_1.EMPTY_DATA_SHA_256);
    	        }
    	        return Promise.resolve()
    	            .then(function () {
    	            return (0, util_locate_window_1.locateWindow)().crypto.subtle.digest(constants_1.SHA_256_HASH, _this.toHash);
    	        })
    	            .then(function (data) { return Promise.resolve(new Uint8Array(data)); });
    	    };
    	    Sha256.prototype.reset = function () {
    	        var _this = this;
    	        this.toHash = new Uint8Array(0);
    	        if (this.secret && this.secret !== void 0) {
    	            this.key = new Promise(function (resolve, reject) {
    	                (0, util_locate_window_1.locateWindow)()
    	                    .crypto.subtle.importKey("raw", (0, util_1.convertToBuffer)(_this.secret), constants_1.SHA_256_HMAC_ALGO, false, ["sign"])
    	                    .then(resolve, reject);
    	            });
    	            this.key.catch(function () { });
    	        }
    	    };
    	    return Sha256;
    	}());
    	webCryptoSha256.Sha256 = Sha256;
    	
    	return webCryptoSha256;
    }

    var build$1 = {};

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics$1 = function(d, b) {
        extendStatics$1 = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics$1(d, b);
    };

    function __extends$1(d, b) {
        extendStatics$1(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign$1 = function() {
        __assign$1 = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign$1.apply(this, arguments);
    };

    function __rest$1(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate$1(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param$1(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata$1(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter$1(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator$1(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __createBinding$1(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }

    function __exportStar$1(m, exports) {
        for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values$1(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read$1(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread$1() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read$1(arguments[i]));
        return ar;
    }

    function __spreadArrays$1() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __await$1(v) {
        return this instanceof __await$1 ? (this.v = v, this) : new __await$1(v);
    }

    function __asyncGenerator$1(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await$1 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator$1(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await$1(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues$1(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values$1 === "function" ? __values$1(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject$1(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    }
    function __importStar$1(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault$1(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    function __classPrivateFieldGet$1(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }

    function __classPrivateFieldSet$1(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    var tslib_es6$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        get __assign () { return __assign$1; },
        __asyncDelegator: __asyncDelegator$1,
        __asyncGenerator: __asyncGenerator$1,
        __asyncValues: __asyncValues$1,
        __await: __await$1,
        __awaiter: __awaiter$1,
        __classPrivateFieldGet: __classPrivateFieldGet$1,
        __classPrivateFieldSet: __classPrivateFieldSet$1,
        __createBinding: __createBinding$1,
        __decorate: __decorate$1,
        __exportStar: __exportStar$1,
        __extends: __extends$1,
        __generator: __generator$1,
        __importDefault: __importDefault$1,
        __importStar: __importStar$1,
        __makeTemplateObject: __makeTemplateObject$1,
        __metadata: __metadata$1,
        __param: __param$1,
        __read: __read$1,
        __rest: __rest$1,
        __spread: __spread$1,
        __spreadArrays: __spreadArrays$1,
        __values: __values$1
    });

    var require$$0$1 = /*@__PURE__*/getAugmentedNamespace(tslib_es6$1);

    var jsSha256 = {};

    var constants = {};

    var hasRequiredConstants;

    function requireConstants () {
    	if (hasRequiredConstants) return constants;
    	hasRequiredConstants = 1;
    	Object.defineProperty(constants, "__esModule", { value: true });
    	constants.MAX_HASHABLE_LENGTH = constants.INIT = constants.KEY = constants.DIGEST_LENGTH = constants.BLOCK_SIZE = void 0;
    	/**
    	 * @internal
    	 */
    	constants.BLOCK_SIZE = 64;
    	/**
    	 * @internal
    	 */
    	constants.DIGEST_LENGTH = 32;
    	/**
    	 * @internal
    	 */
    	constants.KEY = new Uint32Array([
    	    0x428a2f98,
    	    0x71374491,
    	    0xb5c0fbcf,
    	    0xe9b5dba5,
    	    0x3956c25b,
    	    0x59f111f1,
    	    0x923f82a4,
    	    0xab1c5ed5,
    	    0xd807aa98,
    	    0x12835b01,
    	    0x243185be,
    	    0x550c7dc3,
    	    0x72be5d74,
    	    0x80deb1fe,
    	    0x9bdc06a7,
    	    0xc19bf174,
    	    0xe49b69c1,
    	    0xefbe4786,
    	    0x0fc19dc6,
    	    0x240ca1cc,
    	    0x2de92c6f,
    	    0x4a7484aa,
    	    0x5cb0a9dc,
    	    0x76f988da,
    	    0x983e5152,
    	    0xa831c66d,
    	    0xb00327c8,
    	    0xbf597fc7,
    	    0xc6e00bf3,
    	    0xd5a79147,
    	    0x06ca6351,
    	    0x14292967,
    	    0x27b70a85,
    	    0x2e1b2138,
    	    0x4d2c6dfc,
    	    0x53380d13,
    	    0x650a7354,
    	    0x766a0abb,
    	    0x81c2c92e,
    	    0x92722c85,
    	    0xa2bfe8a1,
    	    0xa81a664b,
    	    0xc24b8b70,
    	    0xc76c51a3,
    	    0xd192e819,
    	    0xd6990624,
    	    0xf40e3585,
    	    0x106aa070,
    	    0x19a4c116,
    	    0x1e376c08,
    	    0x2748774c,
    	    0x34b0bcb5,
    	    0x391c0cb3,
    	    0x4ed8aa4a,
    	    0x5b9cca4f,
    	    0x682e6ff3,
    	    0x748f82ee,
    	    0x78a5636f,
    	    0x84c87814,
    	    0x8cc70208,
    	    0x90befffa,
    	    0xa4506ceb,
    	    0xbef9a3f7,
    	    0xc67178f2
    	]);
    	/**
    	 * @internal
    	 */
    	constants.INIT = [
    	    0x6a09e667,
    	    0xbb67ae85,
    	    0x3c6ef372,
    	    0xa54ff53a,
    	    0x510e527f,
    	    0x9b05688c,
    	    0x1f83d9ab,
    	    0x5be0cd19
    	];
    	/**
    	 * @internal
    	 */
    	constants.MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;
    	
    	return constants;
    }

    var RawSha256 = {};

    var hasRequiredRawSha256;

    function requireRawSha256 () {
    	if (hasRequiredRawSha256) return RawSha256;
    	hasRequiredRawSha256 = 1;
    	Object.defineProperty(RawSha256, "__esModule", { value: true });
    	RawSha256.RawSha256 = void 0;
    	var constants_1 = requireConstants();
    	/**
    	 * @internal
    	 */
    	var RawSha256$1 = /** @class */ (function () {
    	    function RawSha256() {
    	        this.state = Int32Array.from(constants_1.INIT);
    	        this.temp = new Int32Array(64);
    	        this.buffer = new Uint8Array(64);
    	        this.bufferLength = 0;
    	        this.bytesHashed = 0;
    	        /**
    	         * @internal
    	         */
    	        this.finished = false;
    	    }
    	    RawSha256.prototype.update = function (data) {
    	        if (this.finished) {
    	            throw new Error("Attempted to update an already finished hash.");
    	        }
    	        var position = 0;
    	        var byteLength = data.byteLength;
    	        this.bytesHashed += byteLength;
    	        if (this.bytesHashed * 8 > constants_1.MAX_HASHABLE_LENGTH) {
    	            throw new Error("Cannot hash more than 2^53 - 1 bits");
    	        }
    	        while (byteLength > 0) {
    	            this.buffer[this.bufferLength++] = data[position++];
    	            byteLength--;
    	            if (this.bufferLength === constants_1.BLOCK_SIZE) {
    	                this.hashBuffer();
    	                this.bufferLength = 0;
    	            }
    	        }
    	    };
    	    RawSha256.prototype.digest = function () {
    	        if (!this.finished) {
    	            var bitsHashed = this.bytesHashed * 8;
    	            var bufferView = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);
    	            var undecoratedLength = this.bufferLength;
    	            bufferView.setUint8(this.bufferLength++, 0x80);
    	            // Ensure the final block has enough room for the hashed length
    	            if (undecoratedLength % constants_1.BLOCK_SIZE >= constants_1.BLOCK_SIZE - 8) {
    	                for (var i = this.bufferLength; i < constants_1.BLOCK_SIZE; i++) {
    	                    bufferView.setUint8(i, 0);
    	                }
    	                this.hashBuffer();
    	                this.bufferLength = 0;
    	            }
    	            for (var i = this.bufferLength; i < constants_1.BLOCK_SIZE - 8; i++) {
    	                bufferView.setUint8(i, 0);
    	            }
    	            bufferView.setUint32(constants_1.BLOCK_SIZE - 8, Math.floor(bitsHashed / 0x100000000), true);
    	            bufferView.setUint32(constants_1.BLOCK_SIZE - 4, bitsHashed);
    	            this.hashBuffer();
    	            this.finished = true;
    	        }
    	        // The value in state is little-endian rather than big-endian, so flip
    	        // each word into a new Uint8Array
    	        var out = new Uint8Array(constants_1.DIGEST_LENGTH);
    	        for (var i = 0; i < 8; i++) {
    	            out[i * 4] = (this.state[i] >>> 24) & 0xff;
    	            out[i * 4 + 1] = (this.state[i] >>> 16) & 0xff;
    	            out[i * 4 + 2] = (this.state[i] >>> 8) & 0xff;
    	            out[i * 4 + 3] = (this.state[i] >>> 0) & 0xff;
    	        }
    	        return out;
    	    };
    	    RawSha256.prototype.hashBuffer = function () {
    	        var _a = this, buffer = _a.buffer, state = _a.state;
    	        var state0 = state[0], state1 = state[1], state2 = state[2], state3 = state[3], state4 = state[4], state5 = state[5], state6 = state[6], state7 = state[7];
    	        for (var i = 0; i < constants_1.BLOCK_SIZE; i++) {
    	            if (i < 16) {
    	                this.temp[i] =
    	                    ((buffer[i * 4] & 0xff) << 24) |
    	                        ((buffer[i * 4 + 1] & 0xff) << 16) |
    	                        ((buffer[i * 4 + 2] & 0xff) << 8) |
    	                        (buffer[i * 4 + 3] & 0xff);
    	            }
    	            else {
    	                var u = this.temp[i - 2];
    	                var t1_1 = ((u >>> 17) | (u << 15)) ^ ((u >>> 19) | (u << 13)) ^ (u >>> 10);
    	                u = this.temp[i - 15];
    	                var t2_1 = ((u >>> 7) | (u << 25)) ^ ((u >>> 18) | (u << 14)) ^ (u >>> 3);
    	                this.temp[i] =
    	                    ((t1_1 + this.temp[i - 7]) | 0) + ((t2_1 + this.temp[i - 16]) | 0);
    	            }
    	            var t1 = ((((((state4 >>> 6) | (state4 << 26)) ^
    	                ((state4 >>> 11) | (state4 << 21)) ^
    	                ((state4 >>> 25) | (state4 << 7))) +
    	                ((state4 & state5) ^ (~state4 & state6))) |
    	                0) +
    	                ((state7 + ((constants_1.KEY[i] + this.temp[i]) | 0)) | 0)) |
    	                0;
    	            var t2 = ((((state0 >>> 2) | (state0 << 30)) ^
    	                ((state0 >>> 13) | (state0 << 19)) ^
    	                ((state0 >>> 22) | (state0 << 10))) +
    	                ((state0 & state1) ^ (state0 & state2) ^ (state1 & state2))) |
    	                0;
    	            state7 = state6;
    	            state6 = state5;
    	            state5 = state4;
    	            state4 = (state3 + t1) | 0;
    	            state3 = state2;
    	            state2 = state1;
    	            state1 = state0;
    	            state0 = (t1 + t2) | 0;
    	        }
    	        state[0] += state0;
    	        state[1] += state1;
    	        state[2] += state2;
    	        state[3] += state3;
    	        state[4] += state4;
    	        state[5] += state5;
    	        state[6] += state6;
    	        state[7] += state7;
    	    };
    	    return RawSha256;
    	}());
    	RawSha256.RawSha256 = RawSha256$1;
    	
    	return RawSha256;
    }

    var hasRequiredJsSha256;

    function requireJsSha256 () {
    	if (hasRequiredJsSha256) return jsSha256;
    	hasRequiredJsSha256 = 1;
    	Object.defineProperty(jsSha256, "__esModule", { value: true });
    	jsSha256.Sha256 = void 0;
    	var tslib_1 = require$$0$1;
    	var constants_1 = requireConstants();
    	var RawSha256_1 = requireRawSha256();
    	var util_1 = requireBuild$3();
    	var Sha256 = /** @class */ (function () {
    	    function Sha256(secret) {
    	        this.secret = secret;
    	        this.hash = new RawSha256_1.RawSha256();
    	        this.reset();
    	    }
    	    Sha256.prototype.update = function (toHash) {
    	        if ((0, util_1.isEmptyData)(toHash) || this.error) {
    	            return;
    	        }
    	        try {
    	            this.hash.update((0, util_1.convertToBuffer)(toHash));
    	        }
    	        catch (e) {
    	            this.error = e;
    	        }
    	    };
    	    /* This synchronous method keeps compatibility
    	     * with the v2 aws-sdk.
    	     */
    	    Sha256.prototype.digestSync = function () {
    	        if (this.error) {
    	            throw this.error;
    	        }
    	        if (this.outer) {
    	            if (!this.outer.finished) {
    	                this.outer.update(this.hash.digest());
    	            }
    	            return this.outer.digest();
    	        }
    	        return this.hash.digest();
    	    };
    	    /* The underlying digest method here is synchronous.
    	     * To keep the same interface with the other hash functions
    	     * the default is to expose this as an async method.
    	     * However, it can sometimes be useful to have a sync method.
    	     */
    	    Sha256.prototype.digest = function () {
    	        return tslib_1.__awaiter(this, void 0, void 0, function () {
    	            return tslib_1.__generator(this, function (_a) {
    	                return [2 /*return*/, this.digestSync()];
    	            });
    	        });
    	    };
    	    Sha256.prototype.reset = function () {
    	        this.hash = new RawSha256_1.RawSha256();
    	        if (this.secret) {
    	            this.outer = new RawSha256_1.RawSha256();
    	            var inner = bufferFromSecret(this.secret);
    	            var outer = new Uint8Array(constants_1.BLOCK_SIZE);
    	            outer.set(inner);
    	            for (var i = 0; i < constants_1.BLOCK_SIZE; i++) {
    	                inner[i] ^= 0x36;
    	                outer[i] ^= 0x5c;
    	            }
    	            this.hash.update(inner);
    	            this.outer.update(outer);
    	            // overwrite the copied key in memory
    	            for (var i = 0; i < inner.byteLength; i++) {
    	                inner[i] = 0;
    	            }
    	        }
    	    };
    	    return Sha256;
    	}());
    	jsSha256.Sha256 = Sha256;
    	function bufferFromSecret(secret) {
    	    var input = (0, util_1.convertToBuffer)(secret);
    	    if (input.byteLength > constants_1.BLOCK_SIZE) {
    	        var bufferHash = new RawSha256_1.RawSha256();
    	        bufferHash.update(input);
    	        input = bufferHash.digest();
    	    }
    	    var buffer = new Uint8Array(constants_1.BLOCK_SIZE);
    	    buffer.set(input);
    	    return buffer;
    	}
    	
    	return jsSha256;
    }

    var hasRequiredBuild$2;

    function requireBuild$2 () {
    	if (hasRequiredBuild$2) return build$1;
    	hasRequiredBuild$2 = 1;
    	(function (exports) {
    		Object.defineProperty(exports, "__esModule", { value: true });
    		var tslib_1 = require$$0$1;
    		tslib_1.__exportStar(requireJsSha256(), exports);
    		
    	} (build$1));
    	return build$1;
    }

    var build = {};

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __createBinding(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }

    function __exportStar(m, exports) {
        for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    }
    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }

    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    var tslib_es6 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        get __assign () { return __assign; },
        __asyncDelegator: __asyncDelegator,
        __asyncGenerator: __asyncGenerator,
        __asyncValues: __asyncValues,
        __await: __await,
        __awaiter: __awaiter,
        __classPrivateFieldGet: __classPrivateFieldGet,
        __classPrivateFieldSet: __classPrivateFieldSet,
        __createBinding: __createBinding,
        __decorate: __decorate,
        __exportStar: __exportStar,
        __extends: __extends,
        __generator: __generator,
        __importDefault: __importDefault,
        __importStar: __importStar,
        __makeTemplateObject: __makeTemplateObject,
        __metadata: __metadata,
        __param: __param,
        __read: __read,
        __rest: __rest,
        __spread: __spread,
        __spreadArrays: __spreadArrays,
        __values: __values
    });

    var require$$0 = /*@__PURE__*/getAugmentedNamespace(tslib_es6);

    var supportsWebCrypto = {};

    var hasRequiredSupportsWebCrypto;

    function requireSupportsWebCrypto () {
    	if (hasRequiredSupportsWebCrypto) return supportsWebCrypto;
    	hasRequiredSupportsWebCrypto = 1;
    	Object.defineProperty(supportsWebCrypto, "__esModule", { value: true });
    	supportsWebCrypto.supportsZeroByteGCM = supportsWebCrypto.supportsSubtleCrypto = supportsWebCrypto.supportsSecureRandom = supportsWebCrypto.supportsWebCrypto = void 0;
    	var tslib_1 = require$$0;
    	var subtleCryptoMethods = [
    	    "decrypt",
    	    "digest",
    	    "encrypt",
    	    "exportKey",
    	    "generateKey",
    	    "importKey",
    	    "sign",
    	    "verify"
    	];
    	function supportsWebCrypto$1(window) {
    	    if (supportsSecureRandom(window) &&
    	        typeof window.crypto.subtle === "object") {
    	        var subtle = window.crypto.subtle;
    	        return supportsSubtleCrypto(subtle);
    	    }
    	    return false;
    	}
    	supportsWebCrypto.supportsWebCrypto = supportsWebCrypto$1;
    	function supportsSecureRandom(window) {
    	    if (typeof window === "object" && typeof window.crypto === "object") {
    	        var getRandomValues = window.crypto.getRandomValues;
    	        return typeof getRandomValues === "function";
    	    }
    	    return false;
    	}
    	supportsWebCrypto.supportsSecureRandom = supportsSecureRandom;
    	function supportsSubtleCrypto(subtle) {
    	    return (subtle &&
    	        subtleCryptoMethods.every(function (methodName) { return typeof subtle[methodName] === "function"; }));
    	}
    	supportsWebCrypto.supportsSubtleCrypto = supportsSubtleCrypto;
    	function supportsZeroByteGCM(subtle) {
    	    return tslib_1.__awaiter(this, void 0, void 0, function () {
    	        var key, zeroByteAuthTag;
    	        return tslib_1.__generator(this, function (_b) {
    	            switch (_b.label) {
    	                case 0:
    	                    if (!supportsSubtleCrypto(subtle))
    	                        return [2 /*return*/, false];
    	                    _b.label = 1;
    	                case 1:
    	                    _b.trys.push([1, 4, , 5]);
    	                    return [4 /*yield*/, subtle.generateKey({ name: "AES-GCM", length: 128 }, false, ["encrypt"])];
    	                case 2:
    	                    key = _b.sent();
    	                    return [4 /*yield*/, subtle.encrypt({
    	                            name: "AES-GCM",
    	                            iv: new Uint8Array(Array(12)),
    	                            additionalData: new Uint8Array(Array(16)),
    	                            tagLength: 128
    	                        }, key, new Uint8Array(0))];
    	                case 3:
    	                    zeroByteAuthTag = _b.sent();
    	                    return [2 /*return*/, zeroByteAuthTag.byteLength === 16];
    	                case 4:
    	                    _b.sent();
    	                    return [2 /*return*/, false];
    	                case 5: return [2 /*return*/];
    	            }
    	        });
    	    });
    	}
    	supportsWebCrypto.supportsZeroByteGCM = supportsZeroByteGCM;
    	
    	return supportsWebCrypto;
    }

    var hasRequiredBuild$1;

    function requireBuild$1 () {
    	if (hasRequiredBuild$1) return build;
    	hasRequiredBuild$1 = 1;
    	(function (exports) {
    		Object.defineProperty(exports, "__esModule", { value: true });
    		var tslib_1 = require$$0;
    		tslib_1.__exportStar(requireSupportsWebCrypto(), exports);
    		
    	} (build));
    	return build;
    }

    var hasRequiredCrossPlatformSha256;

    function requireCrossPlatformSha256 () {
    	if (hasRequiredCrossPlatformSha256) return crossPlatformSha256;
    	hasRequiredCrossPlatformSha256 = 1;
    	Object.defineProperty(crossPlatformSha256, "__esModule", { value: true });
    	crossPlatformSha256.Sha256 = void 0;
    	var ie11Sha256_1 = requireIe11Sha256();
    	var webCryptoSha256_1 = requireWebCryptoSha256();
    	var sha256_js_1 = requireBuild$2();
    	var supports_web_crypto_1 = requireBuild$1();
    	var ie11_detection_1 = requireBuild$9();
    	var util_locate_window_1 = require$$5;
    	var util_1 = requireBuild$3();
    	var Sha256 = /** @class */ (function () {
    	    function Sha256(secret) {
    	        if ((0, supports_web_crypto_1.supportsWebCrypto)((0, util_locate_window_1.locateWindow)())) {
    	            this.hash = new webCryptoSha256_1.Sha256(secret);
    	        }
    	        else if ((0, ie11_detection_1.isMsWindow)((0, util_locate_window_1.locateWindow)())) {
    	            this.hash = new ie11Sha256_1.Sha256(secret);
    	        }
    	        else {
    	            this.hash = new sha256_js_1.Sha256(secret);
    	        }
    	    }
    	    Sha256.prototype.update = function (data, encoding) {
    	        this.hash.update((0, util_1.convertToBuffer)(data));
    	    };
    	    Sha256.prototype.digest = function () {
    	        return this.hash.digest();
    	    };
    	    Sha256.prototype.reset = function () {
    	        this.hash.reset();
    	    };
    	    return Sha256;
    	}());
    	crossPlatformSha256.Sha256 = Sha256;
    	
    	return crossPlatformSha256;
    }

    var hasRequiredBuild;

    function requireBuild () {
    	if (hasRequiredBuild) return build$3;
    	hasRequiredBuild = 1;
    	(function (exports) {
    		Object.defineProperty(exports, "__esModule", { value: true });
    		exports.WebCryptoSha256 = exports.Ie11Sha256 = void 0;
    		var tslib_1 = require$$0$2;
    		tslib_1.__exportStar(requireCrossPlatformSha256(), exports);
    		var ie11Sha256_1 = requireIe11Sha256();
    		Object.defineProperty(exports, "Ie11Sha256", { enumerable: true, get: function () { return ie11Sha256_1.Sha256; } });
    		var webCryptoSha256_1 = requireWebCryptoSha256();
    		Object.defineProperty(exports, "WebCryptoSha256", { enumerable: true, get: function () { return webCryptoSha256_1.Sha256; } });
    		
    	} (build$3));
    	return build$3;
    }

    var buildExports = requireBuild();

    const defaultUserAgent = ({ serviceId, clientVersion }) => async () => {
        const parsedUA = typeof window !== "undefined" && window?.navigator?.userAgent
            ? bowser.parse(window.navigator.userAgent)
            : undefined;
        const sections = [
            ["aws-sdk-js", clientVersion],
            ["ua", "2.0"],
            [`os/${parsedUA?.os?.name || "other"}`, parsedUA?.os?.version],
            ["lang/js"],
            ["md/browser", `${parsedUA?.browser?.name ?? "unknown"}_${parsedUA?.browser?.version ?? "unknown"}`],
        ];
        if (serviceId) {
            sections.push([`api/${serviceId}`, clientVersion]);
        }
        return sections;
    };

    var SelectorType;
    (function (SelectorType) {
        SelectorType["ENV"] = "env";
        SelectorType["CONFIG"] = "shared config entry";
    })(SelectorType || (SelectorType = {}));

    const DEFAULT_USE_DUALSTACK_ENDPOINT = false;

    const DEFAULT_USE_FIPS_ENDPOINT = false;

    var HttpAuthLocation;
    (function (HttpAuthLocation) {
        HttpAuthLocation["HEADER"] = "header";
        HttpAuthLocation["QUERY"] = "query";
    })(HttpAuthLocation || (HttpAuthLocation = {}));

    var HttpApiKeyAuthLocation;
    (function (HttpApiKeyAuthLocation) {
        HttpApiKeyAuthLocation["HEADER"] = "header";
        HttpApiKeyAuthLocation["QUERY"] = "query";
    })(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));

    var EndpointURLScheme;
    (function (EndpointURLScheme) {
        EndpointURLScheme["HTTP"] = "http";
        EndpointURLScheme["HTTPS"] = "https";
    })(EndpointURLScheme || (EndpointURLScheme = {}));

    var AlgorithmId;
    (function (AlgorithmId) {
        AlgorithmId["MD5"] = "md5";
        AlgorithmId["CRC32"] = "crc32";
        AlgorithmId["CRC32C"] = "crc32c";
        AlgorithmId["SHA1"] = "sha1";
        AlgorithmId["SHA256"] = "sha256";
    })(AlgorithmId || (AlgorithmId = {}));

    var FieldPosition;
    (function (FieldPosition) {
        FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
        FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
    })(FieldPosition || (FieldPosition = {}));

    const SMITHY_CONTEXT_KEY = "__smithy_context";

    var IniSectionType;
    (function (IniSectionType) {
        IniSectionType["PROFILE"] = "profile";
        IniSectionType["SSO_SESSION"] = "sso-session";
        IniSectionType["SERVICES"] = "services";
    })(IniSectionType || (IniSectionType = {}));

    var RequestHandlerProtocol;
    (function (RequestHandlerProtocol) {
        RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
        RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
        RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
    })(RequestHandlerProtocol || (RequestHandlerProtocol = {}));

    const normalizeProvider = (input) => {
        if (typeof input === "function")
            return input;
        const promisified = Promise.resolve(input);
        return () => promisified;
    };

    const getEndpointFromRegion = async (input) => {
        const { tls = true } = input;
        const region = await input.region();
        const dnsHostRegex = new RegExp(/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/);
        if (!dnsHostRegex.test(region)) {
            throw new Error("Invalid region in client config");
        }
        const useDualstackEndpoint = await input.useDualstackEndpoint();
        const useFipsEndpoint = await input.useFipsEndpoint();
        const { hostname } = (await input.regionInfoProvider(region, { useDualstackEndpoint, useFipsEndpoint })) ?? {};
        if (!hostname) {
            throw new Error("Cannot resolve hostname from client config");
        }
        return input.urlParser(`${tls ? "https:" : "http:"}//${hostname}`);
    };

    const resolveEndpointsConfig = (input) => {
        const useDualstackEndpoint = normalizeProvider(input.useDualstackEndpoint ?? false);
        const { endpoint, useFipsEndpoint, urlParser } = input;
        return {
            ...input,
            tls: input.tls ?? true,
            endpoint: endpoint
                ? normalizeProvider(typeof endpoint === "string" ? urlParser(endpoint) : endpoint)
                : () => getEndpointFromRegion({ ...input, useDualstackEndpoint, useFipsEndpoint }),
            isCustomEndpoint: !!endpoint,
            useDualstackEndpoint,
        };
    };

    const isFipsRegion = (region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));

    const getRealRegion = (region) => isFipsRegion(region)
        ? ["fips-aws-global", "aws-fips"].includes(region)
            ? "us-east-1"
            : region.replace(/fips-(dkr-|prod-)?|-fips/, "")
        : region;

    const resolveRegionConfig = (input) => {
        const { region, useFipsEndpoint } = input;
        if (!region) {
            throw new Error("Region is missing");
        }
        return {
            ...input,
            region: async () => {
                if (typeof region === "string") {
                    return getRealRegion(region);
                }
                const providedRegion = await region();
                return getRealRegion(providedRegion);
            },
            useFipsEndpoint: async () => {
                const providedRegion = typeof region === "string" ? region : await region();
                if (isFipsRegion(providedRegion)) {
                    return true;
                }
                return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
            },
        };
    };

    const getHostnameFromVariants = (variants = [], { useFipsEndpoint, useDualstackEndpoint }) => variants.find(({ tags }) => useFipsEndpoint === tags.includes("fips") && useDualstackEndpoint === tags.includes("dualstack"))?.hostname;

    const getResolvedHostname = (resolvedRegion, { regionHostname, partitionHostname }) => regionHostname
        ? regionHostname
        : partitionHostname
            ? partitionHostname.replace("{region}", resolvedRegion)
            : undefined;

    const getResolvedPartition = (region, { partitionHash }) => Object.keys(partitionHash || {}).find((key) => partitionHash[key].regions.includes(region)) ?? "aws";

    const getResolvedSigningRegion = (hostname, { signingRegion, regionRegex, useFipsEndpoint }) => {
        if (signingRegion) {
            return signingRegion;
        }
        else if (useFipsEndpoint) {
            const regionRegexJs = regionRegex.replace("\\\\", "\\").replace(/^\^/g, "\\.").replace(/\$$/g, "\\.");
            const regionRegexmatchArray = hostname.match(regionRegexJs);
            if (regionRegexmatchArray) {
                return regionRegexmatchArray[0].slice(1, -1);
            }
        }
    };

    const getRegionInfo = (region, { useFipsEndpoint = false, useDualstackEndpoint = false, signingService, regionHash, partitionHash, }) => {
        const partition = getResolvedPartition(region, { partitionHash });
        const resolvedRegion = region in regionHash ? region : partitionHash[partition]?.endpoint ?? region;
        const hostnameOptions = { useFipsEndpoint, useDualstackEndpoint };
        const regionHostname = getHostnameFromVariants(regionHash[resolvedRegion]?.variants, hostnameOptions);
        const partitionHostname = getHostnameFromVariants(partitionHash[partition]?.variants, hostnameOptions);
        const hostname = getResolvedHostname(resolvedRegion, { regionHostname, partitionHostname });
        if (hostname === undefined) {
            throw new Error(`Endpoint resolution failed for: ${{ resolvedRegion, useFipsEndpoint, useDualstackEndpoint }}`);
        }
        const signingRegion = getResolvedSigningRegion(hostname, {
            signingRegion: regionHash[resolvedRegion]?.signingRegion,
            regionRegex: partitionHash[partition].regionRegex,
            useFipsEndpoint,
        });
        return {
            partition,
            signingService,
            hostname,
            ...(signingRegion && { signingRegion }),
            ...(regionHash[resolvedRegion]?.signingService && {
                signingService: regionHash[resolvedRegion].signingService,
            }),
        };
    };

    const getHttpHandlerExtensionConfiguration = (runtimeConfig) => {
        let httpHandler = runtimeConfig.httpHandler;
        return {
            setHttpHandler(handler) {
                httpHandler = handler;
            },
            httpHandler() {
                return httpHandler;
            },
            updateHttpClientConfig(key, value) {
                httpHandler.updateHttpClientConfig(key, value);
            },
            httpHandlerConfigs() {
                return httpHandler.httpHandlerConfigs();
            },
        };
    };
    const resolveHttpHandlerRuntimeConfig = (httpHandlerExtensionConfiguration) => {
        return {
            httpHandler: httpHandlerExtensionConfiguration.httpHandler(),
        };
    };

    class HttpRequest {
        constructor(options) {
            this.method = options.method || "GET";
            this.hostname = options.hostname || "localhost";
            this.port = options.port;
            this.query = options.query || {};
            this.headers = options.headers || {};
            this.body = options.body;
            this.protocol = options.protocol
                ? options.protocol.slice(-1) !== ":"
                    ? `${options.protocol}:`
                    : options.protocol
                : "https:";
            this.path = options.path ? (options.path.charAt(0) !== "/" ? `/${options.path}` : options.path) : "/";
            this.username = options.username;
            this.password = options.password;
            this.fragment = options.fragment;
        }
        static isInstance(request) {
            if (!request)
                return false;
            const req = request;
            return ("method" in req &&
                "protocol" in req &&
                "hostname" in req &&
                "path" in req &&
                typeof req["query"] === "object" &&
                typeof req["headers"] === "object");
        }
        clone() {
            const cloned = new HttpRequest({
                ...this,
                headers: { ...this.headers },
            });
            if (cloned.query)
                cloned.query = cloneQuery(cloned.query);
            return cloned;
        }
    }
    function cloneQuery(query) {
        return Object.keys(query).reduce((carry, paramName) => {
            const param = query[paramName];
            return {
                ...carry,
                [paramName]: Array.isArray(param) ? [...param] : param,
            };
        }, {});
    }

    class HttpResponse {
        constructor(options) {
            this.statusCode = options.statusCode;
            this.reason = options.reason;
            this.headers = options.headers || {};
            this.body = options.body;
        }
        static isInstance(response) {
            if (!response)
                return false;
            const resp = response;
            return typeof resp.statusCode === "number" && typeof resp.headers === "object";
        }
    }

    const escapeUri = (uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode);
    const hexEncode = (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`;

    function buildQueryString(query) {
        const parts = [];
        for (let key of Object.keys(query).sort()) {
            const value = query[key];
            key = escapeUri(key);
            if (Array.isArray(value)) {
                for (let i = 0, iLen = value.length; i < iLen; i++) {
                    parts.push(`${key}=${escapeUri(value[i])}`);
                }
            }
            else {
                let qsEntry = key;
                if (value || typeof value === "string") {
                    qsEntry += `=${escapeUri(value)}`;
                }
                parts.push(qsEntry);
            }
        }
        return parts.join("&");
    }

    function requestTimeout(timeoutInMs = 0) {
        return new Promise((resolve, reject) => {
            if (timeoutInMs) {
                setTimeout(() => {
                    const timeoutError = new Error(`Request did not complete within ${timeoutInMs} ms`);
                    timeoutError.name = "TimeoutError";
                    reject(timeoutError);
                }, timeoutInMs);
            }
        });
    }

    const keepAliveSupport = {
        supported: Boolean(typeof Request !== "undefined" && "keepalive" in new Request("https://[::1]")),
    };
    class FetchHttpHandler {
        static create(instanceOrOptions) {
            if (typeof instanceOrOptions?.handle === "function") {
                return instanceOrOptions;
            }
            return new FetchHttpHandler(instanceOrOptions);
        }
        constructor(options) {
            if (typeof options === "function") {
                this.configProvider = options().then((opts) => opts || {});
            }
            else {
                this.config = options ?? {};
                this.configProvider = Promise.resolve(this.config);
            }
        }
        destroy() {
        }
        async handle(request, { abortSignal } = {}) {
            if (!this.config) {
                this.config = await this.configProvider;
            }
            const requestTimeoutInMs = this.config.requestTimeout;
            const keepAlive = this.config.keepAlive === true;
            if (abortSignal?.aborted) {
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                return Promise.reject(abortError);
            }
            let path = request.path;
            const queryString = buildQueryString(request.query || {});
            if (queryString) {
                path += `?${queryString}`;
            }
            if (request.fragment) {
                path += `#${request.fragment}`;
            }
            let auth = "";
            if (request.username != null || request.password != null) {
                const username = request.username ?? "";
                const password = request.password ?? "";
                auth = `${username}:${password}@`;
            }
            const { port, method } = request;
            const url = `${request.protocol}//${auth}${request.hostname}${port ? `:${port}` : ""}${path}`;
            const body = method === "GET" || method === "HEAD" ? undefined : request.body;
            const requestOptions = { body, headers: new Headers(request.headers), method: method };
            if (typeof AbortController !== "undefined") {
                requestOptions["signal"] = abortSignal;
            }
            if (keepAliveSupport.supported) {
                requestOptions["keepalive"] = keepAlive;
            }
            const fetchRequest = new Request(url, requestOptions);
            const raceOfPromises = [
                fetch(fetchRequest).then((response) => {
                    const fetchHeaders = response.headers;
                    const transformedHeaders = {};
                    for (const pair of fetchHeaders.entries()) {
                        transformedHeaders[pair[0]] = pair[1];
                    }
                    const hasReadableStream = response.body != undefined;
                    if (!hasReadableStream) {
                        return response.blob().then((body) => ({
                            response: new HttpResponse({
                                headers: transformedHeaders,
                                reason: response.statusText,
                                statusCode: response.status,
                                body,
                            }),
                        }));
                    }
                    return {
                        response: new HttpResponse({
                            headers: transformedHeaders,
                            reason: response.statusText,
                            statusCode: response.status,
                            body: response.body,
                        }),
                    };
                }),
                requestTimeout(requestTimeoutInMs),
            ];
            if (abortSignal) {
                raceOfPromises.push(new Promise((resolve, reject) => {
                    abortSignal.onabort = () => {
                        const abortError = new Error("Request aborted");
                        abortError.name = "AbortError";
                        reject(abortError);
                    };
                }));
            }
            return Promise.race(raceOfPromises);
        }
        updateHttpClientConfig(key, value) {
            this.config = undefined;
            this.configProvider = this.configProvider.then((config) => {
                config[key] = value;
                return config;
            });
        }
        httpHandlerConfigs() {
            return this.config ?? {};
        }
    }

    const alphabetByEncoding = {};
    const alphabetByValue = new Array(64);
    for (let i = 0, start = "A".charCodeAt(0), limit = "Z".charCodeAt(0); i + start <= limit; i++) {
        const char = String.fromCharCode(i + start);
        alphabetByEncoding[char] = i;
        alphabetByValue[i] = char;
    }
    for (let i = 0, start = "a".charCodeAt(0), limit = "z".charCodeAt(0); i + start <= limit; i++) {
        const char = String.fromCharCode(i + start);
        const index = i + 26;
        alphabetByEncoding[char] = index;
        alphabetByValue[index] = char;
    }
    for (let i = 0; i < 10; i++) {
        alphabetByEncoding[i.toString(10)] = i + 52;
        const char = i.toString(10);
        const index = i + 52;
        alphabetByEncoding[char] = index;
        alphabetByValue[index] = char;
    }
    alphabetByEncoding["+"] = 62;
    alphabetByValue[62] = "+";
    alphabetByEncoding["/"] = 63;
    alphabetByValue[63] = "/";
    const bitsPerLetter = 6;
    const bitsPerByte = 8;
    const maxLetterValue = 0b111111;

    const fromBase64 = (input) => {
        let totalByteLength = (input.length / 4) * 3;
        if (input.slice(-2) === "==") {
            totalByteLength -= 2;
        }
        else if (input.slice(-1) === "=") {
            totalByteLength--;
        }
        const out = new ArrayBuffer(totalByteLength);
        const dataView = new DataView(out);
        for (let i = 0; i < input.length; i += 4) {
            let bits = 0;
            let bitLength = 0;
            for (let j = i, limit = i + 3; j <= limit; j++) {
                if (input[j] !== "=") {
                    if (!(input[j] in alphabetByEncoding)) {
                        throw new TypeError(`Invalid character ${input[j]} in base64 string.`);
                    }
                    bits |= alphabetByEncoding[input[j]] << ((limit - j) * bitsPerLetter);
                    bitLength += bitsPerLetter;
                }
                else {
                    bits >>= bitsPerLetter;
                }
            }
            const chunkOffset = (i / 4) * 3;
            bits >>= bitLength % bitsPerByte;
            const byteLength = Math.floor(bitLength / bitsPerByte);
            for (let k = 0; k < byteLength; k++) {
                const offset = (byteLength - k - 1) * bitsPerByte;
                dataView.setUint8(chunkOffset + k, (bits & (255 << offset)) >> offset);
            }
        }
        return new Uint8Array(out);
    };

    const fromUtf8 = (input) => new TextEncoder().encode(input);

    const toUtf8 = (input) => {
        if (typeof input === "string") {
            return input;
        }
        if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
            throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
        }
        return new TextDecoder("utf-8").decode(input);
    };

    function toBase64(_input) {
        let input;
        if (typeof _input === "string") {
            input = fromUtf8(_input);
        }
        else {
            input = _input;
        }
        const isArrayLike = typeof input === "object" && typeof input.length === "number";
        const isUint8Array = typeof input === "object" &&
            typeof input.byteOffset === "number" &&
            typeof input.byteLength === "number";
        if (!isArrayLike && !isUint8Array) {
            throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
        }
        let str = "";
        for (let i = 0; i < input.length; i += 3) {
            let bits = 0;
            let bitLength = 0;
            for (let j = i, limit = Math.min(i + 3, input.length); j < limit; j++) {
                bits |= input[j] << ((limit - j - 1) * bitsPerByte);
                bitLength += bitsPerByte;
            }
            const bitClusterCount = Math.ceil(bitLength / bitsPerLetter);
            bits <<= bitClusterCount * bitsPerLetter - bitLength;
            for (let k = 1; k <= bitClusterCount; k++) {
                const offset = (bitClusterCount - k) * bitsPerLetter;
                str += alphabetByValue[(bits & (maxLetterValue << offset)) >> offset];
            }
            str += "==".slice(0, 4 - bitClusterCount);
        }
        return str;
    }

    const streamCollector = (stream) => {
        if (typeof Blob === "function" && stream instanceof Blob) {
            return collectBlob(stream);
        }
        return collectStream(stream);
    };
    async function collectBlob(blob) {
        const base64 = await readToBase64(blob);
        const arrayBuffer = fromBase64(base64);
        return new Uint8Array(arrayBuffer);
    }
    async function collectStream(stream) {
        let res = new Uint8Array(0);
        const reader = stream.getReader();
        let isDone = false;
        while (!isDone) {
            const { done, value } = await reader.read();
            if (value) {
                const prior = res;
                res = new Uint8Array(prior.length + value.length);
                res.set(prior);
                res.set(value, prior.length);
            }
            isDone = done;
        }
        return res;
    }
    function readToBase64(blob) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => {
                if (reader.readyState !== 2) {
                    return reject(new Error("Reader aborted too early"));
                }
                const result = (reader.result ?? "");
                const commaIndex = result.indexOf(",");
                const dataOffset = commaIndex > -1 ? commaIndex + 1 : result.length;
                resolve(result.substring(dataOffset));
            };
            reader.onabort = () => reject(new Error("Read aborted"));
            reader.onerror = () => reject(reader.error);
            reader.readAsDataURL(blob);
        });
    }

    const invalidProvider = (message) => () => Promise.reject(message);

    const TEXT_ENCODER = typeof TextEncoder == "function" ? new TextEncoder() : null;
    const calculateBodyLength = (body) => {
        if (typeof body === "string") {
            if (TEXT_ENCODER) {
                return TEXT_ENCODER.encode(body).byteLength;
            }
            let len = body.length;
            for (let i = len - 1; i >= 0; i--) {
                const code = body.charCodeAt(i);
                if (code > 0x7f && code <= 0x7ff)
                    len++;
                else if (code > 0x7ff && code <= 0xffff)
                    len += 2;
                if (code >= 0xdc00 && code <= 0xdfff)
                    i--;
            }
            return len;
        }
        else if (typeof body.byteLength === "number") {
            return body.byteLength;
        }
        else if (typeof body.size === "number") {
            return body.size;
        }
        throw new Error(`Body Length computation failed for ${body}`);
    };

    var RETRY_MODES;
    (function (RETRY_MODES) {
        RETRY_MODES["STANDARD"] = "standard";
        RETRY_MODES["ADAPTIVE"] = "adaptive";
    })(RETRY_MODES || (RETRY_MODES = {}));
    const DEFAULT_MAX_ATTEMPTS = 3;
    const DEFAULT_RETRY_MODE = RETRY_MODES.STANDARD;

    const THROTTLING_ERROR_CODES = [
        "BandwidthLimitExceeded",
        "EC2ThrottledException",
        "LimitExceededException",
        "PriorRequestNotComplete",
        "ProvisionedThroughputExceededException",
        "RequestLimitExceeded",
        "RequestThrottled",
        "RequestThrottledException",
        "SlowDown",
        "ThrottledException",
        "Throttling",
        "ThrottlingException",
        "TooManyRequestsException",
        "TransactionInProgressException",
    ];
    const TRANSIENT_ERROR_CODES = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"];
    const TRANSIENT_ERROR_STATUS_CODES = [500, 502, 503, 504];
    const NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"];

    const isClockSkewCorrectedError = (error) => error.$metadata?.clockSkewCorrected;
    const isThrottlingError = (error) => error.$metadata?.httpStatusCode === 429 ||
        THROTTLING_ERROR_CODES.includes(error.name) ||
        error.$retryable?.throttling == true;
    const isTransientError = (error) => isClockSkewCorrectedError(error) ||
        TRANSIENT_ERROR_CODES.includes(error.name) ||
        NODEJS_TIMEOUT_ERROR_CODES.includes(error?.code || "") ||
        TRANSIENT_ERROR_STATUS_CODES.includes(error.$metadata?.httpStatusCode || 0);
    const isServerError = (error) => {
        if (error.$metadata?.httpStatusCode !== undefined) {
            const statusCode = error.$metadata.httpStatusCode;
            if (500 <= statusCode && statusCode <= 599 && !isTransientError(error)) {
                return true;
            }
            return false;
        }
        return false;
    };

    class DefaultRateLimiter {
        constructor(options) {
            this.currentCapacity = 0;
            this.enabled = false;
            this.lastMaxRate = 0;
            this.measuredTxRate = 0;
            this.requestCount = 0;
            this.lastTimestamp = 0;
            this.timeWindow = 0;
            this.beta = options?.beta ?? 0.7;
            this.minCapacity = options?.minCapacity ?? 1;
            this.minFillRate = options?.minFillRate ?? 0.5;
            this.scaleConstant = options?.scaleConstant ?? 0.4;
            this.smooth = options?.smooth ?? 0.8;
            const currentTimeInSeconds = this.getCurrentTimeInSeconds();
            this.lastThrottleTime = currentTimeInSeconds;
            this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());
            this.fillRate = this.minFillRate;
            this.maxCapacity = this.minCapacity;
        }
        getCurrentTimeInSeconds() {
            return Date.now() / 1000;
        }
        async getSendToken() {
            return this.acquireTokenBucket(1);
        }
        async acquireTokenBucket(amount) {
            if (!this.enabled) {
                return;
            }
            this.refillTokenBucket();
            if (amount > this.currentCapacity) {
                const delay = ((amount - this.currentCapacity) / this.fillRate) * 1000;
                await new Promise((resolve) => setTimeout(resolve, delay));
            }
            this.currentCapacity = this.currentCapacity - amount;
        }
        refillTokenBucket() {
            const timestamp = this.getCurrentTimeInSeconds();
            if (!this.lastTimestamp) {
                this.lastTimestamp = timestamp;
                return;
            }
            const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;
            this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);
            this.lastTimestamp = timestamp;
        }
        updateClientSendingRate(response) {
            let calculatedRate;
            this.updateMeasuredRate();
            if (isThrottlingError(response)) {
                const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);
                this.lastMaxRate = rateToUse;
                this.calculateTimeWindow();
                this.lastThrottleTime = this.getCurrentTimeInSeconds();
                calculatedRate = this.cubicThrottle(rateToUse);
                this.enableTokenBucket();
            }
            else {
                this.calculateTimeWindow();
                calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());
            }
            const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);
            this.updateTokenBucketRate(newRate);
        }
        calculateTimeWindow() {
            this.timeWindow = this.getPrecise(Math.pow((this.lastMaxRate * (1 - this.beta)) / this.scaleConstant, 1 / 3));
        }
        cubicThrottle(rateToUse) {
            return this.getPrecise(rateToUse * this.beta);
        }
        cubicSuccess(timestamp) {
            return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
        }
        enableTokenBucket() {
            this.enabled = true;
        }
        updateTokenBucketRate(newRate) {
            this.refillTokenBucket();
            this.fillRate = Math.max(newRate, this.minFillRate);
            this.maxCapacity = Math.max(newRate, this.minCapacity);
            this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
        }
        updateMeasuredRate() {
            const t = this.getCurrentTimeInSeconds();
            const timeBucket = Math.floor(t * 2) / 2;
            this.requestCount++;
            if (timeBucket > this.lastTxRateBucket) {
                const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);
                this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));
                this.requestCount = 0;
                this.lastTxRateBucket = timeBucket;
            }
        }
        getPrecise(num) {
            return parseFloat(num.toFixed(8));
        }
    }

    const DEFAULT_RETRY_DELAY_BASE = 100;
    const MAXIMUM_RETRY_DELAY = 20 * 1000;
    const THROTTLING_RETRY_DELAY_BASE = 500;
    const INITIAL_RETRY_TOKENS = 500;
    const RETRY_COST = 5;
    const TIMEOUT_RETRY_COST = 10;
    const NO_RETRY_INCREMENT = 1;
    const INVOCATION_ID_HEADER = "amz-sdk-invocation-id";
    const REQUEST_HEADER = "amz-sdk-request";

    const getDefaultRetryBackoffStrategy = () => {
        let delayBase = DEFAULT_RETRY_DELAY_BASE;
        const computeNextBackoffDelay = (attempts) => {
            return Math.floor(Math.min(MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
        };
        const setDelayBase = (delay) => {
            delayBase = delay;
        };
        return {
            computeNextBackoffDelay,
            setDelayBase,
        };
    };

    const createDefaultRetryToken = ({ retryDelay, retryCount, retryCost, }) => {
        const getRetryCount = () => retryCount;
        const getRetryDelay = () => Math.min(MAXIMUM_RETRY_DELAY, retryDelay);
        const getRetryCost = () => retryCost;
        return {
            getRetryCount,
            getRetryDelay,
            getRetryCost,
        };
    };

    class StandardRetryStrategy {
        constructor(maxAttempts) {
            this.maxAttempts = maxAttempts;
            this.mode = RETRY_MODES.STANDARD;
            this.capacity = INITIAL_RETRY_TOKENS;
            this.retryBackoffStrategy = getDefaultRetryBackoffStrategy();
            this.maxAttemptsProvider = typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts;
        }
        async acquireInitialRetryToken(retryTokenScope) {
            return createDefaultRetryToken({
                retryDelay: DEFAULT_RETRY_DELAY_BASE,
                retryCount: 0,
            });
        }
        async refreshRetryTokenForRetry(token, errorInfo) {
            const maxAttempts = await this.getMaxAttempts();
            if (this.shouldRetry(token, errorInfo, maxAttempts)) {
                const errorType = errorInfo.errorType;
                this.retryBackoffStrategy.setDelayBase(errorType === "THROTTLING" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE);
                const delayFromErrorType = this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());
                const retryDelay = errorInfo.retryAfterHint
                    ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType)
                    : delayFromErrorType;
                const capacityCost = this.getCapacityCost(errorType);
                this.capacity -= capacityCost;
                return createDefaultRetryToken({
                    retryDelay,
                    retryCount: token.getRetryCount() + 1,
                    retryCost: capacityCost,
                });
            }
            throw new Error("No retry token available");
        }
        recordSuccess(token) {
            this.capacity = Math.max(INITIAL_RETRY_TOKENS, this.capacity + (token.getRetryCost() ?? NO_RETRY_INCREMENT));
        }
        getCapacity() {
            return this.capacity;
        }
        async getMaxAttempts() {
            try {
                return await this.maxAttemptsProvider();
            }
            catch (error) {
                console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`);
                return DEFAULT_MAX_ATTEMPTS;
            }
        }
        shouldRetry(tokenToRenew, errorInfo, maxAttempts) {
            const attempts = tokenToRenew.getRetryCount() + 1;
            return (attempts < maxAttempts &&
                this.capacity >= this.getCapacityCost(errorInfo.errorType) &&
                this.isRetryableError(errorInfo.errorType));
        }
        getCapacityCost(errorType) {
            return errorType === "TRANSIENT" ? TIMEOUT_RETRY_COST : RETRY_COST;
        }
        isRetryableError(errorType) {
            return errorType === "THROTTLING" || errorType === "TRANSIENT";
        }
    }

    class AdaptiveRetryStrategy {
        constructor(maxAttemptsProvider, options) {
            this.maxAttemptsProvider = maxAttemptsProvider;
            this.mode = RETRY_MODES.ADAPTIVE;
            const { rateLimiter } = options ?? {};
            this.rateLimiter = rateLimiter ?? new DefaultRateLimiter();
            this.standardRetryStrategy = new StandardRetryStrategy(maxAttemptsProvider);
        }
        async acquireInitialRetryToken(retryTokenScope) {
            await this.rateLimiter.getSendToken();
            return this.standardRetryStrategy.acquireInitialRetryToken(retryTokenScope);
        }
        async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
            this.rateLimiter.updateClientSendingRate(errorInfo);
            return this.standardRetryStrategy.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
        }
        recordSuccess(token) {
            this.rateLimiter.updateClientSendingRate({});
            this.standardRetryStrategy.recordSuccess(token);
        }
    }

    const regionHash = {};
    const partitionHash = {
        "aws": {
            regions: [
                "af-south-1",
                "ap-east-1",
                "ap-northeast-1",
                "ap-northeast-2",
                "ap-northeast-3",
                "ap-south-1",
                "ap-south-2",
                "ap-southeast-1",
                "ap-southeast-2",
                "ap-southeast-3",
                "ap-southeast-4",
                "ca-central-1",
                "eu-central-1",
                "eu-central-2",
                "eu-north-1",
                "eu-south-1",
                "eu-south-2",
                "eu-west-1",
                "eu-west-2",
                "eu-west-3",
                "il-central-1",
                "me-central-1",
                "me-south-1",
                "sa-east-1",
                "us-east-1",
                "us-east-2",
                "us-west-1",
                "us-west-2",
            ],
            regionRegex: "^(us|eu|ap|sa|ca|me|af|il)\\-\\w+\\-\\d+$",
            variants: [
                {
                    "hostname": "geo-routes.{region}.amazonaws.com",
                    "tags": []
                },
                {
                    "hostname": "geo-routes-fips.{region}.amazonaws.com",
                    "tags": [
                        "fips"
                    ]
                },
                {
                    "hostname": "geo-routes-fips.{region}.api.aws",
                    "tags": [
                        "dualstack",
                        "fips"
                    ]
                },
                {
                    "hostname": "geo-routes.{region}.api.aws",
                    "tags": [
                        "dualstack"
                    ]
                }
            ],
        },
        "aws-cn": {
            regions: [
                "cn-north-1",
                "cn-northwest-1",
            ],
            regionRegex: "^cn\\-\\w+\\-\\d+$",
            variants: [
                {
                    "hostname": "geo-routes.{region}.amazonaws.com.cn",
                    "tags": []
                },
                {
                    "hostname": "geo-routes-fips.{region}.amazonaws.com.cn",
                    "tags": [
                        "fips"
                    ]
                },
                {
                    "hostname": "geo-routes-fips.{region}.api.amazonwebservices.com.cn",
                    "tags": [
                        "dualstack",
                        "fips"
                    ]
                },
                {
                    "hostname": "geo-routes.{region}.api.amazonwebservices.com.cn",
                    "tags": [
                        "dualstack"
                    ]
                }
            ],
        },
        "aws-iso": {
            regions: [
                "us-iso-east-1",
                "us-iso-west-1",
            ],
            regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
            variants: [
                {
                    "hostname": "geo-routes.{region}.c2s.ic.gov",
                    "tags": []
                },
                {
                    "hostname": "geo-routes-fips.{region}.c2s.ic.gov",
                    "tags": [
                        "fips"
                    ]
                }
            ],
        },
        "aws-iso-b": {
            regions: [
                "us-isob-east-1",
            ],
            regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
            variants: [
                {
                    "hostname": "geo-routes.{region}.sc2s.sgov.gov",
                    "tags": []
                },
                {
                    "hostname": "geo-routes-fips.{region}.sc2s.sgov.gov",
                    "tags": [
                        "fips"
                    ]
                }
            ],
        },
        "aws-iso-e": {
            regions: [],
            regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
            variants: [
                {
                    "hostname": "geo-routes.{region}.cloud.adc-e.uk",
                    "tags": []
                },
                {
                    "hostname": "geo-routes-fips.{region}.cloud.adc-e.uk",
                    "tags": [
                        "fips"
                    ]
                }
            ],
        },
        "aws-iso-f": {
            regions: [],
            regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
            variants: [
                {
                    "hostname": "geo-routes.{region}.csp.hci.ic.gov",
                    "tags": []
                },
                {
                    "hostname": "geo-routes-fips.{region}.csp.hci.ic.gov",
                    "tags": [
                        "fips"
                    ]
                }
            ],
        },
        "aws-us-gov": {
            regions: [
                "us-gov-east-1",
                "us-gov-west-1",
            ],
            regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
            variants: [
                {
                    "hostname": "geo-routes.{region}.amazonaws.com",
                    "tags": []
                },
                {
                    "hostname": "geo-routes-fips.{region}.amazonaws.com",
                    "tags": [
                        "fips"
                    ]
                },
                {
                    "hostname": "geo-routes-fips.{region}.api.aws",
                    "tags": [
                        "dualstack",
                        "fips"
                    ]
                },
                {
                    "hostname": "geo-routes.{region}.api.aws",
                    "tags": [
                        "dualstack"
                    ]
                }
            ],
        },
    };
    const defaultRegionInfoProvider = async (region, options) => getRegionInfo(region, {
        ...options,
        signingService: "geo-routes",
        regionHash,
        partitionHash,
    });

    class NoOpLogger {
        trace() { }
        debug() { }
        info() { }
        warn() { }
        error() { }
    }

    const getAllAliases = (name, aliases) => {
        const _aliases = [];
        if (name) {
            _aliases.push(name);
        }
        if (aliases) {
            for (const alias of aliases) {
                _aliases.push(alias);
            }
        }
        return _aliases;
    };
    const getMiddlewareNameWithAliases = (name, aliases) => {
        return `${name || "anonymous"}${aliases && aliases.length > 0 ? ` (a.k.a. ${aliases.join(",")})` : ""}`;
    };
    const constructStack = () => {
        let absoluteEntries = [];
        let relativeEntries = [];
        let identifyOnResolve = false;
        const entriesNameSet = new Set();
        const sort = (entries) => entries.sort((a, b) => stepWeights[b.step] - stepWeights[a.step] ||
            priorityWeights[b.priority || "normal"] - priorityWeights[a.priority || "normal"]);
        const removeByName = (toRemove) => {
            let isRemoved = false;
            const filterCb = (entry) => {
                const aliases = getAllAliases(entry.name, entry.aliases);
                if (aliases.includes(toRemove)) {
                    isRemoved = true;
                    for (const alias of aliases) {
                        entriesNameSet.delete(alias);
                    }
                    return false;
                }
                return true;
            };
            absoluteEntries = absoluteEntries.filter(filterCb);
            relativeEntries = relativeEntries.filter(filterCb);
            return isRemoved;
        };
        const removeByReference = (toRemove) => {
            let isRemoved = false;
            const filterCb = (entry) => {
                if (entry.middleware === toRemove) {
                    isRemoved = true;
                    for (const alias of getAllAliases(entry.name, entry.aliases)) {
                        entriesNameSet.delete(alias);
                    }
                    return false;
                }
                return true;
            };
            absoluteEntries = absoluteEntries.filter(filterCb);
            relativeEntries = relativeEntries.filter(filterCb);
            return isRemoved;
        };
        const cloneTo = (toStack) => {
            absoluteEntries.forEach((entry) => {
                toStack.add(entry.middleware, { ...entry });
            });
            relativeEntries.forEach((entry) => {
                toStack.addRelativeTo(entry.middleware, { ...entry });
            });
            toStack.identifyOnResolve?.(stack.identifyOnResolve());
            return toStack;
        };
        const expandRelativeMiddlewareList = (from) => {
            const expandedMiddlewareList = [];
            from.before.forEach((entry) => {
                if (entry.before.length === 0 && entry.after.length === 0) {
                    expandedMiddlewareList.push(entry);
                }
                else {
                    expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
                }
            });
            expandedMiddlewareList.push(from);
            from.after.reverse().forEach((entry) => {
                if (entry.before.length === 0 && entry.after.length === 0) {
                    expandedMiddlewareList.push(entry);
                }
                else {
                    expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
                }
            });
            return expandedMiddlewareList;
        };
        const getMiddlewareList = (debug = false) => {
            const normalizedAbsoluteEntries = [];
            const normalizedRelativeEntries = [];
            const normalizedEntriesNameMap = {};
            absoluteEntries.forEach((entry) => {
                const normalizedEntry = {
                    ...entry,
                    before: [],
                    after: [],
                };
                for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
                    normalizedEntriesNameMap[alias] = normalizedEntry;
                }
                normalizedAbsoluteEntries.push(normalizedEntry);
            });
            relativeEntries.forEach((entry) => {
                const normalizedEntry = {
                    ...entry,
                    before: [],
                    after: [],
                };
                for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
                    normalizedEntriesNameMap[alias] = normalizedEntry;
                }
                normalizedRelativeEntries.push(normalizedEntry);
            });
            normalizedRelativeEntries.forEach((entry) => {
                if (entry.toMiddleware) {
                    const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
                    if (toMiddleware === undefined) {
                        if (debug) {
                            return;
                        }
                        throw new Error(`${entry.toMiddleware} is not found when adding ` +
                            `${getMiddlewareNameWithAliases(entry.name, entry.aliases)} ` +
                            `middleware ${entry.relation} ${entry.toMiddleware}`);
                    }
                    if (entry.relation === "after") {
                        toMiddleware.after.push(entry);
                    }
                    if (entry.relation === "before") {
                        toMiddleware.before.push(entry);
                    }
                }
            });
            const mainChain = sort(normalizedAbsoluteEntries)
                .map(expandRelativeMiddlewareList)
                .reduce((wholeList, expandedMiddlewareList) => {
                wholeList.push(...expandedMiddlewareList);
                return wholeList;
            }, []);
            return mainChain;
        };
        const stack = {
            add: (middleware, options = {}) => {
                const { name, override, aliases: _aliases } = options;
                const entry = {
                    step: "initialize",
                    priority: "normal",
                    middleware,
                    ...options,
                };
                const aliases = getAllAliases(name, _aliases);
                if (aliases.length > 0) {
                    if (aliases.some((alias) => entriesNameSet.has(alias))) {
                        if (!override)
                            throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
                        for (const alias of aliases) {
                            const toOverrideIndex = absoluteEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));
                            if (toOverrideIndex === -1) {
                                continue;
                            }
                            const toOverride = absoluteEntries[toOverrideIndex];
                            if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {
                                throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware with ` +
                                    `${toOverride.priority} priority in ${toOverride.step} step cannot ` +
                                    `be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware with ` +
                                    `${entry.priority} priority in ${entry.step} step.`);
                            }
                            absoluteEntries.splice(toOverrideIndex, 1);
                        }
                    }
                    for (const alias of aliases) {
                        entriesNameSet.add(alias);
                    }
                }
                absoluteEntries.push(entry);
            },
            addRelativeTo: (middleware, options) => {
                const { name, override, aliases: _aliases } = options;
                const entry = {
                    middleware,
                    ...options,
                };
                const aliases = getAllAliases(name, _aliases);
                if (aliases.length > 0) {
                    if (aliases.some((alias) => entriesNameSet.has(alias))) {
                        if (!override)
                            throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
                        for (const alias of aliases) {
                            const toOverrideIndex = relativeEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));
                            if (toOverrideIndex === -1) {
                                continue;
                            }
                            const toOverride = relativeEntries[toOverrideIndex];
                            if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
                                throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware ` +
                                    `${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden ` +
                                    `by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware ${entry.relation} ` +
                                    `"${entry.toMiddleware}" middleware.`);
                            }
                            relativeEntries.splice(toOverrideIndex, 1);
                        }
                    }
                    for (const alias of aliases) {
                        entriesNameSet.add(alias);
                    }
                }
                relativeEntries.push(entry);
            },
            clone: () => cloneTo(constructStack()),
            use: (plugin) => {
                plugin.applyToStack(stack);
            },
            remove: (toRemove) => {
                if (typeof toRemove === "string")
                    return removeByName(toRemove);
                else
                    return removeByReference(toRemove);
            },
            removeByTag: (toRemove) => {
                let isRemoved = false;
                const filterCb = (entry) => {
                    const { tags, name, aliases: _aliases } = entry;
                    if (tags && tags.includes(toRemove)) {
                        const aliases = getAllAliases(name, _aliases);
                        for (const alias of aliases) {
                            entriesNameSet.delete(alias);
                        }
                        isRemoved = true;
                        return false;
                    }
                    return true;
                };
                absoluteEntries = absoluteEntries.filter(filterCb);
                relativeEntries = relativeEntries.filter(filterCb);
                return isRemoved;
            },
            concat: (from) => {
                const cloned = cloneTo(constructStack());
                cloned.use(from);
                cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || (from.identifyOnResolve?.() ?? false));
                return cloned;
            },
            applyToStack: cloneTo,
            identify: () => {
                return getMiddlewareList(true).map((mw) => {
                    const step = mw.step ??
                        mw.relation +
                            " " +
                            mw.toMiddleware;
                    return getMiddlewareNameWithAliases(mw.name, mw.aliases) + " - " + step;
                });
            },
            identifyOnResolve(toggle) {
                if (typeof toggle === "boolean")
                    identifyOnResolve = toggle;
                return identifyOnResolve;
            },
            resolve: (handler, context) => {
                for (const middleware of getMiddlewareList()
                    .map((entry) => entry.middleware)
                    .reverse()) {
                    handler = middleware(handler, context);
                }
                if (identifyOnResolve) {
                    console.log(stack.identify());
                }
                return handler;
            },
        };
        return stack;
    };
    const stepWeights = {
        initialize: 5,
        serialize: 4,
        build: 3,
        finalizeRequest: 2,
        deserialize: 1,
    };
    const priorityWeights = {
        high: 3,
        normal: 2,
        low: 1,
    };

    class Client {
        constructor(config) {
            this.middlewareStack = constructStack();
            this.config = config;
        }
        send(command, optionsOrCb, cb) {
            const options = typeof optionsOrCb !== "function" ? optionsOrCb : undefined;
            const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
            const handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
            if (callback) {
                handler(command)
                    .then((result) => callback(null, result.output), (err) => callback(err))
                    .catch(() => { });
            }
            else {
                return handler(command).then((result) => result.output);
            }
        }
        destroy() {
            if (this.config.requestHandler.destroy)
                this.config.requestHandler.destroy();
        }
    }

    function transformToString(payload, encoding = "utf-8") {
        if (encoding === "base64") {
            return toBase64(payload);
        }
        return toUtf8(payload);
    }
    function transformFromString(str, encoding) {
        if (encoding === "base64") {
            return Uint8ArrayBlobAdapter.mutate(fromBase64(str));
        }
        return Uint8ArrayBlobAdapter.mutate(fromUtf8(str));
    }

    class Uint8ArrayBlobAdapter extends Uint8Array {
        static fromString(source, encoding = "utf-8") {
            switch (typeof source) {
                case "string":
                    return transformFromString(source, encoding);
                default:
                    throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
            }
        }
        static mutate(source) {
            Object.setPrototypeOf(source, Uint8ArrayBlobAdapter.prototype);
            return source;
        }
        transformToString(encoding = "utf-8") {
            return transformToString(this, encoding);
        }
    }

    for (let i = 0; i < 256; i++) {
        let encodedByte = i.toString(16).toLowerCase();
        if (encodedByte.length === 1) {
            encodedByte = `0${encodedByte}`;
        }
    }

    const collectBody = async (streamBody = new Uint8Array(), context) => {
        if (streamBody instanceof Uint8Array) {
            return Uint8ArrayBlobAdapter.mutate(streamBody);
        }
        if (!streamBody) {
            return Uint8ArrayBlobAdapter.mutate(new Uint8Array());
        }
        const fromContext = context.streamCollector(streamBody);
        return Uint8ArrayBlobAdapter.mutate(await fromContext);
    };

    class Command {
        constructor() {
            this.middlewareStack = constructStack();
        }
        static classBuilder() {
            return new ClassBuilder();
        }
        resolveMiddlewareWithContext(clientStack, configuration, options, { middlewareFn, clientName, commandName, inputFilterSensitiveLog, outputFilterSensitiveLog, smithyContext, additionalContext, CommandCtor, }) {
            for (const mw of middlewareFn.bind(this)(CommandCtor, clientStack, configuration, options)) {
                this.middlewareStack.use(mw);
            }
            const stack = clientStack.concat(this.middlewareStack);
            const { logger } = configuration;
            const handlerExecutionContext = {
                logger,
                clientName,
                commandName,
                inputFilterSensitiveLog,
                outputFilterSensitiveLog,
                [SMITHY_CONTEXT_KEY]: {
                    ...smithyContext,
                },
                ...additionalContext,
            };
            const { requestHandler } = configuration;
            return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
    }
    class ClassBuilder {
        constructor() {
            this._init = () => { };
            this._ep = {};
            this._middlewareFn = () => [];
            this._commandName = "";
            this._clientName = "";
            this._additionalContext = {};
            this._smithyContext = {};
            this._inputFilterSensitiveLog = (_) => _;
            this._outputFilterSensitiveLog = (_) => _;
            this._serializer = null;
            this._deserializer = null;
        }
        init(cb) {
            this._init = cb;
        }
        ep(endpointParameterInstructions) {
            this._ep = endpointParameterInstructions;
            return this;
        }
        m(middlewareSupplier) {
            this._middlewareFn = middlewareSupplier;
            return this;
        }
        s(service, operation, smithyContext = {}) {
            this._smithyContext = {
                service,
                operation,
                ...smithyContext,
            };
            return this;
        }
        c(additionalContext = {}) {
            this._additionalContext = additionalContext;
            return this;
        }
        n(clientName, commandName) {
            this._clientName = clientName;
            this._commandName = commandName;
            return this;
        }
        f(inputFilter = (_) => _, outputFilter = (_) => _) {
            this._inputFilterSensitiveLog = inputFilter;
            this._outputFilterSensitiveLog = outputFilter;
            return this;
        }
        ser(serializer) {
            this._serializer = serializer;
            return this;
        }
        de(deserializer) {
            this._deserializer = deserializer;
            return this;
        }
        build() {
            const closure = this;
            let CommandRef;
            return (CommandRef = class extends Command {
                static getEndpointParameterInstructions() {
                    return closure._ep;
                }
                constructor(...[input]) {
                    super();
                    this.serialize = closure._serializer;
                    this.deserialize = closure._deserializer;
                    this.input = input ?? {};
                    closure._init(this);
                }
                resolveMiddleware(stack, configuration, options) {
                    return this.resolveMiddlewareWithContext(stack, configuration, options, {
                        CommandCtor: CommandRef,
                        middlewareFn: closure._middlewareFn,
                        clientName: closure._clientName,
                        commandName: closure._commandName,
                        inputFilterSensitiveLog: closure._inputFilterSensitiveLog,
                        outputFilterSensitiveLog: closure._outputFilterSensitiveLog,
                        smithyContext: closure._smithyContext,
                        additionalContext: closure._additionalContext,
                    });
                }
            });
        }
    }

    const SENSITIVE_STRING = "***SensitiveInformation***";

    const createAggregatedClient = (commands, Client) => {
        for (const command of Object.keys(commands)) {
            const CommandCtor = commands[command];
            const methodImpl = async function (args, optionsOrCb, cb) {
                const command = new CommandCtor(args);
                if (typeof optionsOrCb === "function") {
                    this.send(command, optionsOrCb);
                }
                else if (typeof cb === "function") {
                    if (typeof optionsOrCb !== "object")
                        throw new Error(`Expected http options but got ${typeof optionsOrCb}`);
                    this.send(command, optionsOrCb || {}, cb);
                }
                else {
                    return this.send(command, optionsOrCb);
                }
            };
            const methodName = (command[0].toLowerCase() + command.slice(1)).replace(/Command$/, "");
            Client.prototype[methodName] = methodImpl;
        }
    };

    const expectBoolean = (value) => {
        if (value === null || value === undefined) {
            return undefined;
        }
        if (typeof value === "number") {
            if (value === 0 || value === 1) {
                logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
            }
            if (value === 0) {
                return false;
            }
            if (value === 1) {
                return true;
            }
        }
        if (typeof value === "string") {
            const lower = value.toLowerCase();
            if (lower === "false" || lower === "true") {
                logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
            }
            if (lower === "false") {
                return false;
            }
            if (lower === "true") {
                return true;
            }
        }
        if (typeof value === "boolean") {
            return value;
        }
        throw new TypeError(`Expected boolean, got ${typeof value}: ${value}`);
    };
    const expectNumber = (value) => {
        if (value === null || value === undefined) {
            return undefined;
        }
        if (typeof value === "string") {
            const parsed = parseFloat(value);
            if (!Number.isNaN(parsed)) {
                if (String(parsed) !== String(value)) {
                    logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));
                }
                return parsed;
            }
        }
        if (typeof value === "number") {
            return value;
        }
        throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
    };
    const expectLong = (value) => {
        if (value === null || value === undefined) {
            return undefined;
        }
        if (Number.isInteger(value) && !Number.isNaN(value)) {
            return value;
        }
        throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
    };
    const expectInt32 = (value) => expectSizedInt(value, 32);
    const expectSizedInt = (value, size) => {
        const expected = expectLong(value);
        if (expected !== undefined && castInt(expected, size) !== expected) {
            throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
        }
        return expected;
    };
    const castInt = (value, size) => {
        switch (size) {
            case 32:
                return Int32Array.of(value)[0];
            case 16:
                return Int16Array.of(value)[0];
            case 8:
                return Int8Array.of(value)[0];
        }
    };
    const expectNonNull = (value, location) => {
        if (value === null || value === undefined) {
            {
                throw new TypeError(`Expected a non-null value for ${location}`);
            }
        }
        return value;
    };
    const expectObject = (value) => {
        if (value === null || value === undefined) {
            return undefined;
        }
        if (typeof value === "object" && !Array.isArray(value)) {
            return value;
        }
        const receivedType = Array.isArray(value) ? "array" : typeof value;
        throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
    };
    const expectString = (value) => {
        if (value === null || value === undefined) {
            return undefined;
        }
        if (typeof value === "string") {
            return value;
        }
        if (["boolean", "number", "bigint"].includes(typeof value)) {
            logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));
            return String(value);
        }
        throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
    };
    const limitedParseDouble = (value) => {
        if (typeof value == "string") {
            return parseFloatString(value);
        }
        return expectNumber(value);
    };
    const parseFloatString = (value) => {
        switch (value) {
            case "NaN":
                return NaN;
            case "Infinity":
                return Infinity;
            case "-Infinity":
                return -Infinity;
            default:
                throw new Error(`Unable to parse float value: ${value}`);
        }
    };
    const stackTraceWarning = (message) => {
        return String(new TypeError(message).stack || message)
            .split("\n")
            .slice(0, 5)
            .filter((s) => !s.includes("stackTraceWarning"))
            .join("\n");
    };
    const logger = {
        warn: console.warn,
    };

    class ServiceException extends Error {
        constructor(options) {
            super(options.message);
            Object.setPrototypeOf(this, ServiceException.prototype);
            this.name = options.name;
            this.$fault = options.$fault;
            this.$metadata = options.$metadata;
        }
    }
    const decorateServiceException = (exception, additions = {}) => {
        Object.entries(additions)
            .filter(([, v]) => v !== undefined)
            .forEach(([k, v]) => {
            if (exception[k] == undefined || exception[k] === "") {
                exception[k] = v;
            }
        });
        const message = exception.message || exception.Message || "UnknownError";
        exception.message = message;
        delete exception.Message;
        return exception;
    };

    const throwDefaultError$3 = ({ output, parsedBody, exceptionCtor, errorCode }) => {
        const $metadata = deserializeMetadata$3(output);
        const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
        const response = new exceptionCtor({
            name: parsedBody?.code || parsedBody?.Code || errorCode || statusCode || "UnknownError",
            $fault: "client",
            $metadata,
        });
        throw decorateServiceException(response, parsedBody);
    };
    const withBaseException = (ExceptionCtor) => {
        return ({ output, parsedBody, errorCode }) => {
            throwDefaultError$3({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
        };
    };
    const deserializeMetadata$3 = (output) => ({
        httpStatusCode: output.statusCode,
        requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
        extendedRequestId: output.headers["x-amz-id-2"],
        cfId: output.headers["x-amz-cf-id"],
    });

    const loadConfigsForDefaultMode = (mode) => {
        switch (mode) {
            case "standard":
                return {
                    retryMode: "standard",
                    connectionTimeout: 3100,
                };
            case "in-region":
                return {
                    retryMode: "standard",
                    connectionTimeout: 1100,
                };
            case "cross-region":
                return {
                    retryMode: "standard",
                    connectionTimeout: 3100,
                };
            case "mobile":
                return {
                    retryMode: "standard",
                    connectionTimeout: 30000,
                };
            default:
                return {};
        }
    };

    const getChecksumConfiguration = (runtimeConfig) => {
        const checksumAlgorithms = [];
        for (const id in AlgorithmId) {
            const algorithmId = AlgorithmId[id];
            if (runtimeConfig[algorithmId] === undefined) {
                continue;
            }
            checksumAlgorithms.push({
                algorithmId: () => algorithmId,
                checksumConstructor: () => runtimeConfig[algorithmId],
            });
        }
        return {
            _checksumAlgorithms: checksumAlgorithms,
            addChecksumAlgorithm(algo) {
                this._checksumAlgorithms.push(algo);
            },
            checksumAlgorithms() {
                return this._checksumAlgorithms;
            },
        };
    };
    const resolveChecksumRuntimeConfig = (clientConfig) => {
        const runtimeConfig = {};
        clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
            runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
        });
        return runtimeConfig;
    };

    const getRetryConfiguration = (runtimeConfig) => {
        let _retryStrategy = runtimeConfig.retryStrategy;
        return {
            setRetryStrategy(retryStrategy) {
                _retryStrategy = retryStrategy;
            },
            retryStrategy() {
                return _retryStrategy;
            },
        };
    };
    const resolveRetryRuntimeConfig = (retryStrategyConfiguration) => {
        const runtimeConfig = {};
        runtimeConfig.retryStrategy = retryStrategyConfiguration.retryStrategy();
        return runtimeConfig;
    };

    const getDefaultExtensionConfiguration = (runtimeConfig) => {
        return {
            ...getChecksumConfiguration(runtimeConfig),
            ...getRetryConfiguration(runtimeConfig),
        };
    };
    const resolveDefaultRuntimeConfig = (config) => {
        return {
            ...resolveChecksumRuntimeConfig(config),
            ...resolveRetryRuntimeConfig(config),
        };
    };

    const StringWrapper = function () {
        const Class = Object.getPrototypeOf(this).constructor;
        const Constructor = Function.bind.apply(String, [null, ...arguments]);
        const instance = new Constructor();
        Object.setPrototypeOf(instance, Class.prototype);
        return instance;
    };
    StringWrapper.prototype = Object.create(String.prototype, {
        constructor: {
            value: StringWrapper,
            enumerable: false,
            writable: true,
            configurable: true,
        },
    });
    Object.setPrototypeOf(StringWrapper, String);

    function map(arg0, arg1, arg2) {
        let target;
        let filter;
        let instructions;
        if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
            target = {};
            instructions = arg0;
        }
        else {
            target = arg0;
            if (typeof arg1 === "function") {
                filter = arg1;
                instructions = arg2;
                return mapWithFilter(target, filter, instructions);
            }
            else {
                instructions = arg1;
            }
        }
        for (const key of Object.keys(instructions)) {
            if (!Array.isArray(instructions[key])) {
                target[key] = instructions[key];
                continue;
            }
            applyInstruction(target, null, instructions, key);
        }
        return target;
    }
    const take = (source, instructions) => {
        const out = {};
        for (const key in instructions) {
            applyInstruction(out, source, instructions, key);
        }
        return out;
    };
    const mapWithFilter = (target, filter, instructions) => {
        return map(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {
            if (Array.isArray(value)) {
                _instructions[key] = value;
            }
            else {
                if (typeof value === "function") {
                    _instructions[key] = [filter, value()];
                }
                else {
                    _instructions[key] = [filter, value];
                }
            }
            return _instructions;
        }, {}));
    };
    const applyInstruction = (target, source, instructions, targetKey) => {
        if (source !== null) {
            let instruction = instructions[targetKey];
            if (typeof instruction === "function") {
                instruction = [, instruction];
            }
            const [filter = nonNullish, valueFn = pass, sourceKey = targetKey] = instruction;
            if ((typeof filter === "function" && filter(source[sourceKey])) || (typeof filter !== "function" && !!filter)) {
                target[targetKey] = valueFn(source[sourceKey]);
            }
            return;
        }
        let [filter, value] = instructions[targetKey];
        if (typeof value === "function") {
            let _value;
            const defaultFilterPassed = filter === undefined && (_value = value()) != null;
            const customFilterPassed = (typeof filter === "function" && !!filter(void 0)) || (typeof filter !== "function" && !!filter);
            if (defaultFilterPassed) {
                target[targetKey] = _value;
            }
            else if (customFilterPassed) {
                target[targetKey] = value();
            }
        }
        else {
            const defaultFilterPassed = filter === undefined && value != null;
            const customFilterPassed = (typeof filter === "function" && !!filter(value)) || (typeof filter !== "function" && !!filter);
            if (defaultFilterPassed || customFilterPassed) {
                target[targetKey] = value;
            }
        }
    };
    const nonNullish = (_) => _ != null;
    const pass = (_) => _;

    const serializeFloat = (value) => {
        if (value !== value) {
            return "NaN";
        }
        switch (value) {
            case Infinity:
                return "Infinity";
            case -Infinity:
                return "-Infinity";
            default:
                return value;
        }
    };

    const _json = (obj) => {
        if (obj == null) {
            return {};
        }
        if (Array.isArray(obj)) {
            return obj.filter((_) => _ != null).map(_json);
        }
        if (typeof obj === "object") {
            const target = {};
            for (const key of Object.keys(obj)) {
                if (obj[key] == null) {
                    continue;
                }
                target[key] = _json(obj[key]);
            }
            return target;
        }
        return obj;
    };

    function parseQueryString(querystring) {
        const query = {};
        querystring = querystring.replace(/^\?/, "");
        if (querystring) {
            for (const pair of querystring.split("&")) {
                let [key, value = null] = pair.split("=");
                key = decodeURIComponent(key);
                if (value) {
                    value = decodeURIComponent(value);
                }
                if (!(key in query)) {
                    query[key] = value;
                }
                else if (Array.isArray(query[key])) {
                    query[key].push(value);
                }
                else {
                    query[key] = [query[key], value];
                }
            }
        }
        return query;
    }

    const parseUrl = (url) => {
        if (typeof url === "string") {
            return parseUrl(new URL(url));
        }
        const { hostname, pathname, port, protocol, search } = url;
        let query;
        if (search) {
            query = parseQueryString(search);
        }
        return {
            hostname,
            port: port ? parseInt(port) : undefined,
            protocol,
            path: pathname,
            query,
        };
    };

    const getRuntimeConfig$5 = (config) => {
        return {
            apiVersion: "2020-11-19",
            base64Decoder: config?.base64Decoder ?? fromBase64,
            base64Encoder: config?.base64Encoder ?? toBase64,
            disableHostPrefix: config?.disableHostPrefix ?? false,
            extensions: config?.extensions ?? [],
            logger: config?.logger ?? new NoOpLogger(),
            regionInfoProvider: config?.regionInfoProvider ?? defaultRegionInfoProvider,
            serviceId: config?.serviceId ?? "GeoRoutes",
            urlParser: config?.urlParser ?? parseUrl,
            utf8Decoder: config?.utf8Decoder ?? fromUtf8,
            utf8Encoder: config?.utf8Encoder ?? toUtf8,
        };
    };

    const memoize = (provider, isExpired, requiresRefresh) => {
        let resolved;
        let pending;
        let hasResult;
        let isConstant = false;
        const coalesceProvider = async () => {
            if (!pending) {
                pending = provider();
            }
            try {
                resolved = await pending;
                hasResult = true;
                isConstant = false;
            }
            finally {
                pending = undefined;
            }
            return resolved;
        };
        {
            return async (options) => {
                if (!hasResult || options?.forceRefresh) {
                    resolved = await coalesceProvider();
                }
                return resolved;
            };
        }
    };

    const DEFAULTS_MODE_OPTIONS = ["in-region", "cross-region", "mobile", "standard", "legacy"];

    const resolveDefaultsModeConfig = ({ defaultsMode, } = {}) => memoize(async () => {
        const mode = typeof defaultsMode === "function" ? await defaultsMode() : defaultsMode;
        switch (mode?.toLowerCase()) {
            case "auto":
                return Promise.resolve(isMobileBrowser() ? "mobile" : "standard");
            case "mobile":
            case "in-region":
            case "cross-region":
            case "standard":
            case "legacy":
                return Promise.resolve(mode?.toLocaleLowerCase());
            case undefined:
                return Promise.resolve("legacy");
            default:
                throw new Error(`Invalid parameter for "defaultsMode", expect ${DEFAULTS_MODE_OPTIONS.join(", ")}, got ${mode}`);
        }
    });
    const isMobileBrowser = () => {
        const parsedUA = typeof window !== "undefined" && window?.navigator?.userAgent
            ? bowser.parse(window.navigator.userAgent)
            : undefined;
        const platform = parsedUA?.platform?.type;
        return platform === "tablet" || platform === "mobile";
    };

    const getRuntimeConfig$4 = (config) => {
        const defaultsMode = resolveDefaultsModeConfig(config);
        const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
        const clientSharedValues = getRuntimeConfig$5(config);
        return {
            ...clientSharedValues,
            ...config,
            runtime: "browser",
            defaultsMode,
            bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength,
            credentialDefaultProvider: config?.credentialDefaultProvider ?? ((_) => () => Promise.reject(new Error("Credential is missing"))),
            defaultUserAgentProvider: config?.defaultUserAgentProvider ?? defaultUserAgent({ serviceId: clientSharedValues.serviceId, clientVersion: packageInfo$2.version }),
            maxAttempts: config?.maxAttempts ?? DEFAULT_MAX_ATTEMPTS,
            region: config?.region ?? invalidProvider("Region is missing"),
            requestHandler: config?.requestHandler ?? new FetchHttpHandler(defaultConfigProvider),
            retryMode: config?.retryMode ?? (async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE),
            sha256: config?.sha256 ?? buildExports.Sha256,
            streamCollector: config?.streamCollector ?? streamCollector,
            useDualstackEndpoint: config?.useDualstackEndpoint ?? (() => Promise.resolve(DEFAULT_USE_DUALSTACK_ENDPOINT)),
            useFipsEndpoint: config?.useFipsEndpoint ?? (() => Promise.resolve(DEFAULT_USE_FIPS_ENDPOINT)),
        };
    };

    const getAwsRegionExtensionConfiguration = (runtimeConfig) => {
        let runtimeConfigRegion = async () => {
            if (runtimeConfig.region === undefined) {
                throw new Error("Region is missing from runtimeConfig");
            }
            const region = runtimeConfig.region;
            if (typeof region === "string") {
                return region;
            }
            return region();
        };
        return {
            setRegion(region) {
                runtimeConfigRegion = region;
            },
            region() {
                return runtimeConfigRegion;
            },
        };
    };
    const resolveAwsRegionExtensionConfiguration = (awsRegionExtensionConfiguration) => {
        return {
            region: awsRegionExtensionConfiguration.region(),
        };
    };

    const asPartial$2 = (t) => t;
    const resolveRuntimeExtensions$2 = (runtimeConfig, extensions) => {
        const extensionConfiguration = {
            ...asPartial$2(getAwsRegionExtensionConfiguration(runtimeConfig)),
            ...asPartial$2(getDefaultExtensionConfiguration(runtimeConfig)),
            ...asPartial$2(getHttpHandlerExtensionConfiguration(runtimeConfig)),
        };
        extensions.forEach(extension => extension.configure(extensionConfiguration));
        return {
            ...runtimeConfig,
            ...resolveAwsRegionExtensionConfiguration(extensionConfiguration),
            ...resolveDefaultRuntimeConfig(extensionConfiguration),
            ...resolveHttpHandlerRuntimeConfig(extensionConfiguration),
        };
    };

    function resolveHostHeaderConfig(input) {
        return input;
    }
    const hostHeaderMiddleware = (options) => (next) => async (args) => {
        if (!HttpRequest.isInstance(args.request))
            return next(args);
        const { request } = args;
        const { handlerProtocol = "" } = options.requestHandler.metadata || {};
        if (handlerProtocol.indexOf("h2") >= 0 && !request.headers[":authority"]) {
            delete request.headers["host"];
            request.headers[":authority"] = request.hostname + (request.port ? ":" + request.port : "");
        }
        else if (!request.headers["host"]) {
            let host = request.hostname;
            if (request.port != null)
                host += `:${request.port}`;
            request.headers["host"] = host;
        }
        return next(args);
    };
    const hostHeaderMiddlewareOptions = {
        name: "hostHeaderMiddleware",
        step: "build",
        priority: "low",
        tags: ["HOST"],
        override: true,
    };
    const getHostHeaderPlugin = (options) => ({
        applyToStack: (clientStack) => {
            clientStack.add(hostHeaderMiddleware(options), hostHeaderMiddlewareOptions);
        },
    });

    const loggerMiddleware = () => (next, context) => async (args) => {
        try {
            const response = await next(args);
            const { clientName, commandName, logger, dynamoDbDocumentClientOptions = {} } = context;
            const { overrideInputFilterSensitiveLog, overrideOutputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
            const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
            const outputFilterSensitiveLog = overrideOutputFilterSensitiveLog ?? context.outputFilterSensitiveLog;
            const { $metadata, ...outputWithoutMetadata } = response.output;
            logger?.info?.({
                clientName,
                commandName,
                input: inputFilterSensitiveLog(args.input),
                output: outputFilterSensitiveLog(outputWithoutMetadata),
                metadata: $metadata,
            });
            return response;
        }
        catch (error) {
            const { clientName, commandName, logger, dynamoDbDocumentClientOptions = {} } = context;
            const { overrideInputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
            const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
            logger?.error?.({
                clientName,
                commandName,
                input: inputFilterSensitiveLog(args.input),
                error,
                metadata: error.$metadata,
            });
            throw error;
        }
    };
    const loggerMiddlewareOptions = {
        name: "loggerMiddleware",
        tags: ["LOGGER"],
        step: "initialize",
        override: true,
    };
    const getLoggerPlugin = (options) => ({
        applyToStack: (clientStack) => {
            clientStack.add(loggerMiddleware(), loggerMiddlewareOptions);
        },
    });

    const TRACE_ID_HEADER_NAME = "X-Amzn-Trace-Id";
    const ENV_LAMBDA_FUNCTION_NAME = "AWS_LAMBDA_FUNCTION_NAME";
    const ENV_TRACE_ID = "_X_AMZN_TRACE_ID";
    const recursionDetectionMiddleware = (options) => (next) => async (args) => {
        const { request } = args;
        if (!HttpRequest.isInstance(request) ||
            options.runtime !== "node" ||
            request.headers.hasOwnProperty(TRACE_ID_HEADER_NAME)) {
            return next(args);
        }
        const functionName = process.env[ENV_LAMBDA_FUNCTION_NAME];
        const traceId = process.env[ENV_TRACE_ID];
        const nonEmptyString = (str) => typeof str === "string" && str.length > 0;
        if (nonEmptyString(functionName) && nonEmptyString(traceId)) {
            request.headers[TRACE_ID_HEADER_NAME] = traceId;
        }
        return next({
            ...args,
            request,
        });
    };
    const addRecursionDetectionMiddlewareOptions = {
        step: "build",
        tags: ["RECURSION_DETECTION"],
        name: "recursionDetectionMiddleware",
        override: true,
        priority: "low",
    };
    const getRecursionDetectionPlugin = (options) => ({
        applyToStack: (clientStack) => {
            clientStack.add(recursionDetectionMiddleware(options), addRecursionDetectionMiddlewareOptions);
        },
    });

    function resolveUserAgentConfig(input) {
        return {
            ...input,
            customUserAgent: typeof input.customUserAgent === "string" ? [[input.customUserAgent]] : input.customUserAgent,
        };
    }

    ({
        [EndpointURLScheme.HTTP]: 80,
        [EndpointURLScheme.HTTPS]: 443,
    });

    const USER_AGENT = "user-agent";
    const X_AMZ_USER_AGENT = "x-amz-user-agent";
    const SPACE = " ";
    const UA_NAME_SEPARATOR = "/";
    const UA_NAME_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g;
    const UA_VALUE_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g;
    const UA_ESCAPE_CHAR = "-";

    const userAgentMiddleware = (options) => (next, context) => async (args) => {
        const { request } = args;
        if (!HttpRequest.isInstance(request))
            return next(args);
        const { headers } = request;
        const userAgent = context?.userAgent?.map(escapeUserAgent) || [];
        const defaultUserAgent = (await options.defaultUserAgentProvider()).map(escapeUserAgent);
        const customUserAgent = options?.customUserAgent?.map(escapeUserAgent) || [];
        const sdkUserAgentValue = ([])
            .concat([...defaultUserAgent, ...userAgent, ...customUserAgent])
            .join(SPACE);
        const normalUAValue = [
            ...defaultUserAgent.filter((section) => section.startsWith("aws-sdk-")),
            ...customUserAgent,
        ].join(SPACE);
        if (options.runtime !== "browser") {
            if (normalUAValue) {
                headers[X_AMZ_USER_AGENT] = headers[X_AMZ_USER_AGENT]
                    ? `${headers[USER_AGENT]} ${normalUAValue}`
                    : normalUAValue;
            }
            headers[USER_AGENT] = sdkUserAgentValue;
        }
        else {
            headers[X_AMZ_USER_AGENT] = sdkUserAgentValue;
        }
        return next({
            ...args,
            request,
        });
    };
    const escapeUserAgent = (userAgentPair) => {
        const name = userAgentPair[0]
            .split(UA_NAME_SEPARATOR)
            .map((part) => part.replace(UA_NAME_ESCAPE_REGEX, UA_ESCAPE_CHAR))
            .join(UA_NAME_SEPARATOR);
        const version = userAgentPair[1]?.replace(UA_VALUE_ESCAPE_REGEX, UA_ESCAPE_CHAR);
        const prefixSeparatorIndex = name.indexOf(UA_NAME_SEPARATOR);
        const prefix = name.substring(0, prefixSeparatorIndex);
        let uaName = name.substring(prefixSeparatorIndex + 1);
        if (prefix === "api") {
            uaName = uaName.toLowerCase();
        }
        return [prefix, uaName, version]
            .filter((item) => item && item.length > 0)
            .reduce((acc, item, index) => {
            switch (index) {
                case 0:
                    return item;
                case 1:
                    return `${acc}/${item}`;
                default:
                    return `${acc}#${item}`;
            }
        }, "");
    };
    const getUserAgentMiddlewareOptions = {
        name: "getUserAgentMiddleware",
        step: "build",
        priority: "low",
        tags: ["SET_USER_AGENT", "USER_AGENT"],
        override: true,
    };
    const getUserAgentPlugin = (config) => ({
        applyToStack: (clientStack) => {
            clientStack.add(userAgentMiddleware(config), getUserAgentMiddlewareOptions);
        },
    });

    const CONTENT_LENGTH_HEADER = "content-length";
    function contentLengthMiddleware(bodyLengthChecker) {
        return (next) => async (args) => {
            const request = args.request;
            if (HttpRequest.isInstance(request)) {
                const { body, headers } = request;
                if (body &&
                    Object.keys(headers)
                        .map((str) => str.toLowerCase())
                        .indexOf(CONTENT_LENGTH_HEADER) === -1) {
                    try {
                        const length = bodyLengthChecker(body);
                        request.headers = {
                            ...request.headers,
                            [CONTENT_LENGTH_HEADER]: String(length),
                        };
                    }
                    catch (error) {
                    }
                }
            }
            return next({
                ...args,
                request,
            });
        };
    }
    const contentLengthMiddlewareOptions = {
        step: "build",
        tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
        name: "contentLengthMiddleware",
        override: true,
    };
    const getContentLengthPlugin = (options) => ({
        applyToStack: (clientStack) => {
            clientStack.add(contentLengthMiddleware(options.bodyLengthChecker), contentLengthMiddlewareOptions);
        },
    });

    const asSdkError = (error) => {
        if (error instanceof Error)
            return error;
        if (error instanceof Object)
            return Object.assign(new Error(), error);
        if (typeof error === "string")
            return new Error(error);
        return new Error(`AWS SDK error wrapper for ${error}`);
    };

    const resolveRetryConfig = (input) => {
        const { retryStrategy } = input;
        const maxAttempts = normalizeProvider(input.maxAttempts ?? DEFAULT_MAX_ATTEMPTS);
        return {
            ...input,
            maxAttempts,
            retryStrategy: async () => {
                if (retryStrategy) {
                    return retryStrategy;
                }
                const retryMode = await normalizeProvider(input.retryMode)();
                if (retryMode === RETRY_MODES.ADAPTIVE) {
                    return new AdaptiveRetryStrategy(maxAttempts);
                }
                return new StandardRetryStrategy(maxAttempts);
            },
        };
    };

    const isStreamingPayload = (request) => request?.body instanceof ReadableStream;

    const retryMiddleware = (options) => (next, context) => async (args) => {
        let retryStrategy = await options.retryStrategy();
        const maxAttempts = await options.maxAttempts();
        if (isRetryStrategyV2(retryStrategy)) {
            retryStrategy = retryStrategy;
            let retryToken = await retryStrategy.acquireInitialRetryToken(context["partition_id"]);
            let lastError = new Error();
            let attempts = 0;
            let totalRetryDelay = 0;
            const { request } = args;
            const isRequest = HttpRequest.isInstance(request);
            if (isRequest) {
                request.headers[INVOCATION_ID_HEADER] = v4();
            }
            while (true) {
                try {
                    if (isRequest) {
                        request.headers[REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
                    }
                    const { response, output } = await next(args);
                    retryStrategy.recordSuccess(retryToken);
                    output.$metadata.attempts = attempts + 1;
                    output.$metadata.totalRetryDelay = totalRetryDelay;
                    return { response, output };
                }
                catch (e) {
                    const retryErrorInfo = getRetryErrorInfo(e);
                    lastError = asSdkError(e);
                    if (isRequest && isStreamingPayload(request)) {
                        (context.logger instanceof NoOpLogger ? console : context.logger)?.warn("An error was encountered in a non-retryable streaming request.");
                        throw lastError;
                    }
                    try {
                        retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);
                    }
                    catch (refreshError) {
                        if (!lastError.$metadata) {
                            lastError.$metadata = {};
                        }
                        lastError.$metadata.attempts = attempts + 1;
                        lastError.$metadata.totalRetryDelay = totalRetryDelay;
                        throw lastError;
                    }
                    attempts = retryToken.getRetryCount();
                    const delay = retryToken.getRetryDelay();
                    totalRetryDelay += delay;
                    await new Promise((resolve) => setTimeout(resolve, delay));
                }
            }
        }
        else {
            retryStrategy = retryStrategy;
            if (retryStrategy?.mode)
                context.userAgent = [...(context.userAgent || []), ["cfg/retry-mode", retryStrategy.mode]];
            return retryStrategy.retry(next, args);
        }
    };
    const isRetryStrategyV2 = (retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== "undefined" &&
        typeof retryStrategy.refreshRetryTokenForRetry !== "undefined" &&
        typeof retryStrategy.recordSuccess !== "undefined";
    const getRetryErrorInfo = (error) => {
        const errorInfo = {
            error,
            errorType: getRetryErrorType(error),
        };
        const retryAfterHint = getRetryAfterHint(error.$response);
        if (retryAfterHint) {
            errorInfo.retryAfterHint = retryAfterHint;
        }
        return errorInfo;
    };
    const getRetryErrorType = (error) => {
        if (isThrottlingError(error))
            return "THROTTLING";
        if (isTransientError(error))
            return "TRANSIENT";
        if (isServerError(error))
            return "SERVER_ERROR";
        return "CLIENT_ERROR";
    };
    const retryMiddlewareOptions = {
        name: "retryMiddleware",
        tags: ["RETRY"],
        step: "finalizeRequest",
        priority: "high",
        override: true,
    };
    const getRetryPlugin = (options) => ({
        applyToStack: (clientStack) => {
            clientStack.add(retryMiddleware(options), retryMiddlewareOptions);
        },
    });
    const getRetryAfterHint = (response) => {
        if (!HttpResponse.isInstance(response))
            return;
        const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
        if (!retryAfterHeaderName)
            return;
        const retryAfter = response.headers[retryAfterHeaderName];
        const retryAfterSeconds = Number(retryAfter);
        if (!Number.isNaN(retryAfterSeconds))
            return new Date(retryAfterSeconds * 1000);
        const retryAfterDate = new Date(retryAfter);
        return retryAfterDate;
    };

    class GeoRoutesClient extends Client {
        constructor(...[configuration]) {
            let _config_0 = getRuntimeConfig$4(configuration || {});
            let _config_1 = resolveRegionConfig(_config_0);
            let _config_2 = resolveEndpointsConfig(_config_1);
            let _config_3 = resolveRetryConfig(_config_2);
            let _config_4 = resolveHostHeaderConfig(_config_3);
            let _config_5 = resolveAwsAuthConfig(_config_4);
            let _config_6 = resolveUserAgentConfig(_config_5);
            let _config_7 = resolveRuntimeExtensions$2(_config_6, configuration?.extensions || []);
            super(_config_7);
            this.config = _config_7;
            this.middlewareStack.use(getRetryPlugin(this.config));
            this.middlewareStack.use(getContentLengthPlugin(this.config));
            this.middlewareStack.use(getHostHeaderPlugin(this.config));
            this.middlewareStack.use(getLoggerPlugin(this.config));
            this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
            this.middlewareStack.use(getAwsAuthPlugin(this.config));
            this.middlewareStack.use(getUserAgentPlugin(this.config));
        }
        destroy() {
            super.destroy();
        }
    }

    class GeoRoutesServiceException extends ServiceException {
        constructor(options) {
            super(options);
            Object.setPrototypeOf(this, GeoRoutesServiceException.prototype);
        }
    }

    class AccessDeniedException extends GeoRoutesServiceException {
        constructor(opts) {
            super({
                name: "AccessDeniedException",
                $fault: "client",
                ...opts
            });
            this.name = "AccessDeniedException";
            this.$fault = "client";
            Object.setPrototypeOf(this, AccessDeniedException.prototype);
            this.Message = opts.Message;
        }
    }
    class InternalServerException extends GeoRoutesServiceException {
        constructor(opts) {
            super({
                name: "InternalServerException",
                $fault: "server",
                ...opts
            });
            this.name = "InternalServerException";
            this.$fault = "server";
            this.$retryable = {};
            Object.setPrototypeOf(this, InternalServerException.prototype);
            this.Message = opts.Message;
        }
    }
    class ThrottlingException extends GeoRoutesServiceException {
        constructor(opts) {
            super({
                name: "ThrottlingException",
                $fault: "client",
                ...opts
            });
            this.name = "ThrottlingException";
            this.$fault = "client";
            this.$retryable = {};
            Object.setPrototypeOf(this, ThrottlingException.prototype);
            this.Message = opts.Message;
        }
    }
    class ValidationException extends GeoRoutesServiceException {
        constructor(opts) {
            super({
                name: "ValidationException",
                $fault: "client",
                ...opts
            });
            this.name = "ValidationException";
            this.$fault = "client";
            Object.setPrototypeOf(this, ValidationException.prototype);
            this.Message = opts.Message;
            this.Reason = opts.Reason;
            this.FieldList = opts.FieldList;
        }
    }
    const CorridorFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.LineString && { LineString: SENSITIVE_STRING
        }),
    });
    const PolylineCorridorFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Polyline && { Polyline: SENSITIVE_STRING
        }),
    });
    const IsolineAvoidanceAreaGeometryFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.BoundingBox && { BoundingBox: SENSITIVE_STRING
        }),
        ...(obj.Polygon && { Polygon: obj.Polygon.map(item => SENSITIVE_STRING)
        }),
        ...(obj.Corridor && { Corridor: SENSITIVE_STRING
        }),
        ...(obj.PolylinePolygon && { PolylinePolygon: SENSITIVE_STRING
        }),
        ...(obj.PolylineCorridor && { PolylineCorridor: SENSITIVE_STRING
        }),
    });
    const IsolineAvoidanceAreaFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Geometry && { Geometry: IsolineAvoidanceAreaGeometryFilterSensitiveLog(obj.Geometry)
        }),
        ...(obj.Except && { Except: obj.Except.map(item => IsolineAvoidanceAreaGeometryFilterSensitiveLog(item))
        }),
    });
    const IsolineAvoidanceOptionsFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Areas && { Areas: obj.Areas.map(item => IsolineAvoidanceAreaFilterSensitiveLog(item))
        }),
    });
    const IsolineMatchingOptionsFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.NameHint && { NameHint: SENSITIVE_STRING
        }),
    });
    const IsolineSideOfStreetOptionsFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Position && { Position: SENSITIVE_STRING
        }),
    });
    const IsolineDestinationOptionsFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Matching && { Matching: IsolineMatchingOptionsFilterSensitiveLog(obj.Matching)
        }),
        ...(obj.SideOfStreet && { SideOfStreet: IsolineSideOfStreetOptionsFilterSensitiveLog(obj.SideOfStreet)
        }),
    });
    const IsolineOriginOptionsFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Matching && { Matching: IsolineMatchingOptionsFilterSensitiveLog(obj.Matching)
        }),
        ...(obj.SideOfStreet && { SideOfStreet: IsolineSideOfStreetOptionsFilterSensitiveLog(obj.SideOfStreet)
        }),
    });
    const CalculateIsolinesRequestFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Avoid && { Avoid: IsolineAvoidanceOptionsFilterSensitiveLog(obj.Avoid)
        }),
        ...(obj.Destination && { Destination: SENSITIVE_STRING
        }),
        ...(obj.DestinationOptions && { DestinationOptions: IsolineDestinationOptionsFilterSensitiveLog(obj.DestinationOptions)
        }),
        ...(obj.Key && { Key: SENSITIVE_STRING
        }),
        ...(obj.KeyHeader && { KeyHeader: SENSITIVE_STRING
        }),
        ...(obj.Origin && { Origin: SENSITIVE_STRING
        }),
        ...(obj.OriginOptions && { OriginOptions: IsolineOriginOptionsFilterSensitiveLog(obj.OriginOptions)
        }),
    });
    const IsolineConnectionGeometryFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.LineString && { LineString: SENSITIVE_STRING
        }),
        ...(obj.Polyline && { Polyline: SENSITIVE_STRING
        }),
    });
    const IsolineConnectionFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Geometry && { Geometry: IsolineConnectionGeometryFilterSensitiveLog(obj.Geometry)
        }),
    });
    const IsolineShapeGeometryFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.PolylinePolygon && { PolylinePolygon: SENSITIVE_STRING
        }),
        ...(obj.Polygon && { Polygon: obj.Polygon.map(item => SENSITIVE_STRING)
        }),
    });
    const IsolineFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Connections && { Connections: obj.Connections.map(item => IsolineConnectionFilterSensitiveLog(item))
        }),
        ...(obj.Geometries && { Geometries: obj.Geometries.map(item => IsolineShapeGeometryFilterSensitiveLog(item))
        }),
    });
    const CalculateIsolinesResponseFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.SnappedDestination && { SnappedDestination: SENSITIVE_STRING
        }),
        ...(obj.SnappedOrigin && { SnappedOrigin: SENSITIVE_STRING
        }),
    });
    const RouteMatrixAvoidanceAreaGeometryFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.BoundingBox && { BoundingBox: SENSITIVE_STRING
        }),
        ...(obj.Polygon && { Polygon: obj.Polygon.map(item => SENSITIVE_STRING)
        }),
        ...(obj.PolylinePolygon && { PolylinePolygon: SENSITIVE_STRING
        }),
    });
    const RouteMatrixAvoidanceAreaFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Geometry && { Geometry: RouteMatrixAvoidanceAreaGeometryFilterSensitiveLog(obj.Geometry)
        }),
    });
    const RouteMatrixAvoidanceOptionsFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Areas && { Areas: obj.Areas.map(item => RouteMatrixAvoidanceAreaFilterSensitiveLog(item))
        }),
    });
    const RouteMatrixMatchingOptionsFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.NameHint && { NameHint: SENSITIVE_STRING
        }),
    });
    const RouteMatrixSideOfStreetOptionsFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Position && { Position: SENSITIVE_STRING
        }),
    });
    const RouteMatrixDestinationOptionsFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Matching && { Matching: RouteMatrixMatchingOptionsFilterSensitiveLog(obj.Matching)
        }),
        ...(obj.SideOfStreet && { SideOfStreet: RouteMatrixSideOfStreetOptionsFilterSensitiveLog(obj.SideOfStreet)
        }),
    });
    const RouteMatrixDestinationFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Position && { Position: SENSITIVE_STRING
        }),
        ...(obj.Options && { Options: RouteMatrixDestinationOptionsFilterSensitiveLog(obj.Options)
        }),
    });
    const RouteMatrixOriginOptionsFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Matching && { Matching: RouteMatrixMatchingOptionsFilterSensitiveLog(obj.Matching)
        }),
        ...(obj.SideOfStreet && { SideOfStreet: RouteMatrixSideOfStreetOptionsFilterSensitiveLog(obj.SideOfStreet)
        }),
    });
    const RouteMatrixOriginFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Position && { Position: SENSITIVE_STRING
        }),
        ...(obj.Options && { Options: RouteMatrixOriginOptionsFilterSensitiveLog(obj.Options)
        }),
    });
    const CircleFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Center && { Center: SENSITIVE_STRING
        }),
    });
    const RouteMatrixBoundaryGeometryFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Circle && { Circle: SENSITIVE_STRING
        }),
        ...(obj.BoundingBox && { BoundingBox: SENSITIVE_STRING
        }),
        ...(obj.Polygon && { Polygon: obj.Polygon.map(item => SENSITIVE_STRING)
        }),
    });
    const RouteMatrixBoundaryFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Geometry && { Geometry: RouteMatrixBoundaryGeometryFilterSensitiveLog(obj.Geometry)
        }),
    });
    const CalculateRouteMatrixRequestFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Avoid && { Avoid: RouteMatrixAvoidanceOptionsFilterSensitiveLog(obj.Avoid)
        }),
        ...(obj.Destinations && { Destinations: obj.Destinations.map(item => RouteMatrixDestinationFilterSensitiveLog(item))
        }),
        ...(obj.Key && { Key: SENSITIVE_STRING
        }),
        ...(obj.KeyHeader && { KeyHeader: SENSITIVE_STRING
        }),
        ...(obj.Origins && { Origins: obj.Origins.map(item => RouteMatrixOriginFilterSensitiveLog(item))
        }),
        ...(obj.RoutingBoundary && { RoutingBoundary: RouteMatrixBoundaryFilterSensitiveLog(obj.RoutingBoundary)
        }),
    });
    const CalculateRouteMatrixResponseFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.RoutingBoundary && { RoutingBoundary: RouteMatrixBoundaryFilterSensitiveLog(obj.RoutingBoundary)
        }),
    });
    const RouteAvoidanceAreaGeometryFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.BoundingBox && { BoundingBox: SENSITIVE_STRING
        }),
        ...(obj.Polygon && { Polygon: obj.Polygon.map(item => SENSITIVE_STRING)
        }),
        ...(obj.PolylinePolygon && { PolylinePolygon: SENSITIVE_STRING
        }),
        ...(obj.Corridor && { Corridor: SENSITIVE_STRING
        }),
        ...(obj.PolylineCorridor && { PolylineCorridor: SENSITIVE_STRING
        }),
    });
    const RouteAvoidanceAreaFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Geometry && { Geometry: RouteAvoidanceAreaGeometryFilterSensitiveLog(obj.Geometry)
        }),
        ...(obj.Except && { Except: obj.Except.map(item => RouteAvoidanceAreaGeometryFilterSensitiveLog(item))
        }),
    });
    const RouteAvoidanceOptionsFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Areas && { Areas: obj.Areas.map(item => RouteAvoidanceAreaFilterSensitiveLog(item))
        }),
    });
    const RouteMatchingOptionsFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.NameHint && { NameHint: SENSITIVE_STRING
        }),
    });
    const RouteSideOfStreetOptionsFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Position && { Position: SENSITIVE_STRING
        }),
    });
    const RouteDestinationOptionsFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Matching && { Matching: RouteMatchingOptionsFilterSensitiveLog(obj.Matching)
        }),
        ...(obj.SideOfStreet && { SideOfStreet: RouteSideOfStreetOptionsFilterSensitiveLog(obj.SideOfStreet)
        }),
    });
    const RouteOriginOptionsFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Matching && { Matching: RouteMatchingOptionsFilterSensitiveLog(obj.Matching)
        }),
        ...(obj.SideOfStreet && { SideOfStreet: RouteSideOfStreetOptionsFilterSensitiveLog(obj.SideOfStreet)
        }),
    });
    const RouteWaypointFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Matching && { Matching: RouteMatchingOptionsFilterSensitiveLog(obj.Matching)
        }),
        ...(obj.Position && { Position: SENSITIVE_STRING
        }),
        ...(obj.SideOfStreet && { SideOfStreet: RouteSideOfStreetOptionsFilterSensitiveLog(obj.SideOfStreet)
        }),
    });
    const CalculateRoutesRequestFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Avoid && { Avoid: RouteAvoidanceOptionsFilterSensitiveLog(obj.Avoid)
        }),
        ...(obj.Destination && { Destination: SENSITIVE_STRING
        }),
        ...(obj.DestinationOptions && { DestinationOptions: RouteDestinationOptionsFilterSensitiveLog(obj.DestinationOptions)
        }),
        ...(obj.Key && { Key: SENSITIVE_STRING
        }),
        ...(obj.KeyHeader && { KeyHeader: SENSITIVE_STRING
        }),
        ...(obj.Origin && { Origin: SENSITIVE_STRING
        }),
        ...(obj.OriginOptions && { OriginOptions: RouteOriginOptionsFilterSensitiveLog(obj.OriginOptions)
        }),
        ...(obj.Waypoints && { Waypoints: obj.Waypoints.map(item => RouteWaypointFilterSensitiveLog(item))
        }),
    });
    const RouteFerryPlaceFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.OriginalPosition && { OriginalPosition: SENSITIVE_STRING
        }),
        ...(obj.Position && { Position: SENSITIVE_STRING
        }),
    });
    const RouteFerryArrivalFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Place && { Place: RouteFerryPlaceFilterSensitiveLog(obj.Place)
        }),
    });
    const RouteFerryDepartureFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Place && { Place: RouteFerryPlaceFilterSensitiveLog(obj.Place)
        }),
    });
    const RoutePassThroughPlaceFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.OriginalPosition && { OriginalPosition: SENSITIVE_STRING
        }),
        ...(obj.Position && { Position: SENSITIVE_STRING
        }),
    });
    const RoutePassThroughWaypointFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Place && { Place: RoutePassThroughPlaceFilterSensitiveLog(obj.Place)
        }),
    });
    const RouteFerryLegDetailsFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Arrival && { Arrival: RouteFerryArrivalFilterSensitiveLog(obj.Arrival)
        }),
        ...(obj.Departure && { Departure: RouteFerryDepartureFilterSensitiveLog(obj.Departure)
        }),
        ...(obj.PassThroughWaypoints && { PassThroughWaypoints: obj.PassThroughWaypoints.map(item => RoutePassThroughWaypointFilterSensitiveLog(item))
        }),
    });
    const RouteLegGeometryFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.LineString && { LineString: SENSITIVE_STRING
        }),
        ...(obj.Polyline && { Polyline: SENSITIVE_STRING
        }),
    });
    const RoutePedestrianPlaceFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.OriginalPosition && { OriginalPosition: SENSITIVE_STRING
        }),
        ...(obj.Position && { Position: SENSITIVE_STRING
        }),
    });
    const RoutePedestrianArrivalFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Place && { Place: RoutePedestrianPlaceFilterSensitiveLog(obj.Place)
        }),
    });
    const RoutePedestrianDepartureFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Place && { Place: RoutePedestrianPlaceFilterSensitiveLog(obj.Place)
        }),
    });
    const RoutePedestrianLegDetailsFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Arrival && { Arrival: RoutePedestrianArrivalFilterSensitiveLog(obj.Arrival)
        }),
        ...(obj.Departure && { Departure: RoutePedestrianDepartureFilterSensitiveLog(obj.Departure)
        }),
        ...(obj.PassThroughWaypoints && { PassThroughWaypoints: obj.PassThroughWaypoints.map(item => RoutePassThroughWaypointFilterSensitiveLog(item))
        }),
    });
    const RouteVehiclePlaceFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.OriginalPosition && { OriginalPosition: SENSITIVE_STRING
        }),
        ...(obj.Position && { Position: SENSITIVE_STRING
        }),
    });
    const RouteVehicleArrivalFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Place && { Place: RouteVehiclePlaceFilterSensitiveLog(obj.Place)
        }),
    });
    const RouteVehicleDepartureFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Place && { Place: RouteVehiclePlaceFilterSensitiveLog(obj.Place)
        }),
    });
    const RouteTollPaymentSiteFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Position && { Position: SENSITIVE_STRING
        }),
    });
    const RouteTollFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.PaymentSites && { PaymentSites: obj.PaymentSites.map(item => RouteTollPaymentSiteFilterSensitiveLog(item))
        }),
    });
    const RouteVehicleLegDetailsFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Arrival && { Arrival: RouteVehicleArrivalFilterSensitiveLog(obj.Arrival)
        }),
        ...(obj.Departure && { Departure: RouteVehicleDepartureFilterSensitiveLog(obj.Departure)
        }),
        ...(obj.PassThroughWaypoints && { PassThroughWaypoints: obj.PassThroughWaypoints.map(item => RoutePassThroughWaypointFilterSensitiveLog(item))
        }),
    });
    const RouteLegFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.FerryLegDetails && { FerryLegDetails: RouteFerryLegDetailsFilterSensitiveLog(obj.FerryLegDetails)
        }),
        ...(obj.Geometry && { Geometry: RouteLegGeometryFilterSensitiveLog(obj.Geometry)
        }),
        ...(obj.PedestrianLegDetails && { PedestrianLegDetails: RoutePedestrianLegDetailsFilterSensitiveLog(obj.PedestrianLegDetails)
        }),
        ...(obj.VehicleLegDetails && { VehicleLegDetails: RouteVehicleLegDetailsFilterSensitiveLog(obj.VehicleLegDetails)
        }),
    });
    const RouteFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Legs && { Legs: obj.Legs.map(item => RouteLegFilterSensitiveLog(item))
        }),
    });
    const CalculateRoutesResponseFilterSensitiveLog = (obj) => ({
        ...obj,
    });
    const WaypointOptimizationAvoidanceAreaGeometryFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.BoundingBox && { BoundingBox: SENSITIVE_STRING
        }),
    });
    const WaypointOptimizationAvoidanceAreaFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Geometry && { Geometry: WaypointOptimizationAvoidanceAreaGeometryFilterSensitiveLog(obj.Geometry)
        }),
    });
    const WaypointOptimizationAvoidanceOptionsFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Areas && { Areas: obj.Areas.map(item => WaypointOptimizationAvoidanceAreaFilterSensitiveLog(item))
        }),
    });
    const WaypointOptimizationSideOfStreetOptionsFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Position && { Position: SENSITIVE_STRING
        }),
    });
    const WaypointOptimizationDestinationOptionsFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.SideOfStreet && { SideOfStreet: WaypointOptimizationSideOfStreetOptionsFilterSensitiveLog(obj.SideOfStreet)
        }),
    });
    const WaypointOptimizationWaypointFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Position && { Position: SENSITIVE_STRING
        }),
        ...(obj.SideOfStreet && { SideOfStreet: WaypointOptimizationSideOfStreetOptionsFilterSensitiveLog(obj.SideOfStreet)
        }),
    });
    const OptimizeWaypointsRequestFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Avoid && { Avoid: WaypointOptimizationAvoidanceOptionsFilterSensitiveLog(obj.Avoid)
        }),
        ...(obj.Destination && { Destination: SENSITIVE_STRING
        }),
        ...(obj.DestinationOptions && { DestinationOptions: WaypointOptimizationDestinationOptionsFilterSensitiveLog(obj.DestinationOptions)
        }),
        ...(obj.Origin && { Origin: SENSITIVE_STRING
        }),
        ...(obj.Waypoints && { Waypoints: obj.Waypoints.map(item => WaypointOptimizationWaypointFilterSensitiveLog(item))
        }),
        ...(obj.Key && { Key: SENSITIVE_STRING
        }),
        ...(obj.KeyHeader && { KeyHeader: SENSITIVE_STRING
        }),
    });
    const WaypointOptimizationImpedingWaypointFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Position && { Position: SENSITIVE_STRING
        }),
    });
    const WaypointOptimizationOptimizedWaypointFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Position && { Position: SENSITIVE_STRING
        }),
    });
    const OptimizeWaypointsResponseFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.ImpedingWaypoints && { ImpedingWaypoints: obj.ImpedingWaypoints.map(item => WaypointOptimizationImpedingWaypointFilterSensitiveLog(item))
        }),
        ...(obj.OptimizedWaypoints && { OptimizedWaypoints: obj.OptimizedWaypoints.map(item => WaypointOptimizationOptimizedWaypointFilterSensitiveLog(item))
        }),
    });
    const RoadSnapTracePointFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Position && { Position: SENSITIVE_STRING
        }),
    });
    const SnapToRoadsRequestFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Key && { Key: SENSITIVE_STRING
        }),
        ...(obj.KeyHeader && { KeyHeader: SENSITIVE_STRING
        }),
        ...(obj.TracePoints && { TracePoints: obj.TracePoints.map(item => RoadSnapTracePointFilterSensitiveLog(item))
        }),
    });
    const RoadSnapSnappedGeometryFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.LineString && { LineString: SENSITIVE_STRING
        }),
        ...(obj.Polyline && { Polyline: SENSITIVE_STRING
        }),
    });
    const RoadSnapSnappedTracePointFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.OriginalPosition && { OriginalPosition: SENSITIVE_STRING
        }),
        ...(obj.SnappedPosition && { SnappedPosition: SENSITIVE_STRING
        }),
    });
    const SnapToRoadsResponseFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.SnappedGeometry && { SnappedGeometry: RoadSnapSnappedGeometryFilterSensitiveLog(obj.SnappedGeometry)
        }),
        ...(obj.SnappedTracePoints && { SnappedTracePoints: obj.SnappedTracePoints.map(item => RoadSnapSnappedTracePointFilterSensitiveLog(item))
        }),
    });

    const se_CalculateIsolinesCommand = async (input, context) => {
        const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
        const headers = map({}, isSerializableHeaderValue, {
            'content-type': 'application/json',
            'api-key': input.KeyHeader,
        });
        let resolvedPath = `${basePath?.endsWith('/') ? basePath.slice(0, -1) : (basePath || '')}` + "/isolines";
        const query = map({
            "key": [, input.Key],
        });
        let body;
        body = JSON.stringify(take(input, {
            'AdditionalFeatures': _ => _json(_),
            'Allow': _ => _json(_),
            'ArrivalTime': [],
            'Avoid': _ => se_IsolineAvoidanceOptions(_),
            'DepartNow': [],
            'DepartureTime': [],
            'Destination': _ => se_Position(_),
            'DestinationOptions': _ => se_IsolineDestinationOptions(_),
            'IsolineGeometryFormat': [],
            'IsolineGranularity': _ => _json(_),
            'OptimizeIsolineFor': [],
            'OptimizeRoutingFor': [],
            'Origin': _ => se_Position(_),
            'OriginOptions': _ => se_IsolineOriginOptions(_),
            'Thresholds': _ => _json(_),
            'Traffic': _ => _json(_),
            'TravelMode': [],
            'TravelModeOptions': _ => se_IsolineTravelModeOptions(_),
        }));
        return new HttpRequest({
            protocol,
            hostname,
            port,
            method: "POST",
            headers,
            path: resolvedPath,
            query,
            body,
        });
    };
    const se_CalculateRouteMatrixCommand = async (input, context) => {
        const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
        const headers = map({}, isSerializableHeaderValue, {
            'content-type': 'application/json',
            'api-key': input.KeyHeader,
        });
        let resolvedPath = `${basePath?.endsWith('/') ? basePath.slice(0, -1) : (basePath || '')}` + "/route-matrix";
        const query = map({
            "key": [, input.Key],
        });
        let body;
        body = JSON.stringify(take(input, {
            'AdditionalFeatures': _ => _json(_),
            'Allow': _ => _json(_),
            'Avoid': _ => se_RouteMatrixAvoidanceOptions(_),
            'DepartNow': [],
            'DepartureTime': [],
            'Destinations': _ => se_RouteMatrixDestinationList(_),
            'Exclude': _ => _json(_),
            'OptimizeRoutingFor': [],
            'Origins': _ => se_RouteMatrixOriginList(_),
            'RoutingBoundary': _ => se_RouteMatrixBoundary(_),
            'Traffic': _ => _json(_),
            'TravelMode': [],
            'TravelModeOptions': _ => se_RouteMatrixTravelModeOptions(_),
        }));
        return new HttpRequest({
            protocol,
            hostname,
            port,
            method: "POST",
            headers,
            path: resolvedPath,
            query,
            body,
        });
    };
    const se_CalculateRoutesCommand = async (input, context) => {
        const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
        const headers = map({}, isSerializableHeaderValue, {
            'content-type': 'application/json',
            'api-key': input.KeyHeader,
        });
        let resolvedPath = `${basePath?.endsWith('/') ? basePath.slice(0, -1) : (basePath || '')}` + "/routes";
        const query = map({
            "key": [, input.Key],
        });
        let body;
        body = JSON.stringify(take(input, {
            'Allow': _ => _json(_),
            'ArrivalTime': [],
            'Avoid': _ => se_RouteAvoidanceOptions(_),
            'DepartNow': [],
            'DepartureTime': [],
            'Destination': _ => se_Position(_),
            'DestinationOptions': _ => se_RouteDestinationOptions(_),
            'Driver': _ => _json(_),
            'Exclude': _ => _json(_),
            'InstructionsMeasurementSystem': [],
            'Languages': _ => _json(_),
            'LegAdditionalFeatures': _ => _json(_),
            'LegGeometryFormat': [],
            'MaxAlternatives': [],
            'OptimizeRoutingFor': [],
            'Origin': _ => se_Position(_),
            'OriginOptions': _ => se_RouteOriginOptions(_),
            'SpanAdditionalFeatures': _ => _json(_),
            'Tolls': _ => _json(_),
            'Traffic': _ => _json(_),
            'TravelMode': [],
            'TravelModeOptions': _ => se_RouteTravelModeOptions(_),
            'TravelStepType': [],
            'Waypoints': _ => se_RouteWaypointList(_),
        }));
        return new HttpRequest({
            protocol,
            hostname,
            port,
            method: "POST",
            headers,
            path: resolvedPath,
            query,
            body,
        });
    };
    const se_OptimizeWaypointsCommand = async (input, context) => {
        const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
        const headers = map({}, isSerializableHeaderValue, {
            'content-type': 'application/json',
            'api-key': input.KeyHeader,
        });
        let resolvedPath = `${basePath?.endsWith('/') ? basePath.slice(0, -1) : (basePath || '')}` + "/optimize-waypoints";
        const query = map({
            "key": [, input.Key],
        });
        let body;
        body = JSON.stringify(take(input, {
            'AdditionalFeatures': _ => _json(_),
            'Avoid': _ => se_WaypointOptimizationAvoidanceOptions(_),
            'Clustering': _ => _json(_),
            'DepartureTime': [],
            'Destination': _ => se_Position(_),
            'DestinationOptions': _ => se_WaypointOptimizationDestinationOptions(_),
            'Driver': _ => _json(_),
            'Exclude': _ => _json(_),
            'OptimizeSequencingFor': [],
            'Origin': _ => se_Position(_),
            'OriginOptions': _ => _json(_),
            'Traffic': _ => _json(_),
            'TravelMode': [],
            'TravelModeOptions': _ => se_WaypointOptimizationTravelModeOptions(_),
            'Waypoints': _ => se_WaypointOptimizationWaypointList(_),
        }));
        return new HttpRequest({
            protocol,
            hostname,
            port,
            method: "POST",
            headers,
            path: resolvedPath,
            query,
            body,
        });
    };
    const se_SnapToRoadsCommand = async (input, context) => {
        const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
        const headers = map({}, isSerializableHeaderValue, {
            'content-type': 'application/json',
            'api-key': input.KeyHeader,
        });
        let resolvedPath = `${basePath?.endsWith('/') ? basePath.slice(0, -1) : (basePath || '')}` + "/snap-to-roads";
        const query = map({
            "key": [, input.Key],
        });
        let body;
        body = JSON.stringify(take(input, {
            'AdditionalFeatures': _ => _json(_),
            'SnapRadius': [],
            'SnappedGeometryFormat': [],
            'TracePoints': _ => se_RoadSnapTracePointList(_),
            'TravelMode': [],
            'TravelModeOptions': _ => _json(_),
        }));
        return new HttpRequest({
            protocol,
            hostname,
            port,
            method: "POST",
            headers,
            path: resolvedPath,
            query,
            body,
        });
    };
    const de_CalculateIsolinesCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CalculateIsolinesCommandError(output, context);
        }
        const contents = map({
            $metadata: deserializeMetadata$2(output),
            PricingBucket: [, output.headers['x-amz-geo-pricing-bucket']],
        });
        const data = expectNonNull((expectObject(await parseBody(output.body, context))), "body");
        const doc = take(data, {
            'ArrivalTime': expectString,
            'DepartureTime': expectString,
            'IsolineGeometryFormat': expectString,
            'Isolines': _ => de_IsolineList(_),
            'SnappedDestination': _ => de_Position(_),
            'SnappedOrigin': _ => de_Position(_),
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_CalculateIsolinesCommandError = async (output, context) => {
        const parsedOutput = {
            ...output,
            body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
            case "AccessDeniedException":
            case "com.amazonaws.services.waypoint.exceptions#AccessDeniedException":
                throw await de_AccessDeniedExceptionRes(parsedOutput);
            case "InternalServerException":
            case "com.amazonaws.services.waypoint.exceptions#InternalServerException":
                throw await de_InternalServerExceptionRes(parsedOutput);
            case "ThrottlingException":
            case "com.amazonaws.services.waypoint.exceptions#ThrottlingException":
                throw await de_ThrottlingExceptionRes(parsedOutput);
            case "ValidationException":
            case "com.amazonaws.services.waypoint.exceptions#ValidationException":
                throw await de_ValidationExceptionRes(parsedOutput);
            default:
                const parsedBody = parsedOutput.body;
                return throwDefaultError$2({
                    output,
                    parsedBody,
                    errorCode
                });
        }
    };
    const de_CalculateRouteMatrixCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CalculateRouteMatrixCommandError(output, context);
        }
        const contents = map({
            $metadata: deserializeMetadata$2(output),
            PricingBucket: [, output.headers['x-amz-geo-pricing-bucket']],
        });
        const data = expectNonNull((expectObject(await parseBody(output.body, context))), "body");
        const doc = take(data, {
            'ErrorCount': expectInt32,
            'RouteMatrix': _json,
            'RoutingBoundary': _ => de_RouteMatrixBoundary(_),
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_CalculateRouteMatrixCommandError = async (output, context) => {
        const parsedOutput = {
            ...output,
            body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
            case "AccessDeniedException":
            case "com.amazonaws.services.waypoint.exceptions#AccessDeniedException":
                throw await de_AccessDeniedExceptionRes(parsedOutput);
            case "InternalServerException":
            case "com.amazonaws.services.waypoint.exceptions#InternalServerException":
                throw await de_InternalServerExceptionRes(parsedOutput);
            case "ThrottlingException":
            case "com.amazonaws.services.waypoint.exceptions#ThrottlingException":
                throw await de_ThrottlingExceptionRes(parsedOutput);
            case "ValidationException":
            case "com.amazonaws.services.waypoint.exceptions#ValidationException":
                throw await de_ValidationExceptionRes(parsedOutput);
            default:
                const parsedBody = parsedOutput.body;
                return throwDefaultError$2({
                    output,
                    parsedBody,
                    errorCode
                });
        }
    };
    const de_CalculateRoutesCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_CalculateRoutesCommandError(output, context);
        }
        const contents = map({
            $metadata: deserializeMetadata$2(output),
            PricingBucket: [, output.headers['x-amz-geo-pricing-bucket']],
        });
        const data = expectNonNull((expectObject(await parseBody(output.body, context))), "body");
        const doc = take(data, {
            'LegGeometryFormat': expectString,
            'Notices': _json,
            'Routes': _ => de_RouteList(_),
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_CalculateRoutesCommandError = async (output, context) => {
        const parsedOutput = {
            ...output,
            body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
            case "AccessDeniedException":
            case "com.amazonaws.services.waypoint.exceptions#AccessDeniedException":
                throw await de_AccessDeniedExceptionRes(parsedOutput);
            case "InternalServerException":
            case "com.amazonaws.services.waypoint.exceptions#InternalServerException":
                throw await de_InternalServerExceptionRes(parsedOutput);
            case "ThrottlingException":
            case "com.amazonaws.services.waypoint.exceptions#ThrottlingException":
                throw await de_ThrottlingExceptionRes(parsedOutput);
            case "ValidationException":
            case "com.amazonaws.services.waypoint.exceptions#ValidationException":
                throw await de_ValidationExceptionRes(parsedOutput);
            default:
                const parsedBody = parsedOutput.body;
                return throwDefaultError$2({
                    output,
                    parsedBody,
                    errorCode
                });
        }
    };
    const de_OptimizeWaypointsCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_OptimizeWaypointsCommandError(output, context);
        }
        const contents = map({
            $metadata: deserializeMetadata$2(output),
            PricingBucket: [, output.headers['x-amz-geo-pricing-bucket']],
        });
        const data = expectNonNull((expectObject(await parseBody(output.body, context))), "body");
        const doc = take(data, {
            'Connections': _json,
            'Distance': expectLong,
            'Duration': expectLong,
            'ImpedingWaypoints': _ => de_WaypointOptimizationImpedingWaypointList(_),
            'OptimizedWaypoints': _ => de_WaypointOptimizationOptimizedWaypointList(_),
            'TimeBreakdown': _json,
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_OptimizeWaypointsCommandError = async (output, context) => {
        const parsedOutput = {
            ...output,
            body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
            case "AccessDeniedException":
            case "com.amazonaws.services.waypoint.exceptions#AccessDeniedException":
                throw await de_AccessDeniedExceptionRes(parsedOutput);
            case "InternalServerException":
            case "com.amazonaws.services.waypoint.exceptions#InternalServerException":
                throw await de_InternalServerExceptionRes(parsedOutput);
            case "ThrottlingException":
            case "com.amazonaws.services.waypoint.exceptions#ThrottlingException":
                throw await de_ThrottlingExceptionRes(parsedOutput);
            case "ValidationException":
            case "com.amazonaws.services.waypoint.exceptions#ValidationException":
                throw await de_ValidationExceptionRes(parsedOutput);
            default:
                const parsedBody = parsedOutput.body;
                return throwDefaultError$2({
                    output,
                    parsedBody,
                    errorCode
                });
        }
    };
    const de_SnapToRoadsCommand = async (output, context) => {
        if (output.statusCode !== 200 && output.statusCode >= 300) {
            return de_SnapToRoadsCommandError(output, context);
        }
        const contents = map({
            $metadata: deserializeMetadata$2(output),
            PricingBucket: [, output.headers['x-amz-geo-pricing-bucket']],
        });
        const data = expectNonNull((expectObject(await parseBody(output.body, context))), "body");
        const doc = take(data, {
            'Notices': _json,
            'SnappedGeometry': _ => de_RoadSnapSnappedGeometry(_),
            'SnappedGeometryFormat': expectString,
            'SnappedTracePoints': _ => de_RoadSnapSnappedTracePointList(_),
        });
        Object.assign(contents, doc);
        return contents;
    };
    const de_SnapToRoadsCommandError = async (output, context) => {
        const parsedOutput = {
            ...output,
            body: await parseErrorBody(output.body, context)
        };
        const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
        switch (errorCode) {
            case "AccessDeniedException":
            case "com.amazonaws.services.waypoint.exceptions#AccessDeniedException":
                throw await de_AccessDeniedExceptionRes(parsedOutput);
            case "InternalServerException":
            case "com.amazonaws.services.waypoint.exceptions#InternalServerException":
                throw await de_InternalServerExceptionRes(parsedOutput);
            case "ThrottlingException":
            case "com.amazonaws.services.waypoint.exceptions#ThrottlingException":
                throw await de_ThrottlingExceptionRes(parsedOutput);
            case "ValidationException":
            case "com.amazonaws.services.waypoint.exceptions#ValidationException":
                throw await de_ValidationExceptionRes(parsedOutput);
            default:
                const parsedBody = parsedOutput.body;
                return throwDefaultError$2({
                    output,
                    parsedBody,
                    errorCode
                });
        }
    };
    const throwDefaultError$2 = withBaseException(GeoRoutesServiceException);
    const de_AccessDeniedExceptionRes = async (parsedOutput, context) => {
        const contents = map({});
        const data = parsedOutput.body;
        const doc = take(data, {
            'Message': [, expectString, `message`],
        });
        Object.assign(contents, doc);
        const exception = new AccessDeniedException({
            $metadata: deserializeMetadata$2(parsedOutput),
            ...contents
        });
        return decorateServiceException(exception, parsedOutput.body);
    };
    const de_InternalServerExceptionRes = async (parsedOutput, context) => {
        const contents = map({});
        const data = parsedOutput.body;
        const doc = take(data, {
            'Message': [, expectString, `message`],
        });
        Object.assign(contents, doc);
        const exception = new InternalServerException({
            $metadata: deserializeMetadata$2(parsedOutput),
            ...contents
        });
        return decorateServiceException(exception, parsedOutput.body);
    };
    const de_ThrottlingExceptionRes = async (parsedOutput, context) => {
        const contents = map({});
        const data = parsedOutput.body;
        const doc = take(data, {
            'Message': [, expectString, `message`],
        });
        Object.assign(contents, doc);
        const exception = new ThrottlingException({
            $metadata: deserializeMetadata$2(parsedOutput),
            ...contents
        });
        return decorateServiceException(exception, parsedOutput.body);
    };
    const de_ValidationExceptionRes = async (parsedOutput, context) => {
        const contents = map({});
        const data = parsedOutput.body;
        const doc = take(data, {
            'FieldList': [, _ => de_ValidationExceptionFieldList(_), `fieldList`],
            'Message': [, expectString, `message`],
            'Reason': [, expectString, `reason`],
        });
        Object.assign(contents, doc);
        const exception = new ValidationException({
            $metadata: deserializeMetadata$2(parsedOutput),
            ...contents
        });
        return decorateServiceException(exception, parsedOutput.body);
    };
    const se_ChargingRateAtChargeLevel = (input, context) => {
        return take(input, {
            'ChargingLevel': serializeFloat,
            'ChargingRate': serializeFloat,
        });
    };
    const se_ChargingRateAtChargeLevelList = (input, context) => {
        return input.filter((e) => e != null).map(entry => {
            return se_ChargingRateAtChargeLevel(entry);
        });
    };
    const se_ConsumptionRateAtSpeed = (input, context) => {
        return take(input, {
            'ConsumptionRate': serializeFloat,
            'Speed': serializeFloat,
        });
    };
    const se_ConsumptionRateAtSpeedList = (input, context) => {
        return input.filter((e) => e != null).map(entry => {
            return se_ConsumptionRateAtSpeed(entry);
        });
    };
    const se_IsolineAvoidanceArea = (input, context) => {
        return take(input, {
            'Except': _ => se_IsolineAvoidanceAreaGeometryList(_),
            'Geometry': _ => se_IsolineAvoidanceAreaGeometry(_),
        });
    };
    const se_IsolineAvoidanceAreaGeometry = (input, context) => {
        return take(input, {
            'BoundingBox': _ => se_BoundingBox(_),
            'Corridor': _ => se_Corridor(_),
            'Polygon': _ => se_LinearRings(_),
            'PolylineCorridor': _json,
            'PolylinePolygon': _json,
        });
    };
    const se_IsolineAvoidanceAreaGeometryList = (input, context) => {
        return input.filter((e) => e != null).map(entry => {
            return se_IsolineAvoidanceAreaGeometry(entry);
        });
    };
    const se_IsolineAvoidanceAreaList = (input, context) => {
        return input.filter((e) => e != null).map(entry => {
            return se_IsolineAvoidanceArea(entry);
        });
    };
    const se_IsolineAvoidanceOptions = (input, context) => {
        return take(input, {
            'Areas': _ => se_IsolineAvoidanceAreaList(_),
            'CarShuttleTrains': [],
            'ControlledAccessHighways': [],
            'DifficultTurns': [],
            'DirtRoads': [],
            'Ferries': [],
            'SeasonalClosure': [],
            'TollRoads': [],
            'TollTransponders': [],
            'TruckRoadTypes': _json,
            'Tunnels': [],
            'UTurns': [],
            'ZoneCategories': _json,
        });
    };
    const se_IsolineCarOptions = (input, context) => {
        return take(input, {
            'EngineType': [],
            'LicensePlate': _json,
            'MaxSpeed': serializeFloat,
            'Occupancy': [],
        });
    };
    const se_IsolineConsumptionRateAtSpeed = (input, context) => {
        return take(input, {
            'ConsumptionRate': serializeFloat,
            'Speed': serializeFloat,
        });
    };
    const se_IsolineConsumptionRateAtSpeedList = (input, context) => {
        return input.filter((e) => e != null).map(entry => {
            return se_IsolineConsumptionRateAtSpeed(entry);
        });
    };
    const se_IsolineDestinationOptions = (input, context) => {
        return take(input, {
            'AvoidActionsForDistance': [],
            'Heading': serializeFloat,
            'Matching': _json,
            'SideOfStreet': _ => se_IsolineSideOfStreetOptions(_),
        });
    };
    const se_IsolineEvOptions = (input, context) => {
        return take(input, {
            'AuxiliaryConsumptionRate': serializeFloat,
            'ConsumptionRateOnAscent': serializeFloat,
            'ConsumptionRateOnDescent': serializeFloat,
            'FreeFlowConsumptionCurve': _ => se_IsolineConsumptionRateAtSpeedList(_),
            'TrafficConsumptionCurve': _ => se_IsolineConsumptionRateAtSpeedList(_),
        });
    };
    const se_IsolineOriginOptions = (input, context) => {
        return take(input, {
            'AvoidActionsForDistance': [],
            'Heading': serializeFloat,
            'Matching': _json,
            'SideOfStreet': _ => se_IsolineSideOfStreetOptions(_),
        });
    };
    const se_IsolineScooterOptions = (input, context) => {
        return take(input, {
            'EngineType': [],
            'LicensePlate': _json,
            'MaxSpeed': serializeFloat,
            'Occupancy': [],
        });
    };
    const se_IsolineSideOfStreetOptions = (input, context) => {
        return take(input, {
            'Position': _ => se_Position(_),
            'UseWith': [],
        });
    };
    const se_IsolineTravelModeOptions = (input, context) => {
        return take(input, {
            'Car': _ => se_IsolineCarOptions(_),
            'Ev': _ => se_IsolineEvOptions(_),
            'Scooter': _ => se_IsolineScooterOptions(_),
            'Truck': _ => se_IsolineTruckOptions(_),
        });
    };
    const se_IsolineTruckOptions = (input, context) => {
        return take(input, {
            'AxleCount': [],
            'EngineType': [],
            'GrossWeight': [],
            'HazardousCargos': _json,
            'Height': [],
            'HeightAboveFirstAxle': [],
            'KpraLength': [],
            'Length': [],
            'LicensePlate': _json,
            'MaxSpeed': serializeFloat,
            'Occupancy': [],
            'PayloadCapacity': [],
            'TireCount': [],
            'Trailer': _json,
            'TruckType': [],
            'TunnelRestrictionCode': [],
            'WeightPerAxle': [],
            'WeightPerAxleGroup': _json,
            'Width': [],
        });
    };
    const se_RoadSnapTracePoint = (input, context) => {
        return take(input, {
            'Heading': serializeFloat,
            'Position': _ => se_Position(_),
            'Speed': serializeFloat,
            'Timestamp': [],
        });
    };
    const se_RoadSnapTracePointList = (input, context) => {
        return input.filter((e) => e != null).map(entry => {
            return se_RoadSnapTracePoint(entry);
        });
    };
    const se_RouteAvoidanceArea = (input, context) => {
        return take(input, {
            'Except': _ => se_RouteAvoidanceAreaGeometryList(_),
            'Geometry': _ => se_RouteAvoidanceAreaGeometry(_),
        });
    };
    const se_RouteAvoidanceAreaGeometry = (input, context) => {
        return take(input, {
            'BoundingBox': _ => se_BoundingBox(_),
            'Corridor': _ => se_Corridor(_),
            'Polygon': _ => se_LinearRings(_),
            'PolylineCorridor': _json,
            'PolylinePolygon': _json,
        });
    };
    const se_RouteAvoidanceAreaGeometryList = (input, context) => {
        return input.filter((e) => e != null).map(entry => {
            return se_RouteAvoidanceAreaGeometry(entry);
        });
    };
    const se_RouteAvoidanceAreaList = (input, context) => {
        return input.filter((e) => e != null).map(entry => {
            return se_RouteAvoidanceArea(entry);
        });
    };
    const se_RouteAvoidanceOptions = (input, context) => {
        return take(input, {
            'Areas': _ => se_RouteAvoidanceAreaList(_),
            'CarShuttleTrains': [],
            'ControlledAccessHighways': [],
            'DifficultTurns': [],
            'DirtRoads': [],
            'Ferries': [],
            'SeasonalClosure': [],
            'TollRoads': [],
            'TollTransponders': [],
            'TruckRoadTypes': _json,
            'Tunnels': [],
            'UTurns': [],
            'ZoneCategories': _json,
        });
    };
    const se_RouteCarOptions = (input, context) => {
        return take(input, {
            'EngineType': [],
            'LicensePlate': _json,
            'MaxSpeed': serializeFloat,
            'Occupancy': [],
        });
    };
    const se_RouteDestinationOptions = (input, context) => {
        return take(input, {
            'AvoidActionsForDistance': [],
            'AvoidUTurns': [],
            'Heading': serializeFloat,
            'Matching': _json,
            'SideOfStreet': _ => se_RouteSideOfStreetOptions(_),
            'StopDuration': [],
        });
    };
    const se_RouteEvOptions = (input, context) => {
        return take(input, {
            'AuxiliaryConsumptionRate': serializeFloat,
            'ChargingCurve': _ => se_ChargingRateAtChargeLevelList(_),
            'ChargingSetupDuration': [],
            'ConnectorTypes': _json,
            'ConsumptionRateOnAscent': serializeFloat,
            'ConsumptionRateOnDescent': serializeFloat,
            'FreeFlowConsumptionCurve': _ => se_ConsumptionRateAtSpeedList(_),
            'MakeReachable': [],
            'MaxCharge': serializeFloat,
            'MaxChargeDepartingFromChargingStation': serializeFloat,
            'MaxChargingCurrent': serializeFloat,
            'MaxChargingVoltage': serializeFloat,
            'MinChargeArrivingAtChargingStation': serializeFloat,
            'MinChargeArrivingAtDestination': serializeFloat,
            'MinChargeArrivingAtFirstChargingStation': serializeFloat,
            'OriginCharge': serializeFloat,
            'TrafficConsumptionCurve': _ => se_ConsumptionRateAtSpeedList(_),
        });
    };
    const se_RouteMatrixAvoidanceArea = (input, context) => {
        return take(input, {
            'Geometry': _ => se_RouteMatrixAvoidanceAreaGeometry(_),
        });
    };
    const se_RouteMatrixAvoidanceAreaGeometry = (input, context) => {
        return take(input, {
            'BoundingBox': _ => se_BoundingBox(_),
            'Polygon': _ => se_LinearRings(_),
            'PolylinePolygon': _json,
        });
    };
    const se_RouteMatrixAvoidanceAreaList = (input, context) => {
        return input.filter((e) => e != null).map(entry => {
            return se_RouteMatrixAvoidanceArea(entry);
        });
    };
    const se_RouteMatrixAvoidanceOptions = (input, context) => {
        return take(input, {
            'Areas': _ => se_RouteMatrixAvoidanceAreaList(_),
            'CarShuttleTrains': [],
            'ControlledAccessHighways': [],
            'DifficultTurns': [],
            'DirtRoads': [],
            'Ferries': [],
            'TollRoads': [],
            'TollTransponders': [],
            'TruckRoadTypes': _json,
            'Tunnels': [],
            'UTurns': [],
            'ZoneCategories': _json,
        });
    };
    const se_RouteMatrixBoundary = (input, context) => {
        return take(input, {
            'Geometry': _ => se_RouteMatrixBoundaryGeometry(_),
            'Unbounded': [],
        });
    };
    const se_RouteMatrixBoundaryGeometry = (input, context) => {
        return take(input, {
            'AutoCircle': _json,
            'BoundingBox': _ => se_BoundingBox(_),
            'Circle': _ => se_Circle(_),
            'Polygon': _ => se_LinearRings(_),
        });
    };
    const se_RouteMatrixCarOptions = (input, context) => {
        return take(input, {
            'LicensePlate': _json,
            'MaxSpeed': serializeFloat,
            'Occupancy': [],
        });
    };
    const se_RouteMatrixDestination = (input, context) => {
        return take(input, {
            'Options': _ => se_RouteMatrixDestinationOptions(_),
            'Position': _ => se_Position(_),
        });
    };
    const se_RouteMatrixDestinationList = (input, context) => {
        return input.filter((e) => e != null).map(entry => {
            return se_RouteMatrixDestination(entry);
        });
    };
    const se_RouteMatrixDestinationOptions = (input, context) => {
        return take(input, {
            'AvoidActionsForDistance': [],
            'Heading': serializeFloat,
            'Matching': _json,
            'SideOfStreet': _ => se_RouteMatrixSideOfStreetOptions(_),
        });
    };
    const se_RouteMatrixOrigin = (input, context) => {
        return take(input, {
            'Options': _ => se_RouteMatrixOriginOptions(_),
            'Position': _ => se_Position(_),
        });
    };
    const se_RouteMatrixOriginList = (input, context) => {
        return input.filter((e) => e != null).map(entry => {
            return se_RouteMatrixOrigin(entry);
        });
    };
    const se_RouteMatrixOriginOptions = (input, context) => {
        return take(input, {
            'AvoidActionsForDistance': [],
            'Heading': serializeFloat,
            'Matching': _json,
            'SideOfStreet': _ => se_RouteMatrixSideOfStreetOptions(_),
        });
    };
    const se_RouteMatrixScooterOptions = (input, context) => {
        return take(input, {
            'LicensePlate': _json,
            'MaxSpeed': serializeFloat,
            'Occupancy': [],
        });
    };
    const se_RouteMatrixSideOfStreetOptions = (input, context) => {
        return take(input, {
            'Position': _ => se_Position(_),
            'UseWith': [],
        });
    };
    const se_RouteMatrixTravelModeOptions = (input, context) => {
        return take(input, {
            'Car': _ => se_RouteMatrixCarOptions(_),
            'Scooter': _ => se_RouteMatrixScooterOptions(_),
            'Truck': _ => se_RouteMatrixTruckOptions(_),
        });
    };
    const se_RouteMatrixTruckOptions = (input, context) => {
        return take(input, {
            'AxleCount': [],
            'GrossWeight': [],
            'HazardousCargos': _json,
            'Height': [],
            'KpraLength': [],
            'Length': [],
            'LicensePlate': _json,
            'MaxSpeed': serializeFloat,
            'Occupancy': [],
            'PayloadCapacity': [],
            'Trailer': _json,
            'TruckType': [],
            'TunnelRestrictionCode': [],
            'WeightPerAxle': [],
            'WeightPerAxleGroup': _json,
            'Width': [],
        });
    };
    const se_RouteOriginOptions = (input, context) => {
        return take(input, {
            'AvoidActionsForDistance': [],
            'AvoidUTurns': [],
            'Heading': serializeFloat,
            'Matching': _json,
            'SideOfStreet': _ => se_RouteSideOfStreetOptions(_),
        });
    };
    const se_RoutePedestrianOptions = (input, context) => {
        return take(input, {
            'Speed': serializeFloat,
        });
    };
    const se_RouteScooterOptions = (input, context) => {
        return take(input, {
            'EngineType': [],
            'LicensePlate': _json,
            'MaxSpeed': serializeFloat,
            'Occupancy': [],
        });
    };
    const se_RouteSideOfStreetOptions = (input, context) => {
        return take(input, {
            'Position': _ => se_Position(_),
            'UseWith': [],
        });
    };
    const se_RouteTravelModeOptions = (input, context) => {
        return take(input, {
            'Car': _ => se_RouteCarOptions(_),
            'Ev': _ => se_RouteEvOptions(_),
            'Pedestrian': _ => se_RoutePedestrianOptions(_),
            'Scooter': _ => se_RouteScooterOptions(_),
            'Truck': _ => se_RouteTruckOptions(_),
        });
    };
    const se_RouteTruckOptions = (input, context) => {
        return take(input, {
            'AxleCount': [],
            'EngineType': [],
            'GrossWeight': [],
            'HazardousCargos': _json,
            'Height': [],
            'HeightAboveFirstAxle': [],
            'KpraLength': [],
            'Length': [],
            'LicensePlate': _json,
            'MaxSpeed': serializeFloat,
            'Occupancy': [],
            'PayloadCapacity': [],
            'TireCount': [],
            'Trailer': _json,
            'TruckType': [],
            'TunnelRestrictionCode': [],
            'WeightPerAxle': [],
            'WeightPerAxleGroup': _json,
            'Width': [],
        });
    };
    const se_RouteWaypoint = (input, context) => {
        return take(input, {
            'AvoidActionsForDistance': [],
            'AvoidUTurns': [],
            'Heading': serializeFloat,
            'Matching': _json,
            'PassThrough': [],
            'Position': _ => se_Position(_),
            'SideOfStreet': _ => se_RouteSideOfStreetOptions(_),
            'StopDuration': [],
        });
    };
    const se_RouteWaypointList = (input, context) => {
        return input.filter((e) => e != null).map(entry => {
            return se_RouteWaypoint(entry);
        });
    };
    const se_WaypointOptimizationAvoidanceArea = (input, context) => {
        return take(input, {
            'Geometry': _ => se_WaypointOptimizationAvoidanceAreaGeometry(_),
        });
    };
    const se_WaypointOptimizationAvoidanceAreaGeometry = (input, context) => {
        return take(input, {
            'BoundingBox': _ => se_BoundingBox(_),
        });
    };
    const se_WaypointOptimizationAvoidanceAreaList = (input, context) => {
        return input.filter((e) => e != null).map(entry => {
            return se_WaypointOptimizationAvoidanceArea(entry);
        });
    };
    const se_WaypointOptimizationAvoidanceOptions = (input, context) => {
        return take(input, {
            'Areas': _ => se_WaypointOptimizationAvoidanceAreaList(_),
            'CarShuttleTrains': [],
            'ControlledAccessHighways': [],
            'DirtRoads': [],
            'Ferries': [],
            'TollRoads': [],
            'Tunnels': [],
            'UTurns': [],
        });
    };
    const se_WaypointOptimizationDestinationOptions = (input, context) => {
        return take(input, {
            'AccessHours': _json,
            'AppointmentTime': [],
            'Heading': serializeFloat,
            'Id': [],
            'ServiceDuration': [],
            'SideOfStreet': _ => se_WaypointOptimizationSideOfStreetOptions(_),
        });
    };
    const se_WaypointOptimizationPedestrianOptions = (input, context) => {
        return take(input, {
            'Speed': serializeFloat,
        });
    };
    const se_WaypointOptimizationSideOfStreetOptions = (input, context) => {
        return take(input, {
            'Position': _ => se_Position(_),
            'UseWith': [],
        });
    };
    const se_WaypointOptimizationTravelModeOptions = (input, context) => {
        return take(input, {
            'Ev': _json,
            'Pedestrian': _ => se_WaypointOptimizationPedestrianOptions(_),
            'Truck': _json,
        });
    };
    const se_WaypointOptimizationWaypoint = (input, context) => {
        return take(input, {
            'AccessHours': _json,
            'AppointmentTime': [],
            'Before': _json,
            'Heading': serializeFloat,
            'Id': [],
            'Position': _ => se_Position(_),
            'ServiceDuration': [],
            'SideOfStreet': _ => se_WaypointOptimizationSideOfStreetOptions(_),
        });
    };
    const se_WaypointOptimizationWaypointList = (input, context) => {
        return input.filter((e) => e != null).map(entry => {
            return se_WaypointOptimizationWaypoint(entry);
        });
    };
    const se_BoundingBox = (input, context) => {
        return input.filter((e) => e != null).map(entry => {
            return serializeFloat(entry);
        });
    };
    const se_Circle = (input, context) => {
        return take(input, {
            'Center': _ => se_Position(_),
            'Radius': serializeFloat,
        });
    };
    const se_Corridor = (input, context) => {
        return take(input, {
            'LineString': _ => se_LineString(_),
            'Radius': [],
        });
    };
    const se_LinearRing = (input, context) => {
        return input.filter((e) => e != null).map(entry => {
            return se_Position(entry);
        });
    };
    const se_LinearRings = (input, context) => {
        return input.filter((e) => e != null).map(entry => {
            return se_LinearRing(entry);
        });
    };
    const se_LineString = (input, context) => {
        return input.filter((e) => e != null).map(entry => {
            return se_Position(entry);
        });
    };
    const se_Position = (input, context) => {
        return input.filter((e) => e != null).map(entry => {
            return serializeFloat(entry);
        });
    };
    const de_ValidationExceptionField = (output, context) => {
        return take(output, {
            'Message': [, expectString, `message`],
            'Name': [, expectString, `name`],
        });
    };
    const de_ValidationExceptionFieldList = (output, context) => {
        const retVal = (output || []).filter((e) => e != null).map((entry) => {
            return de_ValidationExceptionField(entry);
        });
        return retVal;
    };
    const de_Isoline = (output, context) => {
        return take(output, {
            'Connections': (_) => de_IsolineConnectionList(_),
            'ConsumptionThreshold': expectLong,
            'DistanceThreshold': expectLong,
            'Geometries': (_) => de_IsolineShapeGeometryList(_),
            'TimeThreshold': expectLong,
        });
    };
    const de_IsolineConnection = (output, context) => {
        return take(output, {
            'FromPolygonIndex': expectInt32,
            'Geometry': (_) => de_IsolineConnectionGeometry(_),
            'ToPolygonIndex': expectInt32,
        });
    };
    const de_IsolineConnectionGeometry = (output, context) => {
        return take(output, {
            'LineString': (_) => de_LineString(_),
            'Polyline': expectString,
        });
    };
    const de_IsolineConnectionList = (output, context) => {
        const retVal = (output || []).filter((e) => e != null).map((entry) => {
            return de_IsolineConnection(entry);
        });
        return retVal;
    };
    const de_IsolineList = (output, context) => {
        const retVal = (output || []).filter((e) => e != null).map((entry) => {
            return de_Isoline(entry);
        });
        return retVal;
    };
    const de_IsolineShapeGeometry = (output, context) => {
        return take(output, {
            'Polygon': (_) => de_LinearRings(_),
            'PolylinePolygon': _json,
        });
    };
    const de_IsolineShapeGeometryList = (output, context) => {
        const retVal = (output || []).filter((e) => e != null).map((entry) => {
            return de_IsolineShapeGeometry(entry);
        });
        return retVal;
    };
    const de_RoadSnapSnappedGeometry = (output, context) => {
        return take(output, {
            'LineString': (_) => de_LineString(_),
            'Polyline': expectString,
        });
    };
    const de_RoadSnapSnappedTracePoint = (output, context) => {
        return take(output, {
            'Confidence': limitedParseDouble,
            'OriginalPosition': (_) => de_Position(_),
            'SnappedPosition': (_) => de_Position(_),
        });
    };
    const de_RoadSnapSnappedTracePointList = (output, context) => {
        const retVal = (output || []).filter((e) => e != null).map((entry) => {
            return de_RoadSnapSnappedTracePoint(entry);
        });
        return retVal;
    };
    const de_Route = (output, context) => {
        return take(output, {
            'Legs': (_) => de_RouteLegList(_),
            'MajorRoadLabels': _json,
            'Summary': (_) => de_RouteSummary(_),
        });
    };
    const de_RouteChargeStepDetails = (output, context) => {
        return take(output, {
            'ArrivalCharge': limitedParseDouble,
            'ConsumablePower': limitedParseDouble,
            'DesiredCharge': limitedParseDouble,
        });
    };
    const de_RouteChargingConnector = (output, context) => {
        return take(output, {
            'ConnectorType': expectString,
            'Current': limitedParseDouble,
            'Power': limitedParseDouble,
            'SupplyType': expectString,
            'Voltage': limitedParseDouble,
        });
    };
    const de_RouteChargingStationDetails = (output, context) => {
        return take(output, {
            'Brand': _json,
            'ChargePointOperator': _json,
            'Connector': (_) => de_RouteChargingConnector(_),
        });
    };
    const de_RouteContinueHighwayStepDetails = (output, context) => {
        return take(output, {
            'Intersection': _json,
            'SteeringDirection': expectString,
            'TurnAngle': limitedParseDouble,
            'TurnIntensity': expectString,
        });
    };
    const de_RouteEnterHighwayStepDetails = (output, context) => {
        return take(output, {
            'Intersection': _json,
            'SteeringDirection': expectString,
            'TurnAngle': limitedParseDouble,
            'TurnIntensity': expectString,
        });
    };
    const de_RouteExitStepDetails = (output, context) => {
        return take(output, {
            'Intersection': _json,
            'RelativeExit': expectInt32,
            'SteeringDirection': expectString,
            'TurnAngle': limitedParseDouble,
            'TurnIntensity': expectString,
        });
    };
    const de_RouteFerryArrival = (output, context) => {
        return take(output, {
            'Place': (_) => de_RouteFerryPlace(_),
            'Time': expectString,
        });
    };
    const de_RouteFerryDeparture = (output, context) => {
        return take(output, {
            'Place': (_) => de_RouteFerryPlace(_),
            'Time': expectString,
        });
    };
    const de_RouteFerryLegDetails = (output, context) => {
        return take(output, {
            'AfterTravelSteps': _json,
            'Arrival': (_) => de_RouteFerryArrival(_),
            'BeforeTravelSteps': _json,
            'Departure': (_) => de_RouteFerryDeparture(_),
            'Notices': _json,
            'PassThroughWaypoints': (_) => de_RoutePassThroughWaypointList(_),
            'RouteName': expectString,
            'Spans': _json,
            'Summary': _json,
            'TravelSteps': _json,
        });
    };
    const de_RouteFerryPlace = (output, context) => {
        return take(output, {
            'Name': expectString,
            'OriginalPosition': (_) => de_Position23(_),
            'Position': (_) => de_Position23(_),
            'WaypointIndex': expectInt32,
        });
    };
    const de_RouteKeepStepDetails = (output, context) => {
        return take(output, {
            'Intersection': _json,
            'SteeringDirection': expectString,
            'TurnAngle': limitedParseDouble,
            'TurnIntensity': expectString,
        });
    };
    const de_RouteLeg = (output, context) => {
        return take(output, {
            'FerryLegDetails': (_) => de_RouteFerryLegDetails(_),
            'Geometry': (_) => de_RouteLegGeometry(_),
            'Language': expectString,
            'PedestrianLegDetails': (_) => de_RoutePedestrianLegDetails(_),
            'TravelMode': expectString,
            'Type': expectString,
            'VehicleLegDetails': (_) => de_RouteVehicleLegDetails(_),
        });
    };
    const de_RouteLegGeometry = (output, context) => {
        return take(output, {
            'LineString': (_) => de_LineString(_),
            'Polyline': expectString,
        });
    };
    const de_RouteLegList = (output, context) => {
        const retVal = (output || []).filter((e) => e != null).map((entry) => {
            return de_RouteLeg(entry);
        });
        return retVal;
    };
    const de_RouteList = (output, context) => {
        const retVal = (output || []).filter((e) => e != null).map((entry) => {
            return de_Route(entry);
        });
        return retVal;
    };
    const de_RouteMatrixBoundary = (output, context) => {
        return take(output, {
            'Geometry': (_) => de_RouteMatrixBoundaryGeometry(_),
            'Unbounded': expectBoolean,
        });
    };
    const de_RouteMatrixBoundaryGeometry = (output, context) => {
        return take(output, {
            'AutoCircle': _json,
            'BoundingBox': (_) => de_BoundingBox(_),
            'Circle': (_) => de_Circle(_),
            'Polygon': (_) => de_LinearRings(_),
        });
    };
    const de_RoutePassThroughPlace = (output, context) => {
        return take(output, {
            'OriginalPosition': (_) => de_Position23(_),
            'Position': (_) => de_Position23(_),
            'WaypointIndex': expectInt32,
        });
    };
    const de_RoutePassThroughWaypoint = (output, context) => {
        return take(output, {
            'GeometryOffset': expectInt32,
            'Place': (_) => de_RoutePassThroughPlace(_),
        });
    };
    const de_RoutePassThroughWaypointList = (output, context) => {
        const retVal = (output || []).filter((e) => e != null).map((entry) => {
            return de_RoutePassThroughWaypoint(entry);
        });
        return retVal;
    };
    const de_RoutePedestrianArrival = (output, context) => {
        return take(output, {
            'Place': (_) => de_RoutePedestrianPlace(_),
            'Time': expectString,
        });
    };
    const de_RoutePedestrianDeparture = (output, context) => {
        return take(output, {
            'Place': (_) => de_RoutePedestrianPlace(_),
            'Time': expectString,
        });
    };
    const de_RoutePedestrianLegDetails = (output, context) => {
        return take(output, {
            'AfterTravelSteps': _json,
            'Arrival': (_) => de_RoutePedestrianArrival(_),
            'Departure': (_) => de_RoutePedestrianDeparture(_),
            'Notices': _json,
            'PassThroughWaypoints': (_) => de_RoutePassThroughWaypointList(_),
            'Spans': (_) => de_RoutePedestrianSpanList(_),
            'Summary': _json,
            'TravelSteps': (_) => de_RoutePedestrianTravelStepList(_),
        });
    };
    const de_RoutePedestrianPlace = (output, context) => {
        return take(output, {
            'Name': expectString,
            'OriginalPosition': (_) => de_Position23(_),
            'Position': (_) => de_Position23(_),
            'SideOfStreet': expectString,
            'WaypointIndex': expectInt32,
        });
    };
    const de_RoutePedestrianSpan = (output, context) => {
        return take(output, {
            'BestCaseDuration': expectLong,
            'Country': expectString,
            'Distance': expectLong,
            'Duration': expectLong,
            'DynamicSpeed': (_) => de_RouteSpanDynamicSpeedDetails(_),
            'FunctionalClassification': expectInt32,
            'GeometryOffset': expectInt32,
            'Incidents': _json,
            'Names': _json,
            'PedestrianAccess': _json,
            'Region': expectString,
            'RoadAttributes': _json,
            'RouteNumbers': _json,
            'SpeedLimit': (_) => de_RouteSpanSpeedLimitDetails(_),
            'TypicalDuration': expectLong,
        });
    };
    const de_RoutePedestrianSpanList = (output, context) => {
        const retVal = (output || []).filter((e) => e != null).map((entry) => {
            return de_RoutePedestrianSpan(entry);
        });
        return retVal;
    };
    const de_RoutePedestrianTravelStep = (output, context) => {
        return take(output, {
            'ContinueStepDetails': _json,
            'CurrentRoad': _json,
            'Distance': expectLong,
            'Duration': expectLong,
            'ExitNumber': _json,
            'ExitStepDetails': (_) => de_RouteExitStepDetails(_),
            'GeometryOffset': expectInt32,
            'Instruction': expectString,
            'KeepStepDetails': (_) => de_RouteKeepStepDetails(_),
            'NextRoad': _json,
            'RampStepDetails': (_) => de_RouteRampStepDetails(_),
            'RoundaboutEnterStepDetails': (_) => de_RouteRoundaboutEnterStepDetails(_),
            'RoundaboutExitStepDetails': (_) => de_RouteRoundaboutExitStepDetails(_),
            'RoundaboutPassStepDetails': (_) => de_RouteRoundaboutPassStepDetails(_),
            'Signpost': _json,
            'TurnStepDetails': (_) => de_RouteTurnStepDetails(_),
            'Type': expectString,
            'UTurnStepDetails': (_) => de_RouteUTurnStepDetails(_),
        });
    };
    const de_RoutePedestrianTravelStepList = (output, context) => {
        const retVal = (output || []).filter((e) => e != null).map((entry) => {
            return de_RoutePedestrianTravelStep(entry);
        });
        return retVal;
    };
    const de_RouteRampStepDetails = (output, context) => {
        return take(output, {
            'Intersection': _json,
            'SteeringDirection': expectString,
            'TurnAngle': limitedParseDouble,
            'TurnIntensity': expectString,
        });
    };
    const de_RouteRoundaboutEnterStepDetails = (output, context) => {
        return take(output, {
            'Intersection': _json,
            'SteeringDirection': expectString,
            'TurnAngle': limitedParseDouble,
            'TurnIntensity': expectString,
        });
    };
    const de_RouteRoundaboutExitStepDetails = (output, context) => {
        return take(output, {
            'Intersection': _json,
            'RelativeExit': expectInt32,
            'RoundaboutAngle': limitedParseDouble,
            'SteeringDirection': expectString,
            'TurnAngle': limitedParseDouble,
            'TurnIntensity': expectString,
        });
    };
    const de_RouteRoundaboutPassStepDetails = (output, context) => {
        return take(output, {
            'Intersection': _json,
            'SteeringDirection': expectString,
            'TurnAngle': limitedParseDouble,
            'TurnIntensity': expectString,
        });
    };
    const de_RouteSpanDynamicSpeedDetails = (output, context) => {
        return take(output, {
            'BestCaseSpeed': limitedParseDouble,
            'TurnDuration': expectLong,
            'TypicalSpeed': limitedParseDouble,
        });
    };
    const de_RouteSpanSpeedLimitDetails = (output, context) => {
        return take(output, {
            'MaxSpeed': limitedParseDouble,
            'Unlimited': expectBoolean,
        });
    };
    const de_RouteSummary = (output, context) => {
        return take(output, {
            'Distance': expectLong,
            'Duration': expectLong,
            'Tolls': (_) => de_RouteTollSummary(_),
        });
    };
    const de_RouteToll = (output, context) => {
        return take(output, {
            'Country': expectString,
            'PaymentSites': (_) => de_RouteTollPaymentSiteList(_),
            'Rates': (_) => de_RouteTollRateList(_),
            'Systems': _json,
        });
    };
    const de_RouteTollList = (output, context) => {
        const retVal = (output || []).filter((e) => e != null).map((entry) => {
            return de_RouteToll(entry);
        });
        return retVal;
    };
    const de_RouteTollPaymentSite = (output, context) => {
        return take(output, {
            'Name': expectString,
            'Position': (_) => de_Position23(_),
        });
    };
    const de_RouteTollPaymentSiteList = (output, context) => {
        const retVal = (output || []).filter((e) => e != null).map((entry) => {
            return de_RouteTollPaymentSite(entry);
        });
        return retVal;
    };
    const de_RouteTollPrice = (output, context) => {
        return take(output, {
            'Currency': expectString,
            'Estimate': expectBoolean,
            'PerDuration': expectLong,
            'Range': expectBoolean,
            'RangeValue': (_) => de_RouteTollPriceValueRange(_),
            'Value': limitedParseDouble,
        });
    };
    const de_RouteTollPriceSummary = (output, context) => {
        return take(output, {
            'Currency': expectString,
            'Estimate': expectBoolean,
            'Range': expectBoolean,
            'RangeValue': (_) => de_RouteTollPriceValueRange(_),
            'Value': limitedParseDouble,
        });
    };
    const de_RouteTollPriceValueRange = (output, context) => {
        return take(output, {
            'Max': limitedParseDouble,
            'Min': limitedParseDouble,
        });
    };
    const de_RouteTollRate = (output, context) => {
        return take(output, {
            'ApplicableTimes': expectString,
            'ConvertedPrice': (_) => de_RouteTollPrice(_),
            'Id': expectString,
            'LocalPrice': (_) => de_RouteTollPrice(_),
            'Name': expectString,
            'Pass': _json,
            'PaymentMethods': _json,
            'Transponders': _json,
        });
    };
    const de_RouteTollRateList = (output, context) => {
        const retVal = (output || []).filter((e) => e != null).map((entry) => {
            return de_RouteTollRate(entry);
        });
        return retVal;
    };
    const de_RouteTollSummary = (output, context) => {
        return take(output, {
            'Total': (_) => de_RouteTollPriceSummary(_),
        });
    };
    const de_RouteTurnStepDetails = (output, context) => {
        return take(output, {
            'Intersection': _json,
            'SteeringDirection': expectString,
            'TurnAngle': limitedParseDouble,
            'TurnIntensity': expectString,
        });
    };
    const de_RouteUTurnStepDetails = (output, context) => {
        return take(output, {
            'Intersection': _json,
            'SteeringDirection': expectString,
            'TurnAngle': limitedParseDouble,
            'TurnIntensity': expectString,
        });
    };
    const de_RouteVehicleAfterTravelStep = (output, context) => {
        return take(output, {
            'ChargeStepDetails': (_) => de_RouteChargeStepDetails(_),
            'Duration': expectLong,
            'Instruction': expectString,
            'Type': expectString,
        });
    };
    const de_RouteVehicleAfterTravelStepList = (output, context) => {
        const retVal = (output || []).filter((e) => e != null).map((entry) => {
            return de_RouteVehicleAfterTravelStep(entry);
        });
        return retVal;
    };
    const de_RouteVehicleArrival = (output, context) => {
        return take(output, {
            'Charge': limitedParseDouble,
            'Place': (_) => de_RouteVehiclePlace(_),
            'Time': expectString,
        });
    };
    const de_RouteVehicleDeparture = (output, context) => {
        return take(output, {
            'Charge': limitedParseDouble,
            'Place': (_) => de_RouteVehiclePlace(_),
            'Time': expectString,
        });
    };
    const de_RouteVehicleLegDetails = (output, context) => {
        return take(output, {
            'AfterTravelSteps': (_) => de_RouteVehicleAfterTravelStepList(_),
            'Arrival': (_) => de_RouteVehicleArrival(_),
            'Departure': (_) => de_RouteVehicleDeparture(_),
            'Incidents': _json,
            'Notices': _json,
            'PassThroughWaypoints': (_) => de_RoutePassThroughWaypointList(_),
            'Spans': (_) => de_RouteVehicleSpanList(_),
            'Summary': (_) => de_RouteVehicleSummary(_),
            'TollSystems': _json,
            'Tolls': (_) => de_RouteTollList(_),
            'TravelSteps': (_) => de_RouteVehicleTravelStepList(_),
            'TruckRoadTypes': _json,
            'Zones': _json,
        });
    };
    const de_RouteVehicleOverviewSummary = (output, context) => {
        return take(output, {
            'BestCaseDuration': expectLong,
            'Consumption': limitedParseDouble,
            'Distance': expectLong,
            'Duration': expectLong,
            'TypicalDuration': expectLong,
        });
    };
    const de_RouteVehiclePlace = (output, context) => {
        return take(output, {
            'ChargingStation': expectBoolean,
            'ChargingStationDetails': (_) => de_RouteChargingStationDetails(_),
            'Name': expectString,
            'OriginalPosition': (_) => de_Position23(_),
            'Position': (_) => de_Position23(_),
            'SideOfStreet': expectString,
            'WaypointIndex': expectInt32,
        });
    };
    const de_RouteVehicleSpan = (output, context) => {
        return take(output, {
            'BestCaseDuration': expectLong,
            'CarAccess': _json,
            'Consumption': limitedParseDouble,
            'Country': expectString,
            'Distance': expectLong,
            'Duration': expectLong,
            'DynamicSpeed': (_) => de_RouteSpanDynamicSpeedDetails(_),
            'FunctionalClassification': expectInt32,
            'Gate': expectString,
            'GeometryOffset': expectInt32,
            'Incidents': _json,
            'Names': _json,
            'Notices': _json,
            'RailwayCrossing': expectString,
            'Region': expectString,
            'RoadAttributes': _json,
            'RouteNumbers': _json,
            'ScooterAccess': _json,
            'SpeedLimit': (_) => de_RouteSpanSpeedLimitDetails(_),
            'TollSystems': _json,
            'TruckAccess': _json,
            'TruckRoadTypes': _json,
            'TypicalDuration': expectLong,
            'Zones': _json,
        });
    };
    const de_RouteVehicleSpanList = (output, context) => {
        const retVal = (output || []).filter((e) => e != null).map((entry) => {
            return de_RouteVehicleSpan(entry);
        });
        return retVal;
    };
    const de_RouteVehicleSummary = (output, context) => {
        return take(output, {
            'Overview': (_) => de_RouteVehicleOverviewSummary(_),
            'TravelOnly': (_) => de_RouteVehicleTravelOnlySummary(_),
        });
    };
    const de_RouteVehicleTravelOnlySummary = (output, context) => {
        return take(output, {
            'BestCaseDuration': expectLong,
            'Consumption': limitedParseDouble,
            'Duration': expectLong,
            'TypicalDuration': expectLong,
        });
    };
    const de_RouteVehicleTravelStep = (output, context) => {
        return take(output, {
            'ContinueHighwayStepDetails': (_) => de_RouteContinueHighwayStepDetails(_),
            'ContinueStepDetails': _json,
            'CurrentRoad': _json,
            'Distance': expectLong,
            'Duration': expectLong,
            'EnterHighwayStepDetails': (_) => de_RouteEnterHighwayStepDetails(_),
            'ExitNumber': _json,
            'ExitStepDetails': (_) => de_RouteExitStepDetails(_),
            'GeometryOffset': expectInt32,
            'Instruction': expectString,
            'KeepStepDetails': (_) => de_RouteKeepStepDetails(_),
            'NextRoad': _json,
            'RampStepDetails': (_) => de_RouteRampStepDetails(_),
            'RoundaboutEnterStepDetails': (_) => de_RouteRoundaboutEnterStepDetails(_),
            'RoundaboutExitStepDetails': (_) => de_RouteRoundaboutExitStepDetails(_),
            'RoundaboutPassStepDetails': (_) => de_RouteRoundaboutPassStepDetails(_),
            'Signpost': _json,
            'TurnStepDetails': (_) => de_RouteTurnStepDetails(_),
            'Type': expectString,
            'UTurnStepDetails': (_) => de_RouteUTurnStepDetails(_),
        });
    };
    const de_RouteVehicleTravelStepList = (output, context) => {
        const retVal = (output || []).filter((e) => e != null).map((entry) => {
            return de_RouteVehicleTravelStep(entry);
        });
        return retVal;
    };
    const de_WaypointOptimizationImpedingWaypoint = (output, context) => {
        return take(output, {
            'FailedConstraints': _json,
            'Id': expectString,
            'Position': (_) => de_Position(_),
        });
    };
    const de_WaypointOptimizationImpedingWaypointList = (output, context) => {
        const retVal = (output || []).filter((e) => e != null).map((entry) => {
            return de_WaypointOptimizationImpedingWaypoint(entry);
        });
        return retVal;
    };
    const de_WaypointOptimizationOptimizedWaypoint = (output, context) => {
        return take(output, {
            'ArrivalTime': expectString,
            'ClusterIndex': expectInt32,
            'DepartureTime': expectString,
            'Id': expectString,
            'Position': (_) => de_Position(_),
        });
    };
    const de_WaypointOptimizationOptimizedWaypointList = (output, context) => {
        const retVal = (output || []).filter((e) => e != null).map((entry) => {
            return de_WaypointOptimizationOptimizedWaypoint(entry);
        });
        return retVal;
    };
    const de_BoundingBox = (output, context) => {
        const retVal = (output || []).filter((e) => e != null).map((entry) => {
            return limitedParseDouble(entry);
        });
        return retVal;
    };
    const de_Circle = (output, context) => {
        return take(output, {
            'Center': (_) => de_Position(_),
            'Radius': limitedParseDouble,
        });
    };
    const de_LinearRing = (output, context) => {
        const retVal = (output || []).filter((e) => e != null).map((entry) => {
            return de_Position(entry);
        });
        return retVal;
    };
    const de_LinearRings = (output, context) => {
        const retVal = (output || []).filter((e) => e != null).map((entry) => {
            return de_LinearRing(entry);
        });
        return retVal;
    };
    const de_LineString = (output, context) => {
        const retVal = (output || []).filter((e) => e != null).map((entry) => {
            return de_Position(entry);
        });
        return retVal;
    };
    const de_Position = (output, context) => {
        const retVal = (output || []).filter((e) => e != null).map((entry) => {
            return limitedParseDouble(entry);
        });
        return retVal;
    };
    const de_Position23 = (output, context) => {
        const retVal = (output || []).filter((e) => e != null).map((entry) => {
            return limitedParseDouble(entry);
        });
        return retVal;
    };
    const deserializeMetadata$2 = (output) => ({
        httpStatusCode: output.statusCode,
        requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
        extendedRequestId: output.headers["x-amz-id-2"],
        cfId: output.headers["x-amz-cf-id"],
    });
    const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then(body => context.utf8Encoder(body));
    const isSerializableHeaderValue = (value) => value !== undefined &&
        value !== null &&
        value !== "" &&
        (!Object.getOwnPropertyNames(value).includes("length") ||
            value.length != 0) &&
        (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
    const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then(encoded => {
        if (encoded.length) {
            return JSON.parse(encoded);
        }
        return {};
    });
    const parseErrorBody = async (errorBody, context) => {
        const value = await parseBody(errorBody, context);
        value.message = value.message ?? value.Message;
        return value;
    };
    const loadRestJsonErrorCode = (output, data) => {
        const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
        const sanitizeErrorCode = (rawValue) => {
            let cleanValue = rawValue;
            if (typeof cleanValue === "number") {
                cleanValue = cleanValue.toString();
            }
            if (cleanValue.indexOf(",") >= 0) {
                cleanValue = cleanValue.split(",")[0];
            }
            if (cleanValue.indexOf(":") >= 0) {
                cleanValue = cleanValue.split(":")[0];
            }
            if (cleanValue.indexOf("#") >= 0) {
                cleanValue = cleanValue.split("#")[1];
            }
            return cleanValue;
        };
        const headerKey = findKey(output.headers, "x-amzn-errortype");
        if (headerKey !== undefined) {
            return sanitizeErrorCode(output.headers[headerKey]);
        }
        if (data.code !== undefined) {
            return sanitizeErrorCode(data.code);
        }
        if (data["__type"] !== undefined) {
            return sanitizeErrorCode(data["__type"]);
        }
    };

    const deserializerMiddleware = (options, deserializer) => (next, context) => async (args) => {
        const { response } = await next(args);
        try {
            const parsed = await deserializer(response, options);
            return {
                response,
                output: parsed,
            };
        }
        catch (error) {
            Object.defineProperty(error, "$response", {
                value: response,
            });
            if (!("$metadata" in error)) {
                const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
                error.message += "\n  " + hint;
                if (typeof error.$responseBodyText !== "undefined") {
                    if (error.$response) {
                        error.$response.body = error.$responseBodyText;
                    }
                }
            }
            throw error;
        }
    };

    const serializerMiddleware = (options, serializer) => (next, context) => async (args) => {
        const endpoint = context.endpointV2?.url && options.urlParser
            ? async () => options.urlParser(context.endpointV2.url)
            : options.endpoint;
        if (!endpoint) {
            throw new Error("No valid endpoint provider available.");
        }
        const request = await serializer(args.input, { ...options, endpoint });
        return next({
            ...args,
            request,
        });
    };

    const deserializerMiddlewareOption = {
        name: "deserializerMiddleware",
        step: "deserialize",
        tags: ["DESERIALIZER"],
        override: true,
    };
    const serializerMiddlewareOption = {
        name: "serializerMiddleware",
        step: "serialize",
        tags: ["SERIALIZER"],
        override: true,
    };
    function getSerdePlugin(config, serializer, deserializer) {
        return {
            applyToStack: (commandStack) => {
                commandStack.add(deserializerMiddleware(config, deserializer), deserializerMiddlewareOption);
                commandStack.add(serializerMiddleware(config, serializer), serializerMiddlewareOption);
            },
        };
    }

    class CalculateIsolinesCommand extends Command {
        constructor(input) {
            super();
            this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
            this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
            const stack = clientStack.concat(this.middlewareStack);
            const { logger } = configuration;
            const clientName = "GeoRoutesClient";
            const commandName = "CalculateIsolinesCommand";
            const handlerExecutionContext = {
                logger,
                clientName,
                commandName,
                inputFilterSensitiveLog: CalculateIsolinesRequestFilterSensitiveLog,
                outputFilterSensitiveLog: CalculateIsolinesResponseFilterSensitiveLog,
                [SMITHY_CONTEXT_KEY]: {
                    service: "RoutesService",
                    operation: "CalculateIsolines",
                },
            };
            const { requestHandler } = configuration;
            return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
            return se_CalculateIsolinesCommand(input, context);
        }
        deserialize(output, context) {
            return de_CalculateIsolinesCommand(output, context);
        }
    }

    class CalculateRouteMatrixCommand extends Command {
        constructor(input) {
            super();
            this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
            this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
            const stack = clientStack.concat(this.middlewareStack);
            const { logger } = configuration;
            const clientName = "GeoRoutesClient";
            const commandName = "CalculateRouteMatrixCommand";
            const handlerExecutionContext = {
                logger,
                clientName,
                commandName,
                inputFilterSensitiveLog: CalculateRouteMatrixRequestFilterSensitiveLog,
                outputFilterSensitiveLog: CalculateRouteMatrixResponseFilterSensitiveLog,
                [SMITHY_CONTEXT_KEY]: {
                    service: "RoutesService",
                    operation: "CalculateRouteMatrix",
                },
            };
            const { requestHandler } = configuration;
            return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
            return se_CalculateRouteMatrixCommand(input, context);
        }
        deserialize(output, context) {
            return de_CalculateRouteMatrixCommand(output, context);
        }
    }

    class CalculateRoutesCommand extends Command {
        constructor(input) {
            super();
            this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
            this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
            const stack = clientStack.concat(this.middlewareStack);
            const { logger } = configuration;
            const clientName = "GeoRoutesClient";
            const commandName = "CalculateRoutesCommand";
            const handlerExecutionContext = {
                logger,
                clientName,
                commandName,
                inputFilterSensitiveLog: CalculateRoutesRequestFilterSensitiveLog,
                outputFilterSensitiveLog: CalculateRoutesResponseFilterSensitiveLog,
                [SMITHY_CONTEXT_KEY]: {
                    service: "RoutesService",
                    operation: "CalculateRoutes",
                },
            };
            const { requestHandler } = configuration;
            return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
            return se_CalculateRoutesCommand(input, context);
        }
        deserialize(output, context) {
            return de_CalculateRoutesCommand(output, context);
        }
    }

    class OptimizeWaypointsCommand extends Command {
        constructor(input) {
            super();
            this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
            this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
            const stack = clientStack.concat(this.middlewareStack);
            const { logger } = configuration;
            const clientName = "GeoRoutesClient";
            const commandName = "OptimizeWaypointsCommand";
            const handlerExecutionContext = {
                logger,
                clientName,
                commandName,
                inputFilterSensitiveLog: OptimizeWaypointsRequestFilterSensitiveLog,
                outputFilterSensitiveLog: OptimizeWaypointsResponseFilterSensitiveLog,
                [SMITHY_CONTEXT_KEY]: {
                    service: "RoutesService",
                    operation: "OptimizeWaypoints",
                },
            };
            const { requestHandler } = configuration;
            return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
            return se_OptimizeWaypointsCommand(input, context);
        }
        deserialize(output, context) {
            return de_OptimizeWaypointsCommand(output, context);
        }
    }

    class SnapToRoadsCommand extends Command {
        constructor(input) {
            super();
            this.input = input;
        }
        resolveMiddleware(clientStack, configuration, options) {
            this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
            const stack = clientStack.concat(this.middlewareStack);
            const { logger } = configuration;
            const clientName = "GeoRoutesClient";
            const commandName = "SnapToRoadsCommand";
            const handlerExecutionContext = {
                logger,
                clientName,
                commandName,
                inputFilterSensitiveLog: SnapToRoadsRequestFilterSensitiveLog,
                outputFilterSensitiveLog: SnapToRoadsResponseFilterSensitiveLog,
                [SMITHY_CONTEXT_KEY]: {
                    service: "RoutesService",
                    operation: "SnapToRoads",
                },
            };
            const { requestHandler } = configuration;
            return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
        }
        serialize(input, context) {
            return se_SnapToRoadsCommand(input, context);
        }
        deserialize(output, context) {
            return de_SnapToRoadsCommand(output, context);
        }
    }

    const commands = {
        CalculateIsolinesCommand,
        CalculateRouteMatrixCommand,
        CalculateRoutesCommand,
        OptimizeWaypointsCommand,
        SnapToRoadsCommand,
    };
    class GeoRoutes extends GeoRoutesClient {
    }
    createAggregatedClient(commands, GeoRoutes);

    var index$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        $Command: Command,
        AccessDeniedException: AccessDeniedException,
        CalculateIsolinesCommand: CalculateIsolinesCommand,
        CalculateIsolinesRequestFilterSensitiveLog: CalculateIsolinesRequestFilterSensitiveLog,
        CalculateIsolinesResponseFilterSensitiveLog: CalculateIsolinesResponseFilterSensitiveLog,
        CalculateRouteMatrixCommand: CalculateRouteMatrixCommand,
        CalculateRouteMatrixRequestFilterSensitiveLog: CalculateRouteMatrixRequestFilterSensitiveLog,
        CalculateRouteMatrixResponseFilterSensitiveLog: CalculateRouteMatrixResponseFilterSensitiveLog,
        CalculateRoutesCommand: CalculateRoutesCommand,
        CalculateRoutesRequestFilterSensitiveLog: CalculateRoutesRequestFilterSensitiveLog,
        CalculateRoutesResponseFilterSensitiveLog: CalculateRoutesResponseFilterSensitiveLog,
        CircleFilterSensitiveLog: CircleFilterSensitiveLog,
        CorridorFilterSensitiveLog: CorridorFilterSensitiveLog,
        GeoRoutes: GeoRoutes,
        GeoRoutesClient: GeoRoutesClient,
        GeoRoutesServiceException: GeoRoutesServiceException,
        InternalServerException: InternalServerException,
        IsolineAvoidanceAreaFilterSensitiveLog: IsolineAvoidanceAreaFilterSensitiveLog,
        IsolineAvoidanceAreaGeometryFilterSensitiveLog: IsolineAvoidanceAreaGeometryFilterSensitiveLog,
        IsolineAvoidanceOptionsFilterSensitiveLog: IsolineAvoidanceOptionsFilterSensitiveLog,
        IsolineConnectionFilterSensitiveLog: IsolineConnectionFilterSensitiveLog,
        IsolineConnectionGeometryFilterSensitiveLog: IsolineConnectionGeometryFilterSensitiveLog,
        IsolineDestinationOptionsFilterSensitiveLog: IsolineDestinationOptionsFilterSensitiveLog,
        IsolineFilterSensitiveLog: IsolineFilterSensitiveLog,
        IsolineMatchingOptionsFilterSensitiveLog: IsolineMatchingOptionsFilterSensitiveLog,
        IsolineOriginOptionsFilterSensitiveLog: IsolineOriginOptionsFilterSensitiveLog,
        IsolineShapeGeometryFilterSensitiveLog: IsolineShapeGeometryFilterSensitiveLog,
        IsolineSideOfStreetOptionsFilterSensitiveLog: IsolineSideOfStreetOptionsFilterSensitiveLog,
        OptimizeWaypointsCommand: OptimizeWaypointsCommand,
        OptimizeWaypointsRequestFilterSensitiveLog: OptimizeWaypointsRequestFilterSensitiveLog,
        OptimizeWaypointsResponseFilterSensitiveLog: OptimizeWaypointsResponseFilterSensitiveLog,
        PolylineCorridorFilterSensitiveLog: PolylineCorridorFilterSensitiveLog,
        RoadSnapSnappedGeometryFilterSensitiveLog: RoadSnapSnappedGeometryFilterSensitiveLog,
        RoadSnapSnappedTracePointFilterSensitiveLog: RoadSnapSnappedTracePointFilterSensitiveLog,
        RoadSnapTracePointFilterSensitiveLog: RoadSnapTracePointFilterSensitiveLog,
        RouteAvoidanceAreaFilterSensitiveLog: RouteAvoidanceAreaFilterSensitiveLog,
        RouteAvoidanceAreaGeometryFilterSensitiveLog: RouteAvoidanceAreaGeometryFilterSensitiveLog,
        RouteAvoidanceOptionsFilterSensitiveLog: RouteAvoidanceOptionsFilterSensitiveLog,
        RouteDestinationOptionsFilterSensitiveLog: RouteDestinationOptionsFilterSensitiveLog,
        RouteFerryArrivalFilterSensitiveLog: RouteFerryArrivalFilterSensitiveLog,
        RouteFerryDepartureFilterSensitiveLog: RouteFerryDepartureFilterSensitiveLog,
        RouteFerryLegDetailsFilterSensitiveLog: RouteFerryLegDetailsFilterSensitiveLog,
        RouteFerryPlaceFilterSensitiveLog: RouteFerryPlaceFilterSensitiveLog,
        RouteFilterSensitiveLog: RouteFilterSensitiveLog,
        RouteLegFilterSensitiveLog: RouteLegFilterSensitiveLog,
        RouteLegGeometryFilterSensitiveLog: RouteLegGeometryFilterSensitiveLog,
        RouteMatchingOptionsFilterSensitiveLog: RouteMatchingOptionsFilterSensitiveLog,
        RouteMatrixAvoidanceAreaFilterSensitiveLog: RouteMatrixAvoidanceAreaFilterSensitiveLog,
        RouteMatrixAvoidanceAreaGeometryFilterSensitiveLog: RouteMatrixAvoidanceAreaGeometryFilterSensitiveLog,
        RouteMatrixAvoidanceOptionsFilterSensitiveLog: RouteMatrixAvoidanceOptionsFilterSensitiveLog,
        RouteMatrixBoundaryFilterSensitiveLog: RouteMatrixBoundaryFilterSensitiveLog,
        RouteMatrixBoundaryGeometryFilterSensitiveLog: RouteMatrixBoundaryGeometryFilterSensitiveLog,
        RouteMatrixDestinationFilterSensitiveLog: RouteMatrixDestinationFilterSensitiveLog,
        RouteMatrixDestinationOptionsFilterSensitiveLog: RouteMatrixDestinationOptionsFilterSensitiveLog,
        RouteMatrixMatchingOptionsFilterSensitiveLog: RouteMatrixMatchingOptionsFilterSensitiveLog,
        RouteMatrixOriginFilterSensitiveLog: RouteMatrixOriginFilterSensitiveLog,
        RouteMatrixOriginOptionsFilterSensitiveLog: RouteMatrixOriginOptionsFilterSensitiveLog,
        RouteMatrixSideOfStreetOptionsFilterSensitiveLog: RouteMatrixSideOfStreetOptionsFilterSensitiveLog,
        RouteOriginOptionsFilterSensitiveLog: RouteOriginOptionsFilterSensitiveLog,
        RoutePassThroughPlaceFilterSensitiveLog: RoutePassThroughPlaceFilterSensitiveLog,
        RoutePassThroughWaypointFilterSensitiveLog: RoutePassThroughWaypointFilterSensitiveLog,
        RoutePedestrianArrivalFilterSensitiveLog: RoutePedestrianArrivalFilterSensitiveLog,
        RoutePedestrianDepartureFilterSensitiveLog: RoutePedestrianDepartureFilterSensitiveLog,
        RoutePedestrianLegDetailsFilterSensitiveLog: RoutePedestrianLegDetailsFilterSensitiveLog,
        RoutePedestrianPlaceFilterSensitiveLog: RoutePedestrianPlaceFilterSensitiveLog,
        RouteSideOfStreetOptionsFilterSensitiveLog: RouteSideOfStreetOptionsFilterSensitiveLog,
        RouteTollFilterSensitiveLog: RouteTollFilterSensitiveLog,
        RouteTollPaymentSiteFilterSensitiveLog: RouteTollPaymentSiteFilterSensitiveLog,
        RouteVehicleArrivalFilterSensitiveLog: RouteVehicleArrivalFilterSensitiveLog,
        RouteVehicleDepartureFilterSensitiveLog: RouteVehicleDepartureFilterSensitiveLog,
        RouteVehicleLegDetailsFilterSensitiveLog: RouteVehicleLegDetailsFilterSensitiveLog,
        RouteVehiclePlaceFilterSensitiveLog: RouteVehiclePlaceFilterSensitiveLog,
        RouteWaypointFilterSensitiveLog: RouteWaypointFilterSensitiveLog,
        SnapToRoadsCommand: SnapToRoadsCommand,
        SnapToRoadsRequestFilterSensitiveLog: SnapToRoadsRequestFilterSensitiveLog,
        SnapToRoadsResponseFilterSensitiveLog: SnapToRoadsResponseFilterSensitiveLog,
        ThrottlingException: ThrottlingException,
        ValidationException: ValidationException,
        WaypointOptimizationAvoidanceAreaFilterSensitiveLog: WaypointOptimizationAvoidanceAreaFilterSensitiveLog,
        WaypointOptimizationAvoidanceAreaGeometryFilterSensitiveLog: WaypointOptimizationAvoidanceAreaGeometryFilterSensitiveLog,
        WaypointOptimizationAvoidanceOptionsFilterSensitiveLog: WaypointOptimizationAvoidanceOptionsFilterSensitiveLog,
        WaypointOptimizationDestinationOptionsFilterSensitiveLog: WaypointOptimizationDestinationOptionsFilterSensitiveLog,
        WaypointOptimizationImpedingWaypointFilterSensitiveLog: WaypointOptimizationImpedingWaypointFilterSensitiveLog,
        WaypointOptimizationOptimizedWaypointFilterSensitiveLog: WaypointOptimizationOptimizedWaypointFilterSensitiveLog,
        WaypointOptimizationSideOfStreetOptionsFilterSensitiveLog: WaypointOptimizationSideOfStreetOptionsFilterSensitiveLog,
        WaypointOptimizationWaypointFilterSensitiveLog: WaypointOptimizationWaypointFilterSensitiveLog,
        __Client: Client
    });

    const defaultCognitoIdentityHttpAuthSchemeParametersProvider = async (config, context, input) => {
        return {
            operation: getSmithyContext(context).operation,
            region: (await normalizeProvider$5(config.region)()) ||
                (() => {
                    throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
                })(),
        };
    };
    function createAwsAuthSigv4HttpAuthOption$1(authParameters) {
        return {
            schemeId: "aws.auth#sigv4",
            signingProperties: {
                name: "cognito-identity",
                region: authParameters.region,
            },
            propertiesExtractor: (config, context) => ({
                signingProperties: {
                    config,
                    context,
                },
            }),
        };
    }
    function createSmithyApiNoAuthHttpAuthOption$1(authParameters) {
        return {
            schemeId: "smithy.api#noAuth",
        };
    }
    const defaultCognitoIdentityHttpAuthSchemeProvider = (authParameters) => {
        const options = [];
        switch (authParameters.operation) {
            case "GetCredentialsForIdentity": {
                options.push(createSmithyApiNoAuthHttpAuthOption$1());
                break;
            }
            case "GetId": {
                options.push(createSmithyApiNoAuthHttpAuthOption$1());
                break;
            }
            case "GetOpenIdToken": {
                options.push(createSmithyApiNoAuthHttpAuthOption$1());
                break;
            }
            case "UnlinkIdentity": {
                options.push(createSmithyApiNoAuthHttpAuthOption$1());
                break;
            }
            default: {
                options.push(createAwsAuthSigv4HttpAuthOption$1(authParameters));
            }
        }
        return options;
    };
    const resolveHttpAuthSchemeConfig$1 = (config) => {
        const config_0 = resolveAwsSdkSigV4Config(config);
        return {
            ...config_0,
        };
    };

    const resolveClientEndpointParameters$1 = (options) => {
        return {
            ...options,
            useDualstackEndpoint: options.useDualstackEndpoint ?? false,
            useFipsEndpoint: options.useFipsEndpoint ?? false,
            defaultSigningName: "cognito-identity",
        };
    };
    const commonParams$1 = {
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
    };

    var name$1 = "@aws-sdk/client-cognito-identity";
    var description$1 = "AWS SDK for JavaScript Cognito Identity Client for Node.js, Browser and React Native";
    var version$1 = "3.621.0";
    var scripts$1 = {
    	build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    	"build:cjs": "node ../../scripts/compilation/inline client-cognito-identity",
    	"build:es": "tsc -p tsconfig.es.json",
    	"build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    	"build:types": "tsc -p tsconfig.types.json",
    	"build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    	clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    	"extract:docs": "api-extractor run --local",
    	"generate:client": "node ../../scripts/generate-clients/single-service --solo cognito-identity",
    	"test:e2e": "ts-mocha test/**/*.ispec.ts && karma start karma.conf.js"
    };
    var main$1 = "./dist-cjs/index.js";
    var types$1 = "./dist-types/index.d.ts";
    var module$1 = "./dist-es/index.js";
    var sideEffects$1 = false;
    var dependencies$1 = {
    	"@aws-crypto/sha256-browser": "5.2.0",
    	"@aws-crypto/sha256-js": "5.2.0",
    	"@aws-sdk/client-sso-oidc": "3.621.0",
    	"@aws-sdk/client-sts": "3.621.0",
    	"@aws-sdk/core": "3.621.0",
    	"@aws-sdk/credential-provider-node": "3.621.0",
    	"@aws-sdk/middleware-host-header": "3.620.0",
    	"@aws-sdk/middleware-logger": "3.609.0",
    	"@aws-sdk/middleware-recursion-detection": "3.620.0",
    	"@aws-sdk/middleware-user-agent": "3.620.0",
    	"@aws-sdk/region-config-resolver": "3.614.0",
    	"@aws-sdk/types": "3.609.0",
    	"@aws-sdk/util-endpoints": "3.614.0",
    	"@aws-sdk/util-user-agent-browser": "3.609.0",
    	"@aws-sdk/util-user-agent-node": "3.614.0",
    	"@smithy/config-resolver": "^3.0.5",
    	"@smithy/core": "^2.3.1",
    	"@smithy/fetch-http-handler": "^3.2.4",
    	"@smithy/hash-node": "^3.0.3",
    	"@smithy/invalid-dependency": "^3.0.3",
    	"@smithy/middleware-content-length": "^3.0.5",
    	"@smithy/middleware-endpoint": "^3.1.0",
    	"@smithy/middleware-retry": "^3.0.13",
    	"@smithy/middleware-serde": "^3.0.3",
    	"@smithy/middleware-stack": "^3.0.3",
    	"@smithy/node-config-provider": "^3.1.4",
    	"@smithy/node-http-handler": "^3.1.4",
    	"@smithy/protocol-http": "^4.1.0",
    	"@smithy/smithy-client": "^3.1.11",
    	"@smithy/types": "^3.3.0",
    	"@smithy/url-parser": "^3.0.3",
    	"@smithy/util-base64": "^3.0.0",
    	"@smithy/util-body-length-browser": "^3.0.0",
    	"@smithy/util-body-length-node": "^3.0.0",
    	"@smithy/util-defaults-mode-browser": "^3.0.13",
    	"@smithy/util-defaults-mode-node": "^3.0.13",
    	"@smithy/util-endpoints": "^2.0.5",
    	"@smithy/util-middleware": "^3.0.3",
    	"@smithy/util-retry": "^3.0.3",
    	"@smithy/util-utf8": "^3.0.0",
    	tslib: "^2.6.2"
    };
    var devDependencies$1 = {
    	"@aws-sdk/client-iam": "3.621.0",
    	"@tsconfig/node16": "16.1.3",
    	"@types/chai": "^4.2.11",
    	"@types/mocha": "^8.0.4",
    	"@types/node": "^16.18.96",
    	concurrently: "7.0.0",
    	"downlevel-dts": "0.10.1",
    	rimraf: "3.0.2",
    	typescript: "~4.9.5"
    };
    var engines$1 = {
    	node: ">=16.0.0"
    };
    var typesVersions$1 = {
    	"<4.0": {
    		"dist-types/*": [
    			"dist-types/ts3.4/*"
    		]
    	}
    };
    var files$1 = [
    	"dist-*/**"
    ];
    var author$1 = {
    	name: "AWS SDK for JavaScript Team",
    	url: "https://aws.amazon.com/javascript/"
    };
    var license$1 = "Apache-2.0";
    var browser$1 = {
    	"./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
    };
    var homepage$1 = "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-cognito-identity";
    var repository$1 = {
    	type: "git",
    	url: "https://github.com/aws/aws-sdk-js-v3.git",
    	directory: "clients/client-cognito-identity"
    };
    var packageInfo$1 = {
    	name: name$1,
    	description: description$1,
    	version: version$1,
    	scripts: scripts$1,
    	main: main$1,
    	types: types$1,
    	module: module$1,
    	sideEffects: sideEffects$1,
    	dependencies: dependencies$1,
    	devDependencies: devDependencies$1,
    	engines: engines$1,
    	typesVersions: typesVersions$1,
    	files: files$1,
    	author: author$1,
    	license: license$1,
    	browser: browser$1,
    	"react-native": {
    	"./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
    },
    	homepage: homepage$1,
    	repository: repository$1
    };

    const s$1 = "required", t$1 = "fn", u$1 = "argv", v$1 = "ref";
    const a$1 = true, b$1 = "isSet", c$1 = "booleanEquals", d$1 = "error", e$1 = "endpoint", f$1 = "tree", g$1 = "PartitionResult", h$1 = { [s$1]: false, "type": "String" }, i$1 = { [s$1]: true, "default": false, "type": "Boolean" }, j$1 = { [v$1]: "Endpoint" }, k$1 = { [t$1]: c$1, [u$1]: [{ [v$1]: "UseFIPS" }, true] }, l$1 = { [t$1]: c$1, [u$1]: [{ [v$1]: "UseDualStack" }, true] }, m$1 = {}, n$1 = { [t$1]: "getAttr", [u$1]: [{ [v$1]: g$1 }, "supportsFIPS"] }, o$1 = { [t$1]: c$1, [u$1]: [true, { [t$1]: "getAttr", [u$1]: [{ [v$1]: g$1 }, "supportsDualStack"] }] }, p$1 = [k$1], q$1 = [l$1], r$1 = [{ [v$1]: "Region" }];
    const _data$1 = { version: "1.0", parameters: { Region: h$1, UseDualStack: i$1, UseFIPS: i$1, Endpoint: h$1 }, rules: [{ conditions: [{ [t$1]: b$1, [u$1]: [j$1] }], rules: [{ conditions: p$1, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d$1 }, { conditions: q$1, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d$1 }, { endpoint: { url: j$1, properties: m$1, headers: m$1 }, type: e$1 }], type: f$1 }, { conditions: [{ [t$1]: b$1, [u$1]: r$1 }], rules: [{ conditions: [{ [t$1]: "aws.partition", [u$1]: r$1, assign: g$1 }], rules: [{ conditions: [k$1, l$1], rules: [{ conditions: [{ [t$1]: c$1, [u$1]: [a$1, n$1] }, o$1], rules: [{ endpoint: { url: "https://cognito-identity-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: m$1, headers: m$1 }, type: e$1 }], type: f$1 }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d$1 }], type: f$1 }, { conditions: p$1, rules: [{ conditions: [{ [t$1]: c$1, [u$1]: [n$1, a$1] }], rules: [{ endpoint: { url: "https://cognito-identity-fips.{Region}.{PartitionResult#dnsSuffix}", properties: m$1, headers: m$1 }, type: e$1 }], type: f$1 }, { error: "FIPS is enabled but this partition does not support FIPS", type: d$1 }], type: f$1 }, { conditions: q$1, rules: [{ conditions: [o$1], rules: [{ endpoint: { url: "https://cognito-identity.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: m$1, headers: m$1 }, type: e$1 }], type: f$1 }, { error: "DualStack is enabled but this partition does not support DualStack", type: d$1 }], type: f$1 }, { endpoint: { url: "https://cognito-identity.{Region}.{PartitionResult#dnsSuffix}", properties: m$1, headers: m$1 }, type: e$1 }], type: f$1 }], type: f$1 }, { error: "Invalid Configuration: Missing Region", type: d$1 }] };
    const ruleSet$1 = _data$1;

    const defaultEndpointResolver$1 = (endpointParams, context = {}) => {
        return resolveEndpoint(ruleSet$1, {
            endpointParams: endpointParams,
            logger: context.logger,
        });
    };
    customEndpointFunctions.aws = awsEndpointFunctions;

    const getRuntimeConfig$3 = (config) => {
        return {
            apiVersion: "2014-06-30",
            base64Decoder: config?.base64Decoder ?? fromBase64$3,
            base64Encoder: config?.base64Encoder ?? toBase64$3,
            disableHostPrefix: config?.disableHostPrefix ?? false,
            endpointProvider: config?.endpointProvider ?? defaultEndpointResolver$1,
            extensions: config?.extensions ?? [],
            httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? defaultCognitoIdentityHttpAuthSchemeProvider,
            httpAuthSchemes: config?.httpAuthSchemes ?? [
                {
                    schemeId: "aws.auth#sigv4",
                    identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
                    signer: new AwsSdkSigV4Signer(),
                },
                {
                    schemeId: "smithy.api#noAuth",
                    identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
                    signer: new NoAuthSigner(),
                },
            ],
            logger: config?.logger ?? new NoOpLogger$3(),
            serviceId: config?.serviceId ?? "Cognito Identity",
            urlParser: config?.urlParser ?? parseUrl$3,
            utf8Decoder: config?.utf8Decoder ?? fromUtf8$9,
            utf8Encoder: config?.utf8Encoder ?? toUtf8$6,
        };
    };

    const getRuntimeConfig$2 = (config) => {
        const defaultsMode = resolveDefaultsModeConfig$3(config);
        const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode$3);
        const clientSharedValues = getRuntimeConfig$3(config);
        return {
            ...clientSharedValues,
            ...config,
            runtime: "browser",
            defaultsMode,
            bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength$3,
            credentialDefaultProvider: config?.credentialDefaultProvider ?? ((_) => () => Promise.reject(new Error("Credential is missing"))),
            defaultUserAgentProvider: config?.defaultUserAgentProvider ??
                defaultUserAgent$3({ serviceId: clientSharedValues.serviceId, clientVersion: packageInfo$1.version }),
            maxAttempts: config?.maxAttempts ?? DEFAULT_MAX_ATTEMPTS$3,
            region: config?.region ?? invalidProvider$3("Region is missing"),
            requestHandler: FetchHttpHandler$3.create(config?.requestHandler ?? defaultConfigProvider),
            retryMode: config?.retryMode ?? (async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE$3),
            sha256: config?.sha256 ?? Sha256,
            streamCollector: config?.streamCollector ?? streamCollector$3,
            useDualstackEndpoint: config?.useDualstackEndpoint ?? (() => Promise.resolve(DEFAULT_USE_DUALSTACK_ENDPOINT$3)),
            useFipsEndpoint: config?.useFipsEndpoint ?? (() => Promise.resolve(DEFAULT_USE_FIPS_ENDPOINT$3)),
        };
    };

    const getHttpAuthExtensionConfiguration$1 = (runtimeConfig) => {
        const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
        let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
        let _credentials = runtimeConfig.credentials;
        return {
            setHttpAuthScheme(httpAuthScheme) {
                const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
                if (index === -1) {
                    _httpAuthSchemes.push(httpAuthScheme);
                }
                else {
                    _httpAuthSchemes.splice(index, 1, httpAuthScheme);
                }
            },
            httpAuthSchemes() {
                return _httpAuthSchemes;
            },
            setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
                _httpAuthSchemeProvider = httpAuthSchemeProvider;
            },
            httpAuthSchemeProvider() {
                return _httpAuthSchemeProvider;
            },
            setCredentials(credentials) {
                _credentials = credentials;
            },
            credentials() {
                return _credentials;
            },
        };
    };
    const resolveHttpAuthRuntimeConfig$1 = (config) => {
        return {
            httpAuthSchemes: config.httpAuthSchemes(),
            httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
            credentials: config.credentials(),
        };
    };

    const asPartial$1 = (t) => t;
    const resolveRuntimeExtensions$1 = (runtimeConfig, extensions) => {
        const extensionConfiguration = {
            ...asPartial$1(getAwsRegionExtensionConfiguration$3(runtimeConfig)),
            ...asPartial$1(getDefaultExtensionConfiguration$3(runtimeConfig)),
            ...asPartial$1(getHttpHandlerExtensionConfiguration$3(runtimeConfig)),
            ...asPartial$1(getHttpAuthExtensionConfiguration$1(runtimeConfig)),
        };
        extensions.forEach((extension) => extension.configure(extensionConfiguration));
        return {
            ...runtimeConfig,
            ...resolveAwsRegionExtensionConfiguration$3(extensionConfiguration),
            ...resolveDefaultRuntimeConfig$3(extensionConfiguration),
            ...resolveHttpHandlerRuntimeConfig$3(extensionConfiguration),
            ...resolveHttpAuthRuntimeConfig$1(extensionConfiguration),
        };
    };

    class CognitoIdentityClient extends Client$3 {
        constructor(...[configuration]) {
            const _config_0 = getRuntimeConfig$2(configuration || {});
            const _config_1 = resolveClientEndpointParameters$1(_config_0);
            const _config_2 = resolveRegionConfig$3(_config_1);
            const _config_3 = resolveEndpointConfig(_config_2);
            const _config_4 = resolveHostHeaderConfig$3(_config_3);
            const _config_5 = resolveUserAgentConfig$3(_config_4);
            const _config_6 = resolveRetryConfig$3(_config_5);
            const _config_7 = resolveHttpAuthSchemeConfig$1(_config_6);
            const _config_8 = resolveRuntimeExtensions$1(_config_7, configuration?.extensions || []);
            super(_config_8);
            this.config = _config_8;
            this.middlewareStack.use(getHostHeaderPlugin$3(this.config));
            this.middlewareStack.use(getLoggerPlugin$3(this.config));
            this.middlewareStack.use(getRecursionDetectionPlugin$3(this.config));
            this.middlewareStack.use(getUserAgentPlugin$3(this.config));
            this.middlewareStack.use(getRetryPlugin$3(this.config));
            this.middlewareStack.use(getContentLengthPlugin$3(this.config));
            this.middlewareStack.use(getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
                httpAuthSchemeParametersProvider: this.getDefaultHttpAuthSchemeParametersProvider(),
                identityProviderConfigProvider: this.getIdentityProviderConfigProvider(),
            }));
            this.middlewareStack.use(getHttpSigningPlugin(this.config));
        }
        destroy() {
            super.destroy();
        }
        getDefaultHttpAuthSchemeParametersProvider() {
            return defaultCognitoIdentityHttpAuthSchemeParametersProvider;
        }
        getIdentityProviderConfigProvider() {
            return async (config) => new DefaultIdentityProviderConfig({
                "aws.auth#sigv4": config.credentials,
            });
        }
    }

    class CognitoIdentityServiceException extends ServiceException$3 {
        constructor(options) {
            super(options);
            Object.setPrototypeOf(this, CognitoIdentityServiceException.prototype);
        }
    }

    class InternalErrorException extends CognitoIdentityServiceException {
        constructor(opts) {
            super({
                name: "InternalErrorException",
                $fault: "server",
                ...opts,
            });
            this.name = "InternalErrorException";
            this.$fault = "server";
            Object.setPrototypeOf(this, InternalErrorException.prototype);
        }
    }
    class InvalidParameterException extends CognitoIdentityServiceException {
        constructor(opts) {
            super({
                name: "InvalidParameterException",
                $fault: "client",
                ...opts,
            });
            this.name = "InvalidParameterException";
            this.$fault = "client";
            Object.setPrototypeOf(this, InvalidParameterException.prototype);
        }
    }
    class LimitExceededException extends CognitoIdentityServiceException {
        constructor(opts) {
            super({
                name: "LimitExceededException",
                $fault: "client",
                ...opts,
            });
            this.name = "LimitExceededException";
            this.$fault = "client";
            Object.setPrototypeOf(this, LimitExceededException.prototype);
        }
    }
    class NotAuthorizedException extends CognitoIdentityServiceException {
        constructor(opts) {
            super({
                name: "NotAuthorizedException",
                $fault: "client",
                ...opts,
            });
            this.name = "NotAuthorizedException";
            this.$fault = "client";
            Object.setPrototypeOf(this, NotAuthorizedException.prototype);
        }
    }
    class ResourceConflictException extends CognitoIdentityServiceException {
        constructor(opts) {
            super({
                name: "ResourceConflictException",
                $fault: "client",
                ...opts,
            });
            this.name = "ResourceConflictException";
            this.$fault = "client";
            Object.setPrototypeOf(this, ResourceConflictException.prototype);
        }
    }
    class TooManyRequestsException extends CognitoIdentityServiceException {
        constructor(opts) {
            super({
                name: "TooManyRequestsException",
                $fault: "client",
                ...opts,
            });
            this.name = "TooManyRequestsException";
            this.$fault = "client";
            Object.setPrototypeOf(this, TooManyRequestsException.prototype);
        }
    }
    class ResourceNotFoundException extends CognitoIdentityServiceException {
        constructor(opts) {
            super({
                name: "ResourceNotFoundException",
                $fault: "client",
                ...opts,
            });
            this.name = "ResourceNotFoundException";
            this.$fault = "client";
            Object.setPrototypeOf(this, ResourceNotFoundException.prototype);
        }
    }
    class ExternalServiceException extends CognitoIdentityServiceException {
        constructor(opts) {
            super({
                name: "ExternalServiceException",
                $fault: "client",
                ...opts,
            });
            this.name = "ExternalServiceException";
            this.$fault = "client";
            Object.setPrototypeOf(this, ExternalServiceException.prototype);
        }
    }
    class InvalidIdentityPoolConfigurationException extends CognitoIdentityServiceException {
        constructor(opts) {
            super({
                name: "InvalidIdentityPoolConfigurationException",
                $fault: "client",
                ...opts,
            });
            this.name = "InvalidIdentityPoolConfigurationException";
            this.$fault = "client";
            Object.setPrototypeOf(this, InvalidIdentityPoolConfigurationException.prototype);
        }
    }
    class DeveloperUserAlreadyRegisteredException extends CognitoIdentityServiceException {
        constructor(opts) {
            super({
                name: "DeveloperUserAlreadyRegisteredException",
                $fault: "client",
                ...opts,
            });
            this.name = "DeveloperUserAlreadyRegisteredException";
            this.$fault = "client";
            Object.setPrototypeOf(this, DeveloperUserAlreadyRegisteredException.prototype);
        }
    }
    class ConcurrentModificationException extends CognitoIdentityServiceException {
        constructor(opts) {
            super({
                name: "ConcurrentModificationException",
                $fault: "client",
                ...opts,
            });
            this.name = "ConcurrentModificationException";
            this.$fault = "client";
            Object.setPrototypeOf(this, ConcurrentModificationException.prototype);
        }
    }

    const se_GetCredentialsForIdentityCommand = async (input, context) => {
        const headers = sharedHeaders("GetCredentialsForIdentity");
        let body;
        body = JSON.stringify(_json$2(input));
        return buildHttpRpcRequest$1(context, headers, "/", undefined, body);
    };
    const se_GetIdCommand = async (input, context) => {
        const headers = sharedHeaders("GetId");
        let body;
        body = JSON.stringify(_json$2(input));
        return buildHttpRpcRequest$1(context, headers, "/", undefined, body);
    };
    const de_GetCredentialsForIdentityCommand = async (output, context) => {
        if (output.statusCode >= 300) {
            return de_CommandError$1(output, context);
        }
        const data = await parseJsonBody(output.body, context);
        let contents = {};
        contents = de_GetCredentialsForIdentityResponse(data);
        const response = {
            $metadata: deserializeMetadata$1(output),
            ...contents,
        };
        return response;
    };
    const de_GetIdCommand = async (output, context) => {
        if (output.statusCode >= 300) {
            return de_CommandError$1(output, context);
        }
        const data = await parseJsonBody(output.body, context);
        let contents = {};
        contents = _json$2(data);
        const response = {
            $metadata: deserializeMetadata$1(output),
            ...contents,
        };
        return response;
    };
    const de_CommandError$1 = async (output, context) => {
        const parsedOutput = {
            ...output,
            body: await parseJsonErrorBody(output.body, context),
        };
        const errorCode = loadRestJsonErrorCode$3(output, parsedOutput.body);
        switch (errorCode) {
            case "InternalErrorException":
            case "com.amazonaws.cognitoidentity#InternalErrorException":
                throw await de_InternalErrorExceptionRes(parsedOutput);
            case "InvalidParameterException":
            case "com.amazonaws.cognitoidentity#InvalidParameterException":
                throw await de_InvalidParameterExceptionRes(parsedOutput);
            case "LimitExceededException":
            case "com.amazonaws.cognitoidentity#LimitExceededException":
                throw await de_LimitExceededExceptionRes(parsedOutput);
            case "NotAuthorizedException":
            case "com.amazonaws.cognitoidentity#NotAuthorizedException":
                throw await de_NotAuthorizedExceptionRes(parsedOutput);
            case "ResourceConflictException":
            case "com.amazonaws.cognitoidentity#ResourceConflictException":
                throw await de_ResourceConflictExceptionRes(parsedOutput);
            case "TooManyRequestsException":
            case "com.amazonaws.cognitoidentity#TooManyRequestsException":
                throw await de_TooManyRequestsExceptionRes(parsedOutput);
            case "ResourceNotFoundException":
            case "com.amazonaws.cognitoidentity#ResourceNotFoundException":
                throw await de_ResourceNotFoundExceptionRes(parsedOutput);
            case "ExternalServiceException":
            case "com.amazonaws.cognitoidentity#ExternalServiceException":
                throw await de_ExternalServiceExceptionRes(parsedOutput);
            case "InvalidIdentityPoolConfigurationException":
            case "com.amazonaws.cognitoidentity#InvalidIdentityPoolConfigurationException":
                throw await de_InvalidIdentityPoolConfigurationExceptionRes(parsedOutput);
            case "DeveloperUserAlreadyRegisteredException":
            case "com.amazonaws.cognitoidentity#DeveloperUserAlreadyRegisteredException":
                throw await de_DeveloperUserAlreadyRegisteredExceptionRes(parsedOutput);
            case "ConcurrentModificationException":
            case "com.amazonaws.cognitoidentity#ConcurrentModificationException":
                throw await de_ConcurrentModificationExceptionRes(parsedOutput);
            default:
                const parsedBody = parsedOutput.body;
                return throwDefaultError$1({
                    output,
                    parsedBody,
                    errorCode,
                });
        }
    };
    const de_ConcurrentModificationExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json$2(body);
        const exception = new ConcurrentModificationException({
            $metadata: deserializeMetadata$1(parsedOutput),
            ...deserialized,
        });
        return decorateServiceException$3(exception, body);
    };
    const de_DeveloperUserAlreadyRegisteredExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json$2(body);
        const exception = new DeveloperUserAlreadyRegisteredException({
            $metadata: deserializeMetadata$1(parsedOutput),
            ...deserialized,
        });
        return decorateServiceException$3(exception, body);
    };
    const de_ExternalServiceExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json$2(body);
        const exception = new ExternalServiceException({
            $metadata: deserializeMetadata$1(parsedOutput),
            ...deserialized,
        });
        return decorateServiceException$3(exception, body);
    };
    const de_InternalErrorExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json$2(body);
        const exception = new InternalErrorException({
            $metadata: deserializeMetadata$1(parsedOutput),
            ...deserialized,
        });
        return decorateServiceException$3(exception, body);
    };
    const de_InvalidIdentityPoolConfigurationExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json$2(body);
        const exception = new InvalidIdentityPoolConfigurationException({
            $metadata: deserializeMetadata$1(parsedOutput),
            ...deserialized,
        });
        return decorateServiceException$3(exception, body);
    };
    const de_InvalidParameterExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json$2(body);
        const exception = new InvalidParameterException({
            $metadata: deserializeMetadata$1(parsedOutput),
            ...deserialized,
        });
        return decorateServiceException$3(exception, body);
    };
    const de_LimitExceededExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json$2(body);
        const exception = new LimitExceededException({
            $metadata: deserializeMetadata$1(parsedOutput),
            ...deserialized,
        });
        return decorateServiceException$3(exception, body);
    };
    const de_NotAuthorizedExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json$2(body);
        const exception = new NotAuthorizedException({
            $metadata: deserializeMetadata$1(parsedOutput),
            ...deserialized,
        });
        return decorateServiceException$3(exception, body);
    };
    const de_ResourceConflictExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json$2(body);
        const exception = new ResourceConflictException({
            $metadata: deserializeMetadata$1(parsedOutput),
            ...deserialized,
        });
        return decorateServiceException$3(exception, body);
    };
    const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json$2(body);
        const exception = new ResourceNotFoundException({
            $metadata: deserializeMetadata$1(parsedOutput),
            ...deserialized,
        });
        return decorateServiceException$3(exception, body);
    };
    const de_TooManyRequestsExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = _json$2(body);
        const exception = new TooManyRequestsException({
            $metadata: deserializeMetadata$1(parsedOutput),
            ...deserialized,
        });
        return decorateServiceException$3(exception, body);
    };
    const de_Credentials$1 = (output, context) => {
        return take$3(output, {
            AccessKeyId: expectString$3,
            Expiration: (_) => expectNonNull$3(parseEpochTimestamp(expectNumber$2(_))),
            SecretKey: expectString$3,
            SessionToken: expectString$3,
        });
    };
    const de_GetCredentialsForIdentityResponse = (output, context) => {
        return take$3(output, {
            Credentials: (_) => de_Credentials$1(_),
            IdentityId: expectString$3,
        });
    };
    const deserializeMetadata$1 = (output) => ({
        httpStatusCode: output.statusCode,
        requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
        extendedRequestId: output.headers["x-amz-id-2"],
        cfId: output.headers["x-amz-cf-id"],
    });
    const throwDefaultError$1 = withBaseException$3(CognitoIdentityServiceException);
    const buildHttpRpcRequest$1 = async (context, headers, path, resolvedHostname, body) => {
        const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
        const contents = {
            protocol,
            hostname,
            port,
            method: "POST",
            path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
            headers,
        };
        if (body !== undefined) {
            contents.body = body;
        }
        return new HttpRequest$4(contents);
    };
    function sharedHeaders(operation) {
        return {
            "content-type": "application/x-amz-json-1.1",
            "x-amz-target": `AWSCognitoIdentityService.${operation}`,
        };
    }

    class GetCredentialsForIdentityCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$1,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("AWSCognitoIdentityService", "GetCredentialsForIdentity", {})
        .n("CognitoIdentityClient", "GetCredentialsForIdentityCommand")
        .f(void 0, void 0)
        .ser(se_GetCredentialsForIdentityCommand)
        .de(de_GetCredentialsForIdentityCommand)
        .build() {
    }

    class GetIdCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams$1,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("AWSCognitoIdentityService", "GetId", {})
        .n("CognitoIdentityClient", "GetIdCommand")
        .f(void 0, void 0)
        .ser(se_GetIdCommand)
        .de(de_GetIdCommand)
        .build() {
    }

    var loadCognitoIdentity = /*#__PURE__*/Object.freeze({
        __proto__: null,
        CognitoIdentityClient: CognitoIdentityClient,
        GetCredentialsForIdentityCommand: GetCredentialsForIdentityCommand,
        GetIdCommand: GetIdCommand
    });

    const defaultSTSHttpAuthSchemeParametersProvider = async (config, context, input) => {
        return {
            operation: getSmithyContext(context).operation,
            region: (await normalizeProvider$5(config.region)()) ||
                (() => {
                    throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
                })(),
        };
    };
    function createAwsAuthSigv4HttpAuthOption(authParameters) {
        return {
            schemeId: "aws.auth#sigv4",
            signingProperties: {
                name: "sts",
                region: authParameters.region,
            },
            propertiesExtractor: (config, context) => ({
                signingProperties: {
                    config,
                    context,
                },
            }),
        };
    }
    function createSmithyApiNoAuthHttpAuthOption(authParameters) {
        return {
            schemeId: "smithy.api#noAuth",
        };
    }
    const defaultSTSHttpAuthSchemeProvider = (authParameters) => {
        const options = [];
        switch (authParameters.operation) {
            case "AssumeRoleWithSAML": {
                options.push(createSmithyApiNoAuthHttpAuthOption());
                break;
            }
            case "AssumeRoleWithWebIdentity": {
                options.push(createSmithyApiNoAuthHttpAuthOption());
                break;
            }
            default: {
                options.push(createAwsAuthSigv4HttpAuthOption(authParameters));
            }
        }
        return options;
    };
    const resolveStsAuthConfig = (input) => ({
        ...input,
        stsClientCtor: STSClient,
    });
    const resolveHttpAuthSchemeConfig = (config) => {
        const config_0 = resolveStsAuthConfig(config);
        const config_1 = resolveAwsSdkSigV4Config(config_0);
        return {
            ...config_1,
        };
    };

    const resolveClientEndpointParameters = (options) => {
        return {
            ...options,
            useDualstackEndpoint: options.useDualstackEndpoint ?? false,
            useFipsEndpoint: options.useFipsEndpoint ?? false,
            useGlobalEndpoint: options.useGlobalEndpoint ?? false,
            defaultSigningName: "sts",
        };
    };
    const commonParams = {
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
    };

    var name = "@aws-sdk/client-sts";
    var description = "AWS SDK for JavaScript Sts Client for Node.js, Browser and React Native";
    var version = "3.621.0";
    var scripts = {
    	build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    	"build:cjs": "node ../../scripts/compilation/inline client-sts",
    	"build:es": "tsc -p tsconfig.es.json",
    	"build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    	"build:types": "rimraf ./dist-types tsconfig.types.tsbuildinfo && tsc -p tsconfig.types.json",
    	"build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    	clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    	"extract:docs": "api-extractor run --local",
    	"generate:client": "node ../../scripts/generate-clients/single-service --solo sts",
    	test: "yarn test:unit",
    	"test:unit": "jest"
    };
    var main = "./dist-cjs/index.js";
    var types = "./dist-types/index.d.ts";
    var module = "./dist-es/index.js";
    var sideEffects = false;
    var dependencies = {
    	"@aws-crypto/sha256-browser": "5.2.0",
    	"@aws-crypto/sha256-js": "5.2.0",
    	"@aws-sdk/client-sso-oidc": "3.621.0",
    	"@aws-sdk/core": "3.621.0",
    	"@aws-sdk/credential-provider-node": "3.621.0",
    	"@aws-sdk/middleware-host-header": "3.620.0",
    	"@aws-sdk/middleware-logger": "3.609.0",
    	"@aws-sdk/middleware-recursion-detection": "3.620.0",
    	"@aws-sdk/middleware-user-agent": "3.620.0",
    	"@aws-sdk/region-config-resolver": "3.614.0",
    	"@aws-sdk/types": "3.609.0",
    	"@aws-sdk/util-endpoints": "3.614.0",
    	"@aws-sdk/util-user-agent-browser": "3.609.0",
    	"@aws-sdk/util-user-agent-node": "3.614.0",
    	"@smithy/config-resolver": "^3.0.5",
    	"@smithy/core": "^2.3.1",
    	"@smithy/fetch-http-handler": "^3.2.4",
    	"@smithy/hash-node": "^3.0.3",
    	"@smithy/invalid-dependency": "^3.0.3",
    	"@smithy/middleware-content-length": "^3.0.5",
    	"@smithy/middleware-endpoint": "^3.1.0",
    	"@smithy/middleware-retry": "^3.0.13",
    	"@smithy/middleware-serde": "^3.0.3",
    	"@smithy/middleware-stack": "^3.0.3",
    	"@smithy/node-config-provider": "^3.1.4",
    	"@smithy/node-http-handler": "^3.1.4",
    	"@smithy/protocol-http": "^4.1.0",
    	"@smithy/smithy-client": "^3.1.11",
    	"@smithy/types": "^3.3.0",
    	"@smithy/url-parser": "^3.0.3",
    	"@smithy/util-base64": "^3.0.0",
    	"@smithy/util-body-length-browser": "^3.0.0",
    	"@smithy/util-body-length-node": "^3.0.0",
    	"@smithy/util-defaults-mode-browser": "^3.0.13",
    	"@smithy/util-defaults-mode-node": "^3.0.13",
    	"@smithy/util-endpoints": "^2.0.5",
    	"@smithy/util-middleware": "^3.0.3",
    	"@smithy/util-retry": "^3.0.3",
    	"@smithy/util-utf8": "^3.0.0",
    	tslib: "^2.6.2"
    };
    var devDependencies = {
    	"@tsconfig/node16": "16.1.3",
    	"@types/node": "^16.18.96",
    	concurrently: "7.0.0",
    	"downlevel-dts": "0.10.1",
    	rimraf: "3.0.2",
    	typescript: "~4.9.5"
    };
    var engines = {
    	node: ">=16.0.0"
    };
    var typesVersions = {
    	"<4.0": {
    		"dist-types/*": [
    			"dist-types/ts3.4/*"
    		]
    	}
    };
    var files = [
    	"dist-*/**"
    ];
    var author = {
    	name: "AWS SDK for JavaScript Team",
    	url: "https://aws.amazon.com/javascript/"
    };
    var license = "Apache-2.0";
    var browser = {
    	"./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
    };
    var homepage = "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sts";
    var repository = {
    	type: "git",
    	url: "https://github.com/aws/aws-sdk-js-v3.git",
    	directory: "clients/client-sts"
    };
    var packageInfo = {
    	name: name,
    	description: description,
    	version: version,
    	scripts: scripts,
    	main: main,
    	types: types,
    	module: module,
    	sideEffects: sideEffects,
    	dependencies: dependencies,
    	devDependencies: devDependencies,
    	engines: engines,
    	typesVersions: typesVersions,
    	files: files,
    	author: author,
    	license: license,
    	browser: browser,
    	"react-native": {
    	"./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
    },
    	homepage: homepage,
    	repository: repository
    };

    const F = "required", G = "type", H = "fn", I = "argv", J = "ref";
    const a = false, b = true, c = "booleanEquals", d = "stringEquals", e = "sigv4", f = "sts", g = "us-east-1", h = "endpoint", i = "https://sts.{Region}.{PartitionResult#dnsSuffix}", j = "tree", k = "error", l = "getAttr", m = { [F]: false, [G]: "String" }, n = { [F]: true, "default": false, [G]: "Boolean" }, o = { [J]: "Endpoint" }, p = { [H]: "isSet", [I]: [{ [J]: "Region" }] }, q = { [J]: "Region" }, r = { [H]: "aws.partition", [I]: [q], "assign": "PartitionResult" }, s = { [J]: "UseFIPS" }, t = { [J]: "UseDualStack" }, u = { "url": "https://sts.amazonaws.com", "properties": { "authSchemes": [{ "name": e, "signingName": f, "signingRegion": g }] }, "headers": {} }, v = {}, w = { "conditions": [{ [H]: d, [I]: [q, "aws-global"] }], [h]: u, [G]: h }, x = { [H]: c, [I]: [s, true] }, y = { [H]: c, [I]: [t, true] }, z = { [H]: l, [I]: [{ [J]: "PartitionResult" }, "supportsFIPS"] }, A = { [J]: "PartitionResult" }, B = { [H]: c, [I]: [true, { [H]: l, [I]: [A, "supportsDualStack"] }] }, C = [{ [H]: "isSet", [I]: [o] }], D = [x], E = [y];
    const _data = { version: "1.0", parameters: { Region: m, UseDualStack: n, UseFIPS: n, Endpoint: m, UseGlobalEndpoint: n }, rules: [{ conditions: [{ [H]: c, [I]: [{ [J]: "UseGlobalEndpoint" }, b] }, { [H]: "not", [I]: C }, p, r, { [H]: c, [I]: [s, a] }, { [H]: c, [I]: [t, a] }], rules: [{ conditions: [{ [H]: d, [I]: [q, "ap-northeast-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "ap-south-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "ap-southeast-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "ap-southeast-2"] }], endpoint: u, [G]: h }, w, { conditions: [{ [H]: d, [I]: [q, "ca-central-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "eu-central-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "eu-north-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "eu-west-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "eu-west-2"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "eu-west-3"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "sa-east-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, g] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "us-east-2"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "us-west-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "us-west-2"] }], endpoint: u, [G]: h }, { endpoint: { url: i, properties: { authSchemes: [{ name: e, signingName: f, signingRegion: "{Region}" }] }, headers: v }, [G]: h }], [G]: j }, { conditions: C, rules: [{ conditions: D, error: "Invalid Configuration: FIPS and custom endpoint are not supported", [G]: k }, { conditions: E, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", [G]: k }, { endpoint: { url: o, properties: v, headers: v }, [G]: h }], [G]: j }, { conditions: [p], rules: [{ conditions: [r], rules: [{ conditions: [x, y], rules: [{ conditions: [{ [H]: c, [I]: [b, z] }, B], rules: [{ endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: v, headers: v }, [G]: h }], [G]: j }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", [G]: k }], [G]: j }, { conditions: D, rules: [{ conditions: [{ [H]: c, [I]: [z, b] }], rules: [{ conditions: [{ [H]: d, [I]: [{ [H]: l, [I]: [A, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://sts.{Region}.amazonaws.com", properties: v, headers: v }, [G]: h }, { endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dnsSuffix}", properties: v, headers: v }, [G]: h }], [G]: j }, { error: "FIPS is enabled but this partition does not support FIPS", [G]: k }], [G]: j }, { conditions: E, rules: [{ conditions: [B], rules: [{ endpoint: { url: "https://sts.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: v, headers: v }, [G]: h }], [G]: j }, { error: "DualStack is enabled but this partition does not support DualStack", [G]: k }], [G]: j }, w, { endpoint: { url: i, properties: v, headers: v }, [G]: h }], [G]: j }], [G]: j }, { error: "Invalid Configuration: Missing Region", [G]: k }] };
    const ruleSet = _data;

    const defaultEndpointResolver = (endpointParams, context = {}) => {
        return resolveEndpoint(ruleSet, {
            endpointParams: endpointParams,
            logger: context.logger,
        });
    };
    customEndpointFunctions.aws = awsEndpointFunctions;

    const getRuntimeConfig$1 = (config) => {
        return {
            apiVersion: "2011-06-15",
            base64Decoder: config?.base64Decoder ?? fromBase64$3,
            base64Encoder: config?.base64Encoder ?? toBase64$3,
            disableHostPrefix: config?.disableHostPrefix ?? false,
            endpointProvider: config?.endpointProvider ?? defaultEndpointResolver,
            extensions: config?.extensions ?? [],
            httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? defaultSTSHttpAuthSchemeProvider,
            httpAuthSchemes: config?.httpAuthSchemes ?? [
                {
                    schemeId: "aws.auth#sigv4",
                    identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
                    signer: new AwsSdkSigV4Signer(),
                },
                {
                    schemeId: "smithy.api#noAuth",
                    identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
                    signer: new NoAuthSigner(),
                },
            ],
            logger: config?.logger ?? new NoOpLogger$3(),
            serviceId: config?.serviceId ?? "STS",
            urlParser: config?.urlParser ?? parseUrl$3,
            utf8Decoder: config?.utf8Decoder ?? fromUtf8$9,
            utf8Encoder: config?.utf8Encoder ?? toUtf8$6,
        };
    };

    const getRuntimeConfig = (config) => {
        const defaultsMode = resolveDefaultsModeConfig$3(config);
        const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode$3);
        const clientSharedValues = getRuntimeConfig$1(config);
        return {
            ...clientSharedValues,
            ...config,
            runtime: "browser",
            defaultsMode,
            bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength$3,
            credentialDefaultProvider: config?.credentialDefaultProvider ?? ((_) => () => Promise.reject(new Error("Credential is missing"))),
            defaultUserAgentProvider: config?.defaultUserAgentProvider ??
                defaultUserAgent$3({ serviceId: clientSharedValues.serviceId, clientVersion: packageInfo.version }),
            maxAttempts: config?.maxAttempts ?? DEFAULT_MAX_ATTEMPTS$3,
            region: config?.region ?? invalidProvider$3("Region is missing"),
            requestHandler: FetchHttpHandler$3.create(config?.requestHandler ?? defaultConfigProvider),
            retryMode: config?.retryMode ?? (async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE$3),
            sha256: config?.sha256 ?? Sha256,
            streamCollector: config?.streamCollector ?? streamCollector$3,
            useDualstackEndpoint: config?.useDualstackEndpoint ?? (() => Promise.resolve(DEFAULT_USE_DUALSTACK_ENDPOINT$3)),
            useFipsEndpoint: config?.useFipsEndpoint ?? (() => Promise.resolve(DEFAULT_USE_FIPS_ENDPOINT$3)),
        };
    };

    const getHttpAuthExtensionConfiguration = (runtimeConfig) => {
        const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
        let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
        let _credentials = runtimeConfig.credentials;
        return {
            setHttpAuthScheme(httpAuthScheme) {
                const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
                if (index === -1) {
                    _httpAuthSchemes.push(httpAuthScheme);
                }
                else {
                    _httpAuthSchemes.splice(index, 1, httpAuthScheme);
                }
            },
            httpAuthSchemes() {
                return _httpAuthSchemes;
            },
            setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
                _httpAuthSchemeProvider = httpAuthSchemeProvider;
            },
            httpAuthSchemeProvider() {
                return _httpAuthSchemeProvider;
            },
            setCredentials(credentials) {
                _credentials = credentials;
            },
            credentials() {
                return _credentials;
            },
        };
    };
    const resolveHttpAuthRuntimeConfig = (config) => {
        return {
            httpAuthSchemes: config.httpAuthSchemes(),
            httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
            credentials: config.credentials(),
        };
    };

    const asPartial = (t) => t;
    const resolveRuntimeExtensions = (runtimeConfig, extensions) => {
        const extensionConfiguration = {
            ...asPartial(getAwsRegionExtensionConfiguration$3(runtimeConfig)),
            ...asPartial(getDefaultExtensionConfiguration$3(runtimeConfig)),
            ...asPartial(getHttpHandlerExtensionConfiguration$3(runtimeConfig)),
            ...asPartial(getHttpAuthExtensionConfiguration(runtimeConfig)),
        };
        extensions.forEach((extension) => extension.configure(extensionConfiguration));
        return {
            ...runtimeConfig,
            ...resolveAwsRegionExtensionConfiguration$3(extensionConfiguration),
            ...resolveDefaultRuntimeConfig$3(extensionConfiguration),
            ...resolveHttpHandlerRuntimeConfig$3(extensionConfiguration),
            ...resolveHttpAuthRuntimeConfig(extensionConfiguration),
        };
    };

    class STSClient extends Client$3 {
        constructor(...[configuration]) {
            const _config_0 = getRuntimeConfig(configuration || {});
            const _config_1 = resolveClientEndpointParameters(_config_0);
            const _config_2 = resolveRegionConfig$3(_config_1);
            const _config_3 = resolveEndpointConfig(_config_2);
            const _config_4 = resolveHostHeaderConfig$3(_config_3);
            const _config_5 = resolveUserAgentConfig$3(_config_4);
            const _config_6 = resolveRetryConfig$3(_config_5);
            const _config_7 = resolveHttpAuthSchemeConfig(_config_6);
            const _config_8 = resolveRuntimeExtensions(_config_7, configuration?.extensions || []);
            super(_config_8);
            this.config = _config_8;
            this.middlewareStack.use(getHostHeaderPlugin$3(this.config));
            this.middlewareStack.use(getLoggerPlugin$3(this.config));
            this.middlewareStack.use(getRecursionDetectionPlugin$3(this.config));
            this.middlewareStack.use(getUserAgentPlugin$3(this.config));
            this.middlewareStack.use(getRetryPlugin$3(this.config));
            this.middlewareStack.use(getContentLengthPlugin$3(this.config));
            this.middlewareStack.use(getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
                httpAuthSchemeParametersProvider: this.getDefaultHttpAuthSchemeParametersProvider(),
                identityProviderConfigProvider: this.getIdentityProviderConfigProvider(),
            }));
            this.middlewareStack.use(getHttpSigningPlugin(this.config));
        }
        destroy() {
            super.destroy();
        }
        getDefaultHttpAuthSchemeParametersProvider() {
            return defaultSTSHttpAuthSchemeParametersProvider;
        }
        getIdentityProviderConfigProvider() {
            return async (config) => new DefaultIdentityProviderConfig({
                "aws.auth#sigv4": config.credentials,
            });
        }
    }

    class STSServiceException extends ServiceException$3 {
        constructor(options) {
            super(options);
            Object.setPrototypeOf(this, STSServiceException.prototype);
        }
    }

    class ExpiredTokenException extends STSServiceException {
        constructor(opts) {
            super({
                name: "ExpiredTokenException",
                $fault: "client",
                ...opts,
            });
            this.name = "ExpiredTokenException";
            this.$fault = "client";
            Object.setPrototypeOf(this, ExpiredTokenException.prototype);
        }
    }
    class MalformedPolicyDocumentException extends STSServiceException {
        constructor(opts) {
            super({
                name: "MalformedPolicyDocumentException",
                $fault: "client",
                ...opts,
            });
            this.name = "MalformedPolicyDocumentException";
            this.$fault = "client";
            Object.setPrototypeOf(this, MalformedPolicyDocumentException.prototype);
        }
    }
    class PackedPolicyTooLargeException extends STSServiceException {
        constructor(opts) {
            super({
                name: "PackedPolicyTooLargeException",
                $fault: "client",
                ...opts,
            });
            this.name = "PackedPolicyTooLargeException";
            this.$fault = "client";
            Object.setPrototypeOf(this, PackedPolicyTooLargeException.prototype);
        }
    }
    class RegionDisabledException extends STSServiceException {
        constructor(opts) {
            super({
                name: "RegionDisabledException",
                $fault: "client",
                ...opts,
            });
            this.name = "RegionDisabledException";
            this.$fault = "client";
            Object.setPrototypeOf(this, RegionDisabledException.prototype);
        }
    }
    class IDPRejectedClaimException extends STSServiceException {
        constructor(opts) {
            super({
                name: "IDPRejectedClaimException",
                $fault: "client",
                ...opts,
            });
            this.name = "IDPRejectedClaimException";
            this.$fault = "client";
            Object.setPrototypeOf(this, IDPRejectedClaimException.prototype);
        }
    }
    class InvalidIdentityTokenException extends STSServiceException {
        constructor(opts) {
            super({
                name: "InvalidIdentityTokenException",
                $fault: "client",
                ...opts,
            });
            this.name = "InvalidIdentityTokenException";
            this.$fault = "client";
            Object.setPrototypeOf(this, InvalidIdentityTokenException.prototype);
        }
    }
    class IDPCommunicationErrorException extends STSServiceException {
        constructor(opts) {
            super({
                name: "IDPCommunicationErrorException",
                $fault: "client",
                ...opts,
            });
            this.name = "IDPCommunicationErrorException";
            this.$fault = "client";
            Object.setPrototypeOf(this, IDPCommunicationErrorException.prototype);
        }
    }
    class InvalidAuthorizationMessageException extends STSServiceException {
        constructor(opts) {
            super({
                name: "InvalidAuthorizationMessageException",
                $fault: "client",
                ...opts,
            });
            this.name = "InvalidAuthorizationMessageException";
            this.$fault = "client";
            Object.setPrototypeOf(this, InvalidAuthorizationMessageException.prototype);
        }
    }
    const CredentialsFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.SecretAccessKey && { SecretAccessKey: SENSITIVE_STRING$3 }),
    });
    const AssumeRoleResponseFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Credentials && { Credentials: CredentialsFilterSensitiveLog(obj.Credentials) }),
    });
    const AssumeRoleWithWebIdentityRequestFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.WebIdentityToken && { WebIdentityToken: SENSITIVE_STRING$3 }),
    });
    const AssumeRoleWithWebIdentityResponseFilterSensitiveLog = (obj) => ({
        ...obj,
        ...(obj.Credentials && { Credentials: CredentialsFilterSensitiveLog(obj.Credentials) }),
    });

    const se_AssumeRoleCommand = async (input, context) => {
        const headers = SHARED_HEADERS;
        let body;
        body = buildFormUrlencodedString({
            ...se_AssumeRoleRequest(input),
            [_A]: _AR,
            [_V]: _,
        });
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
    };
    const se_AssumeRoleWithWebIdentityCommand = async (input, context) => {
        const headers = SHARED_HEADERS;
        let body;
        body = buildFormUrlencodedString({
            ...se_AssumeRoleWithWebIdentityRequest(input),
            [_A]: _ARWWI,
            [_V]: _,
        });
        return buildHttpRpcRequest(context, headers, "/", undefined, body);
    };
    const de_AssumeRoleCommand = async (output, context) => {
        if (output.statusCode >= 300) {
            return de_CommandError(output, context);
        }
        const data = await parseXmlBody(output.body, context);
        let contents = {};
        contents = de_AssumeRoleResponse(data.AssumeRoleResult);
        const response = {
            $metadata: deserializeMetadata(output),
            ...contents,
        };
        return response;
    };
    const de_AssumeRoleWithWebIdentityCommand = async (output, context) => {
        if (output.statusCode >= 300) {
            return de_CommandError(output, context);
        }
        const data = await parseXmlBody(output.body, context);
        let contents = {};
        contents = de_AssumeRoleWithWebIdentityResponse(data.AssumeRoleWithWebIdentityResult);
        const response = {
            $metadata: deserializeMetadata(output),
            ...contents,
        };
        return response;
    };
    const de_CommandError = async (output, context) => {
        const parsedOutput = {
            ...output,
            body: await parseXmlErrorBody(output.body, context),
        };
        const errorCode = loadQueryErrorCode(output, parsedOutput.body);
        switch (errorCode) {
            case "ExpiredTokenException":
            case "com.amazonaws.sts#ExpiredTokenException":
                throw await de_ExpiredTokenExceptionRes(parsedOutput);
            case "MalformedPolicyDocument":
            case "com.amazonaws.sts#MalformedPolicyDocumentException":
                throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput);
            case "PackedPolicyTooLarge":
            case "com.amazonaws.sts#PackedPolicyTooLargeException":
                throw await de_PackedPolicyTooLargeExceptionRes(parsedOutput);
            case "RegionDisabledException":
            case "com.amazonaws.sts#RegionDisabledException":
                throw await de_RegionDisabledExceptionRes(parsedOutput);
            case "IDPRejectedClaim":
            case "com.amazonaws.sts#IDPRejectedClaimException":
                throw await de_IDPRejectedClaimExceptionRes(parsedOutput);
            case "InvalidIdentityToken":
            case "com.amazonaws.sts#InvalidIdentityTokenException":
                throw await de_InvalidIdentityTokenExceptionRes(parsedOutput);
            case "IDPCommunicationError":
            case "com.amazonaws.sts#IDPCommunicationErrorException":
                throw await de_IDPCommunicationErrorExceptionRes(parsedOutput);
            case "InvalidAuthorizationMessageException":
            case "com.amazonaws.sts#InvalidAuthorizationMessageException":
                throw await de_InvalidAuthorizationMessageExceptionRes(parsedOutput);
            default:
                const parsedBody = parsedOutput.body;
                return throwDefaultError({
                    output,
                    parsedBody: parsedBody.Error,
                    errorCode,
                });
        }
    };
    const de_ExpiredTokenExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = de_ExpiredTokenException(body.Error);
        const exception = new ExpiredTokenException({
            $metadata: deserializeMetadata(parsedOutput),
            ...deserialized,
        });
        return decorateServiceException$3(exception, body);
    };
    const de_IDPCommunicationErrorExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = de_IDPCommunicationErrorException(body.Error);
        const exception = new IDPCommunicationErrorException({
            $metadata: deserializeMetadata(parsedOutput),
            ...deserialized,
        });
        return decorateServiceException$3(exception, body);
    };
    const de_IDPRejectedClaimExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = de_IDPRejectedClaimException(body.Error);
        const exception = new IDPRejectedClaimException({
            $metadata: deserializeMetadata(parsedOutput),
            ...deserialized,
        });
        return decorateServiceException$3(exception, body);
    };
    const de_InvalidAuthorizationMessageExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = de_InvalidAuthorizationMessageException(body.Error);
        const exception = new InvalidAuthorizationMessageException({
            $metadata: deserializeMetadata(parsedOutput),
            ...deserialized,
        });
        return decorateServiceException$3(exception, body);
    };
    const de_InvalidIdentityTokenExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = de_InvalidIdentityTokenException(body.Error);
        const exception = new InvalidIdentityTokenException({
            $metadata: deserializeMetadata(parsedOutput),
            ...deserialized,
        });
        return decorateServiceException$3(exception, body);
    };
    const de_MalformedPolicyDocumentExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = de_MalformedPolicyDocumentException(body.Error);
        const exception = new MalformedPolicyDocumentException({
            $metadata: deserializeMetadata(parsedOutput),
            ...deserialized,
        });
        return decorateServiceException$3(exception, body);
    };
    const de_PackedPolicyTooLargeExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = de_PackedPolicyTooLargeException(body.Error);
        const exception = new PackedPolicyTooLargeException({
            $metadata: deserializeMetadata(parsedOutput),
            ...deserialized,
        });
        return decorateServiceException$3(exception, body);
    };
    const de_RegionDisabledExceptionRes = async (parsedOutput, context) => {
        const body = parsedOutput.body;
        const deserialized = de_RegionDisabledException(body.Error);
        const exception = new RegionDisabledException({
            $metadata: deserializeMetadata(parsedOutput),
            ...deserialized,
        });
        return decorateServiceException$3(exception, body);
    };
    const se_AssumeRoleRequest = (input, context) => {
        const entries = {};
        if (input[_RA] != null) {
            entries[_RA] = input[_RA];
        }
        if (input[_RSN] != null) {
            entries[_RSN] = input[_RSN];
        }
        if (input[_PA] != null) {
            const memberEntries = se_policyDescriptorListType(input[_PA]);
            if (input[_PA]?.length === 0) {
                entries.PolicyArns = [];
            }
            Object.entries(memberEntries).forEach(([key, value]) => {
                const loc = `PolicyArns.${key}`;
                entries[loc] = value;
            });
        }
        if (input[_P] != null) {
            entries[_P] = input[_P];
        }
        if (input[_DS] != null) {
            entries[_DS] = input[_DS];
        }
        if (input[_T] != null) {
            const memberEntries = se_tagListType(input[_T]);
            if (input[_T]?.length === 0) {
                entries.Tags = [];
            }
            Object.entries(memberEntries).forEach(([key, value]) => {
                const loc = `Tags.${key}`;
                entries[loc] = value;
            });
        }
        if (input[_TTK] != null) {
            const memberEntries = se_tagKeyListType(input[_TTK]);
            if (input[_TTK]?.length === 0) {
                entries.TransitiveTagKeys = [];
            }
            Object.entries(memberEntries).forEach(([key, value]) => {
                const loc = `TransitiveTagKeys.${key}`;
                entries[loc] = value;
            });
        }
        if (input[_EI] != null) {
            entries[_EI] = input[_EI];
        }
        if (input[_SN] != null) {
            entries[_SN] = input[_SN];
        }
        if (input[_TC] != null) {
            entries[_TC] = input[_TC];
        }
        if (input[_SI] != null) {
            entries[_SI] = input[_SI];
        }
        if (input[_PC] != null) {
            const memberEntries = se_ProvidedContextsListType(input[_PC]);
            if (input[_PC]?.length === 0) {
                entries.ProvidedContexts = [];
            }
            Object.entries(memberEntries).forEach(([key, value]) => {
                const loc = `ProvidedContexts.${key}`;
                entries[loc] = value;
            });
        }
        return entries;
    };
    const se_AssumeRoleWithWebIdentityRequest = (input, context) => {
        const entries = {};
        if (input[_RA] != null) {
            entries[_RA] = input[_RA];
        }
        if (input[_RSN] != null) {
            entries[_RSN] = input[_RSN];
        }
        if (input[_WIT] != null) {
            entries[_WIT] = input[_WIT];
        }
        if (input[_PI] != null) {
            entries[_PI] = input[_PI];
        }
        if (input[_PA] != null) {
            const memberEntries = se_policyDescriptorListType(input[_PA]);
            if (input[_PA]?.length === 0) {
                entries.PolicyArns = [];
            }
            Object.entries(memberEntries).forEach(([key, value]) => {
                const loc = `PolicyArns.${key}`;
                entries[loc] = value;
            });
        }
        if (input[_P] != null) {
            entries[_P] = input[_P];
        }
        if (input[_DS] != null) {
            entries[_DS] = input[_DS];
        }
        return entries;
    };
    const se_policyDescriptorListType = (input, context) => {
        const entries = {};
        let counter = 1;
        for (const entry of input) {
            if (entry === null) {
                continue;
            }
            const memberEntries = se_PolicyDescriptorType(entry);
            Object.entries(memberEntries).forEach(([key, value]) => {
                entries[`member.${counter}.${key}`] = value;
            });
            counter++;
        }
        return entries;
    };
    const se_PolicyDescriptorType = (input, context) => {
        const entries = {};
        if (input[_a] != null) {
            entries[_a] = input[_a];
        }
        return entries;
    };
    const se_ProvidedContext = (input, context) => {
        const entries = {};
        if (input[_PAro] != null) {
            entries[_PAro] = input[_PAro];
        }
        if (input[_CA] != null) {
            entries[_CA] = input[_CA];
        }
        return entries;
    };
    const se_ProvidedContextsListType = (input, context) => {
        const entries = {};
        let counter = 1;
        for (const entry of input) {
            if (entry === null) {
                continue;
            }
            const memberEntries = se_ProvidedContext(entry);
            Object.entries(memberEntries).forEach(([key, value]) => {
                entries[`member.${counter}.${key}`] = value;
            });
            counter++;
        }
        return entries;
    };
    const se_Tag = (input, context) => {
        const entries = {};
        if (input[_K] != null) {
            entries[_K] = input[_K];
        }
        if (input[_Va] != null) {
            entries[_Va] = input[_Va];
        }
        return entries;
    };
    const se_tagKeyListType = (input, context) => {
        const entries = {};
        let counter = 1;
        for (const entry of input) {
            if (entry === null) {
                continue;
            }
            entries[`member.${counter}`] = entry;
            counter++;
        }
        return entries;
    };
    const se_tagListType = (input, context) => {
        const entries = {};
        let counter = 1;
        for (const entry of input) {
            if (entry === null) {
                continue;
            }
            const memberEntries = se_Tag(entry);
            Object.entries(memberEntries).forEach(([key, value]) => {
                entries[`member.${counter}.${key}`] = value;
            });
            counter++;
        }
        return entries;
    };
    const de_AssumedRoleUser = (output, context) => {
        const contents = {};
        if (output[_ARI] != null) {
            contents[_ARI] = expectString$3(output[_ARI]);
        }
        if (output[_Ar] != null) {
            contents[_Ar] = expectString$3(output[_Ar]);
        }
        return contents;
    };
    const de_AssumeRoleResponse = (output, context) => {
        const contents = {};
        if (output[_C] != null) {
            contents[_C] = de_Credentials(output[_C]);
        }
        if (output[_ARU] != null) {
            contents[_ARU] = de_AssumedRoleUser(output[_ARU]);
        }
        if (output[_PPS] != null) {
            contents[_PPS] = strictParseInt32(output[_PPS]);
        }
        if (output[_SI] != null) {
            contents[_SI] = expectString$3(output[_SI]);
        }
        return contents;
    };
    const de_AssumeRoleWithWebIdentityResponse = (output, context) => {
        const contents = {};
        if (output[_C] != null) {
            contents[_C] = de_Credentials(output[_C]);
        }
        if (output[_SFWIT] != null) {
            contents[_SFWIT] = expectString$3(output[_SFWIT]);
        }
        if (output[_ARU] != null) {
            contents[_ARU] = de_AssumedRoleUser(output[_ARU]);
        }
        if (output[_PPS] != null) {
            contents[_PPS] = strictParseInt32(output[_PPS]);
        }
        if (output[_Pr] != null) {
            contents[_Pr] = expectString$3(output[_Pr]);
        }
        if (output[_Au] != null) {
            contents[_Au] = expectString$3(output[_Au]);
        }
        if (output[_SI] != null) {
            contents[_SI] = expectString$3(output[_SI]);
        }
        return contents;
    };
    const de_Credentials = (output, context) => {
        const contents = {};
        if (output[_AKI] != null) {
            contents[_AKI] = expectString$3(output[_AKI]);
        }
        if (output[_SAK] != null) {
            contents[_SAK] = expectString$3(output[_SAK]);
        }
        if (output[_STe] != null) {
            contents[_STe] = expectString$3(output[_STe]);
        }
        if (output[_E] != null) {
            contents[_E] = expectNonNull$3(parseRfc3339DateTimeWithOffset(output[_E]));
        }
        return contents;
    };
    const de_ExpiredTokenException = (output, context) => {
        const contents = {};
        if (output[_m] != null) {
            contents[_m] = expectString$3(output[_m]);
        }
        return contents;
    };
    const de_IDPCommunicationErrorException = (output, context) => {
        const contents = {};
        if (output[_m] != null) {
            contents[_m] = expectString$3(output[_m]);
        }
        return contents;
    };
    const de_IDPRejectedClaimException = (output, context) => {
        const contents = {};
        if (output[_m] != null) {
            contents[_m] = expectString$3(output[_m]);
        }
        return contents;
    };
    const de_InvalidAuthorizationMessageException = (output, context) => {
        const contents = {};
        if (output[_m] != null) {
            contents[_m] = expectString$3(output[_m]);
        }
        return contents;
    };
    const de_InvalidIdentityTokenException = (output, context) => {
        const contents = {};
        if (output[_m] != null) {
            contents[_m] = expectString$3(output[_m]);
        }
        return contents;
    };
    const de_MalformedPolicyDocumentException = (output, context) => {
        const contents = {};
        if (output[_m] != null) {
            contents[_m] = expectString$3(output[_m]);
        }
        return contents;
    };
    const de_PackedPolicyTooLargeException = (output, context) => {
        const contents = {};
        if (output[_m] != null) {
            contents[_m] = expectString$3(output[_m]);
        }
        return contents;
    };
    const de_RegionDisabledException = (output, context) => {
        const contents = {};
        if (output[_m] != null) {
            contents[_m] = expectString$3(output[_m]);
        }
        return contents;
    };
    const deserializeMetadata = (output) => ({
        httpStatusCode: output.statusCode,
        requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
        extendedRequestId: output.headers["x-amz-id-2"],
        cfId: output.headers["x-amz-cf-id"],
    });
    const throwDefaultError = withBaseException$3(STSServiceException);
    const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
        const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
        const contents = {
            protocol,
            hostname,
            port,
            method: "POST",
            path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
            headers,
        };
        if (body !== undefined) {
            contents.body = body;
        }
        return new HttpRequest$4(contents);
    };
    const SHARED_HEADERS = {
        "content-type": "application/x-www-form-urlencoded",
    };
    const _ = "2011-06-15";
    const _A = "Action";
    const _AKI = "AccessKeyId";
    const _AR = "AssumeRole";
    const _ARI = "AssumedRoleId";
    const _ARU = "AssumedRoleUser";
    const _ARWWI = "AssumeRoleWithWebIdentity";
    const _Ar = "Arn";
    const _Au = "Audience";
    const _C = "Credentials";
    const _CA = "ContextAssertion";
    const _DS = "DurationSeconds";
    const _E = "Expiration";
    const _EI = "ExternalId";
    const _K = "Key";
    const _P = "Policy";
    const _PA = "PolicyArns";
    const _PAro = "ProviderArn";
    const _PC = "ProvidedContexts";
    const _PI = "ProviderId";
    const _PPS = "PackedPolicySize";
    const _Pr = "Provider";
    const _RA = "RoleArn";
    const _RSN = "RoleSessionName";
    const _SAK = "SecretAccessKey";
    const _SFWIT = "SubjectFromWebIdentityToken";
    const _SI = "SourceIdentity";
    const _SN = "SerialNumber";
    const _STe = "SessionToken";
    const _T = "Tags";
    const _TC = "TokenCode";
    const _TTK = "TransitiveTagKeys";
    const _V = "Version";
    const _Va = "Value";
    const _WIT = "WebIdentityToken";
    const _a = "arn";
    const _m = "message";
    const buildFormUrlencodedString = (formEntries) => Object.entries(formEntries)
        .map(([key, value]) => extendedEncodeURIComponent$2(key) + "=" + extendedEncodeURIComponent$2(value))
        .join("&");
    const loadQueryErrorCode = (output, data) => {
        if (data.Error?.Code !== undefined) {
            return data.Error.Code;
        }
        if (output.statusCode == 404) {
            return "NotFound";
        }
    };

    class AssumeRoleCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("AWSSecurityTokenServiceV20110615", "AssumeRole", {})
        .n("STSClient", "AssumeRoleCommand")
        .f(void 0, AssumeRoleResponseFilterSensitiveLog)
        .ser(se_AssumeRoleCommand)
        .de(de_AssumeRoleCommand)
        .build() {
    }

    class AssumeRoleWithWebIdentityCommand extends Command$3
        .classBuilder()
        .ep({
        ...commonParams,
    })
        .m(function (Command, cs, config, o) {
        return [
            getSerdePlugin$3(config, this.serialize, this.deserialize),
            getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        ];
    })
        .s("AWSSecurityTokenServiceV20110615", "AssumeRoleWithWebIdentity", {})
        .n("STSClient", "AssumeRoleWithWebIdentityCommand")
        .f(AssumeRoleWithWebIdentityRequestFilterSensitiveLog, AssumeRoleWithWebIdentityResponseFilterSensitiveLog)
        .ser(se_AssumeRoleWithWebIdentityCommand)
        .de(de_AssumeRoleWithWebIdentityCommand)
        .build() {
    }

    const ASSUME_ROLE_DEFAULT_REGION = "us-east-1";
    const getAccountIdFromAssumedRoleUser = (assumedRoleUser) => {
        if (typeof assumedRoleUser?.Arn === "string") {
            const arnComponents = assumedRoleUser.Arn.split(":");
            if (arnComponents.length > 4 && arnComponents[4] !== "") {
                return arnComponents[4];
            }
        }
        return undefined;
    };
    const resolveRegion = async (_region, _parentRegion, credentialProviderLogger) => {
        const region = typeof _region === "function" ? await _region() : _region;
        const parentRegion = typeof _parentRegion === "function" ? await _parentRegion() : _parentRegion;
        credentialProviderLogger?.debug?.("@aws-sdk/client-sts::resolveRegion", "accepting first of:", `${region} (provider)`, `${parentRegion} (parent client)`, `${ASSUME_ROLE_DEFAULT_REGION} (STS default)`);
        return region ?? parentRegion ?? ASSUME_ROLE_DEFAULT_REGION;
    };
    const getDefaultRoleAssumerWithWebIdentity$1 = (stsOptions, stsClientCtor) => {
        let stsClient;
        return async (params) => {
            if (!stsClient) {
                const { logger = stsOptions?.parentClientConfig?.logger, region, requestHandler = stsOptions?.parentClientConfig?.requestHandler, credentialProviderLogger, } = stsOptions;
                const resolvedRegion = await resolveRegion(region, stsOptions?.parentClientConfig?.region, credentialProviderLogger);
                stsClient = new stsClientCtor({
                    region: resolvedRegion,
                    requestHandler: requestHandler,
                    logger: logger,
                });
            }
            const { Credentials, AssumedRoleUser } = await stsClient.send(new AssumeRoleWithWebIdentityCommand(params));
            if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
                throw new Error(`Invalid response from STS.assumeRoleWithWebIdentity call with role ${params.RoleArn}`);
            }
            const accountId = getAccountIdFromAssumedRoleUser(AssumedRoleUser);
            return {
                accessKeyId: Credentials.AccessKeyId,
                secretAccessKey: Credentials.SecretAccessKey,
                sessionToken: Credentials.SessionToken,
                expiration: Credentials.Expiration,
                ...(Credentials.CredentialScope && { credentialScope: Credentials.CredentialScope }),
                ...(accountId && { accountId }),
            };
        };
    };

    const getCustomizableStsClientCtor = (baseCtor, customizations) => {
        if (!customizations)
            return baseCtor;
        else
            return class CustomizableSTSClient extends baseCtor {
                constructor(config) {
                    super(config);
                    for (const customization of customizations) {
                        this.middlewareStack.use(customization);
                    }
                }
            };
    };
    const getDefaultRoleAssumerWithWebIdentity = (stsOptions = {}, stsPlugins) => getDefaultRoleAssumerWithWebIdentity$1(stsOptions, getCustomizableStsClientCtor(STSClient, stsPlugins));

    var index = /*#__PURE__*/Object.freeze({
        __proto__: null,
        $Command: Command$3,
        AssumeRoleCommand: AssumeRoleCommand,
        AssumeRoleResponseFilterSensitiveLog: AssumeRoleResponseFilterSensitiveLog,
        AssumeRoleWithWebIdentityCommand: AssumeRoleWithWebIdentityCommand,
        AssumeRoleWithWebIdentityRequestFilterSensitiveLog: AssumeRoleWithWebIdentityRequestFilterSensitiveLog,
        AssumeRoleWithWebIdentityResponseFilterSensitiveLog: AssumeRoleWithWebIdentityResponseFilterSensitiveLog,
        CredentialsFilterSensitiveLog: CredentialsFilterSensitiveLog,
        ExpiredTokenException: ExpiredTokenException,
        IDPCommunicationErrorException: IDPCommunicationErrorException,
        IDPRejectedClaimException: IDPRejectedClaimException,
        InvalidAuthorizationMessageException: InvalidAuthorizationMessageException,
        InvalidIdentityTokenException: InvalidIdentityTokenException,
        MalformedPolicyDocumentException: MalformedPolicyDocumentException,
        PackedPolicyTooLargeException: PackedPolicyTooLargeException,
        RegionDisabledException: RegionDisabledException,
        STSClient: STSClient,
        STSServiceException: STSServiceException,
        __Client: Client$3,
        getDefaultRoleAssumerWithWebIdentity: getDefaultRoleAssumerWithWebIdentity
    });

    var loadSts = /*#__PURE__*/Object.freeze({
        __proto__: null,
        AssumeRoleCommand: AssumeRoleCommand,
        STSClient: STSClient
    });

    exports.$Command = Command$3;
    exports.AccessDeniedException = AccessDeniedException$3;
    exports.AssociateTrackerConsumerCommand = AssociateTrackerConsumerCommand;
    exports.BatchDeleteDevicePositionHistoryCommand = BatchDeleteDevicePositionHistoryCommand;
    exports.BatchDeleteGeofenceCommand = BatchDeleteGeofenceCommand;
    exports.BatchEvaluateGeofencesCommand = BatchEvaluateGeofencesCommand;
    exports.BatchEvaluateGeofencesRequestFilterSensitiveLog = BatchEvaluateGeofencesRequestFilterSensitiveLog;
    exports.BatchGetDevicePositionCommand = BatchGetDevicePositionCommand;
    exports.BatchGetDevicePositionResponseFilterSensitiveLog = BatchGetDevicePositionResponseFilterSensitiveLog;
    exports.BatchPutGeofenceCommand = BatchPutGeofenceCommand;
    exports.BatchPutGeofenceRequestEntryFilterSensitiveLog = BatchPutGeofenceRequestEntryFilterSensitiveLog;
    exports.BatchPutGeofenceRequestFilterSensitiveLog = BatchPutGeofenceRequestFilterSensitiveLog;
    exports.BatchUpdateDevicePositionCommand = BatchUpdateDevicePositionCommand;
    exports.BatchUpdateDevicePositionRequestFilterSensitiveLog = BatchUpdateDevicePositionRequestFilterSensitiveLog;
    exports.CalculateRouteCommand = CalculateRouteCommand;
    exports.CalculateRouteMatrixCommand = CalculateRouteMatrixCommand$1;
    exports.CalculateRouteMatrixRequestFilterSensitiveLog = CalculateRouteMatrixRequestFilterSensitiveLog$1;
    exports.CalculateRouteMatrixResponseFilterSensitiveLog = CalculateRouteMatrixResponseFilterSensitiveLog$1;
    exports.CalculateRouteRequestFilterSensitiveLog = CalculateRouteRequestFilterSensitiveLog;
    exports.CalculateRouteResponseFilterSensitiveLog = CalculateRouteResponseFilterSensitiveLog;
    exports.CalculateRouteSummaryFilterSensitiveLog = CalculateRouteSummaryFilterSensitiveLog;
    exports.CircleFilterSensitiveLog = CircleFilterSensitiveLog$1;
    exports.ConflictException = ConflictException;
    exports.CreateGeofenceCollectionCommand = CreateGeofenceCollectionCommand;
    exports.CreateKeyCommand = CreateKeyCommand;
    exports.CreateKeyResponseFilterSensitiveLog = CreateKeyResponseFilterSensitiveLog;
    exports.CreateMapCommand = CreateMapCommand;
    exports.CreatePlaceIndexCommand = CreatePlaceIndexCommand;
    exports.CreateRouteCalculatorCommand = CreateRouteCalculatorCommand;
    exports.CreateTrackerCommand = CreateTrackerCommand;
    exports.DeleteGeofenceCollectionCommand = DeleteGeofenceCollectionCommand;
    exports.DeleteKeyCommand = DeleteKeyCommand;
    exports.DeleteMapCommand = DeleteMapCommand;
    exports.DeletePlaceIndexCommand = DeletePlaceIndexCommand;
    exports.DeleteRouteCalculatorCommand = DeleteRouteCalculatorCommand;
    exports.DeleteTrackerCommand = DeleteTrackerCommand;
    exports.DescribeGeofenceCollectionCommand = DescribeGeofenceCollectionCommand;
    exports.DescribeKeyCommand = DescribeKeyCommand;
    exports.DescribeKeyResponseFilterSensitiveLog = DescribeKeyResponseFilterSensitiveLog;
    exports.DescribeMapCommand = DescribeMapCommand;
    exports.DescribePlaceIndexCommand = DescribePlaceIndexCommand;
    exports.DescribeRouteCalculatorCommand = DescribeRouteCalculatorCommand;
    exports.DescribeTrackerCommand = DescribeTrackerCommand;
    exports.DevicePositionFilterSensitiveLog = DevicePositionFilterSensitiveLog;
    exports.DevicePositionUpdateFilterSensitiveLog = DevicePositionUpdateFilterSensitiveLog;
    exports.DeviceStateFilterSensitiveLog = DeviceStateFilterSensitiveLog;
    exports.DisassociateTrackerConsumerCommand = DisassociateTrackerConsumerCommand;
    exports.ForecastGeofenceEventsCommand = ForecastGeofenceEventsCommand;
    exports.ForecastGeofenceEventsDeviceStateFilterSensitiveLog = ForecastGeofenceEventsDeviceStateFilterSensitiveLog;
    exports.ForecastGeofenceEventsRequestFilterSensitiveLog = ForecastGeofenceEventsRequestFilterSensitiveLog;
    exports.ForecastGeofenceEventsResponseFilterSensitiveLog = ForecastGeofenceEventsResponseFilterSensitiveLog;
    exports.ForecastedEventFilterSensitiveLog = ForecastedEventFilterSensitiveLog;
    exports.GeoMapsClient = GeoMapsClient;
    exports.GeoPlacesClient = GeoPlacesClient;
    exports.GeoRoutesClient = GeoRoutesClient;
    exports.GeofenceGeometryFilterSensitiveLog = GeofenceGeometryFilterSensitiveLog;
    exports.GetDevicePositionCommand = GetDevicePositionCommand;
    exports.GetDevicePositionHistoryCommand = GetDevicePositionHistoryCommand;
    exports.GetDevicePositionHistoryResponseFilterSensitiveLog = GetDevicePositionHistoryResponseFilterSensitiveLog;
    exports.GetDevicePositionResponseFilterSensitiveLog = GetDevicePositionResponseFilterSensitiveLog;
    exports.GetGeofenceCommand = GetGeofenceCommand;
    exports.GetGeofenceResponseFilterSensitiveLog = GetGeofenceResponseFilterSensitiveLog;
    exports.GetMapGlyphsCommand = GetMapGlyphsCommand;
    exports.GetMapGlyphsRequestFilterSensitiveLog = GetMapGlyphsRequestFilterSensitiveLog;
    exports.GetMapSpritesCommand = GetMapSpritesCommand;
    exports.GetMapSpritesRequestFilterSensitiveLog = GetMapSpritesRequestFilterSensitiveLog;
    exports.GetMapStyleDescriptorCommand = GetMapStyleDescriptorCommand;
    exports.GetMapStyleDescriptorRequestFilterSensitiveLog = GetMapStyleDescriptorRequestFilterSensitiveLog;
    exports.GetMapTileCommand = GetMapTileCommand;
    exports.GetMapTileRequestFilterSensitiveLog = GetMapTileRequestFilterSensitiveLog;
    exports.GetPlaceCommand = GetPlaceCommand$1;
    exports.GetPlaceRequestFilterSensitiveLog = GetPlaceRequestFilterSensitiveLog$1;
    exports.GetPlaceResponseFilterSensitiveLog = GetPlaceResponseFilterSensitiveLog$1;
    exports.InferredStateFilterSensitiveLog = InferredStateFilterSensitiveLog;
    exports.InternalServerException = InternalServerException$3;
    exports.LegFilterSensitiveLog = LegFilterSensitiveLog;
    exports.LegGeometryFilterSensitiveLog = LegGeometryFilterSensitiveLog;
    exports.ListDevicePositionsCommand = ListDevicePositionsCommand;
    exports.ListDevicePositionsRequestFilterSensitiveLog = ListDevicePositionsRequestFilterSensitiveLog;
    exports.ListDevicePositionsResponseEntryFilterSensitiveLog = ListDevicePositionsResponseEntryFilterSensitiveLog;
    exports.ListDevicePositionsResponseFilterSensitiveLog = ListDevicePositionsResponseFilterSensitiveLog;
    exports.ListGeofenceCollectionsCommand = ListGeofenceCollectionsCommand;
    exports.ListGeofenceResponseEntryFilterSensitiveLog = ListGeofenceResponseEntryFilterSensitiveLog;
    exports.ListGeofencesCommand = ListGeofencesCommand;
    exports.ListGeofencesResponseFilterSensitiveLog = ListGeofencesResponseFilterSensitiveLog;
    exports.ListKeysCommand = ListKeysCommand;
    exports.ListMapsCommand = ListMapsCommand;
    exports.ListPlaceIndexesCommand = ListPlaceIndexesCommand;
    exports.ListRouteCalculatorsCommand = ListRouteCalculatorsCommand;
    exports.ListTagsForResourceCommand = ListTagsForResourceCommand;
    exports.ListTrackerConsumersCommand = ListTrackerConsumersCommand;
    exports.ListTrackersCommand = ListTrackersCommand;
    exports.Location = Location;
    exports.LocationClient = LocationClient;
    exports.LocationServiceException = LocationServiceException;
    exports.PlaceFilterSensitiveLog = PlaceFilterSensitiveLog;
    exports.PlaceGeometryFilterSensitiveLog = PlaceGeometryFilterSensitiveLog;
    exports.PutGeofenceCommand = PutGeofenceCommand;
    exports.PutGeofenceRequestFilterSensitiveLog = PutGeofenceRequestFilterSensitiveLog;
    exports.ResourceNotFoundException = ResourceNotFoundException$2;
    exports.SearchForPositionResultFilterSensitiveLog = SearchForPositionResultFilterSensitiveLog;
    exports.SearchForTextResultFilterSensitiveLog = SearchForTextResultFilterSensitiveLog;
    exports.SearchPlaceIndexForPositionCommand = SearchPlaceIndexForPositionCommand;
    exports.SearchPlaceIndexForPositionRequestFilterSensitiveLog = SearchPlaceIndexForPositionRequestFilterSensitiveLog;
    exports.SearchPlaceIndexForPositionResponseFilterSensitiveLog = SearchPlaceIndexForPositionResponseFilterSensitiveLog;
    exports.SearchPlaceIndexForPositionSummaryFilterSensitiveLog = SearchPlaceIndexForPositionSummaryFilterSensitiveLog;
    exports.SearchPlaceIndexForSuggestionsCommand = SearchPlaceIndexForSuggestionsCommand;
    exports.SearchPlaceIndexForSuggestionsRequestFilterSensitiveLog = SearchPlaceIndexForSuggestionsRequestFilterSensitiveLog;
    exports.SearchPlaceIndexForSuggestionsResponseFilterSensitiveLog = SearchPlaceIndexForSuggestionsResponseFilterSensitiveLog;
    exports.SearchPlaceIndexForSuggestionsSummaryFilterSensitiveLog = SearchPlaceIndexForSuggestionsSummaryFilterSensitiveLog;
    exports.SearchPlaceIndexForTextCommand = SearchPlaceIndexForTextCommand;
    exports.SearchPlaceIndexForTextRequestFilterSensitiveLog = SearchPlaceIndexForTextRequestFilterSensitiveLog;
    exports.SearchPlaceIndexForTextResponseFilterSensitiveLog = SearchPlaceIndexForTextResponseFilterSensitiveLog;
    exports.SearchPlaceIndexForTextSummaryFilterSensitiveLog = SearchPlaceIndexForTextSummaryFilterSensitiveLog;
    exports.ServiceQuotaExceededException = ServiceQuotaExceededException;
    exports.StepFilterSensitiveLog = StepFilterSensitiveLog;
    exports.TagResourceCommand = TagResourceCommand;
    exports.ThrottlingException = ThrottlingException$3;
    exports.TrackingFilterGeometryFilterSensitiveLog = TrackingFilterGeometryFilterSensitiveLog;
    exports.UntagResourceCommand = UntagResourceCommand;
    exports.UpdateGeofenceCollectionCommand = UpdateGeofenceCollectionCommand;
    exports.UpdateKeyCommand = UpdateKeyCommand;
    exports.UpdateMapCommand = UpdateMapCommand;
    exports.UpdatePlaceIndexCommand = UpdatePlaceIndexCommand;
    exports.UpdateRouteCalculatorCommand = UpdateRouteCalculatorCommand;
    exports.UpdateTrackerCommand = UpdateTrackerCommand;
    exports.ValidationException = ValidationException$3;
    exports.VerifyDevicePositionCommand = VerifyDevicePositionCommand;
    exports.VerifyDevicePositionRequestFilterSensitiveLog = VerifyDevicePositionRequestFilterSensitiveLog;
    exports.VerifyDevicePositionResponseFilterSensitiveLog = VerifyDevicePositionResponseFilterSensitiveLog;
    exports.__Client = Client$3;
    exports.fromCognitoIdentity = fromCognitoIdentity;
    exports.fromCognitoIdentityPool = fromCognitoIdentityPool;
    exports.fromHttp = fromHttp;
    exports.fromTemporaryCredentials = fromTemporaryCredentials;
    exports.fromWebToken = fromWebToken;
    exports.maps = index$3;
    exports.paginateForecastGeofenceEvents = paginateForecastGeofenceEvents;
    exports.paginateGetDevicePositionHistory = paginateGetDevicePositionHistory;
    exports.paginateListDevicePositions = paginateListDevicePositions;
    exports.paginateListGeofenceCollections = paginateListGeofenceCollections;
    exports.paginateListGeofences = paginateListGeofences;
    exports.paginateListKeys = paginateListKeys;
    exports.paginateListMaps = paginateListMaps;
    exports.paginateListPlaceIndexes = paginateListPlaceIndexes;
    exports.paginateListRouteCalculators = paginateListRouteCalculators;
    exports.paginateListTrackerConsumers = paginateListTrackerConsumers;
    exports.paginateListTrackers = paginateListTrackers;
    exports.places = index$2;
    exports.routes = index$1;
    exports.withAPIKey = amazonLocationAuthHelperExports.withAPIKey;
    exports.withIdentityPoolId = amazonLocationAuthHelperExports.withIdentityPoolId;
}));
